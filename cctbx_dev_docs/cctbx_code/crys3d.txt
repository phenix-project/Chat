

 *******************************************************************************
crys3d/__init__.py


 *******************************************************************************


 *******************************************************************************
crys3d/command_line/HKLinfo.py
# LIBTBX_SET_DISPATCHER_NAME phenix.HKLinfo
# LIBTBX_SET_DISPATCHER_NAME cctbx.HKLinfo
from __future__ import absolute_import, division, print_function

from iotbx.cli_parser import run_program
from crys3d.programs import HKLinfo

if __name__ == '__main__':
  run_program(program_class=HKLinfo.Program)



 *******************************************************************************


 *******************************************************************************
crys3d/command_line/HKLviewer.py
# LIBTBX_SET_DISPATCHER_NAME phenix.HKLviewer
# LIBTBX_SET_DISPATCHER_NAME cctbx.HKLviewer
# LIBTBX_SET_DISPATCHER_NAME phasertng.HKLviewer
from __future__ import absolute_import, division, print_function

from crys3d.hklviewer import HKLviewer


if (__name__ == "__main__") :
  HKLviewer.run()


 *******************************************************************************


 *******************************************************************************
crys3d/command_line/__init__.py


 *******************************************************************************


 *******************************************************************************
crys3d/command_line/compare_datasets.py
from __future__ import absolute_import, division, print_function
# LIBTBX_SET_DISPATCHER_NAME phenix.compare_datasets
# LIBTBX_PRE_DISPATCHER_INCLUDE_SH export PHENIX_GUI_ENVIRONMENT=1
# LIBTBX_PRE_DISPATCHER_INCLUDE_SH export BOOST_ADAPTBX_FPE_DEFAULT=1

from crys3d.hklview import comparison
from wxtbx import icons
import iotbx.phil
from libtbx.utils import Sorry, Usage
import wx
import os
import sys

# TODO
master_phil = iotbx.phil.parse("""
file_name_1 = None
  .type = path
label_1 = None
  .type = str
file_name_2 = None
  .type = path
label_2 = None
  .type = str
include scope cctbx.miller.display.master_phil
""", process_includes=True)

def run (args) :
  if ("--help" in args) or ("--options" in args) :
    raise Usage("""\
phenix.compare_datasets data1.mtz data2.mtz

Side-by-side visualization of pseudo-precession planes through reciprocal
space for a pair of datasets - essentially a duplex version of 2D view in
phenix.data_viewer.
""")
  a = wx.App(0)
  app_icon = wx.EmptyIcon()
  app_icon.CopyFromBitmap(icons.hklview_2d.GetBitmap())
  if (wx.VERSION >= (2,9)) :
    tb_icon = wx.TaskBarIcon(wx.TBI_DOCK)
  else :
    tb_icon = wx.TaskBarIcon()
  tb_icon.SetIcon(app_icon, "PHENIX data viewer")
  frame = comparison.ComparisonFrame(None, -1, "Dataset comparison")
  frame.Show()
  file_name_1 = file_name_2 = None
  for arg in args :
    if (os.path.isfile(arg)) :
      if (file_name_1 is None) :
        file_name_1 = arg
      elif (file_name_2 is None) :
        file_name_2 = arg
      else :
        raise Sorry("Only two files at a time are supported.")
  if (file_name_1 is not None) and (file_name_2 is not None) :
    frame.load_files(file_name_1, file_name_2)
  a.SetTopWindow(frame)
  a.Bind(wx.EVT_WINDOW_DESTROY, lambda evt: tb_icon.Destroy(), frame)
  a.MainLoop()

if (__name__ == "__main__") :
  run(sys.argv[1:])


 *******************************************************************************


 *******************************************************************************
crys3d/command_line/hklview.py
# LIBTBX_SET_DISPATCHER_NAME phenix.data_viewer
# LIBTBX_SET_DISPATCHER_NAME cctbx.data_viewer
# LIBTBX_PRE_DISPATCHER_INCLUDE_SH export PHENIX_GUI_ENVIRONMENT=1
# LIBTBX_PRE_DISPATCHER_INCLUDE_SH export BOOST_ADAPTBX_FPE_DEFAULT=1

from __future__ import absolute_import, division, print_function
from crys3d.hklview.frames import *
from cctbx.miller.display import master_phil
from wxtbx import icons
import wxtbx.app
import iotbx.phil
import wx
import sys

def run (args) :
  ma = None
  show_2d = False
  if ("--2d" in args) :
    show_2d = True
    args.remove("--2d")
  pcl = iotbx.phil.process_command_line_with_files(
    args=args,
    master_phil=master_phil,
    reflection_file_def="data",
    pdb_file_def="symmetry_file",
    usage_string="phenix.data_viewer f_obs.mtz [options]")
  settings = pcl.work.extract()
  a = wxtbx.app.CCTBXApp(0)
  app_icon = wx.EmptyIcon()
  app_icon.CopyFromBitmap(icons.hklview_3d.GetBitmap())
  if (wx.VERSION >= (2,9)) :
    tb_icon = wx.TaskBarIcon(wx.TBI_DOCK)
  else :
    tb_icon = wx.TaskBarIcon()
  tb_icon.SetIcon(app_icon, "PHENIX data viewer")
  a.hklview_settings = settings
  viewer_class = HKLViewFrame
  if (show_2d) :
    viewer_class = HKLViewFrame2D
  f = viewer_class(None, -1, "Reflection data viewer", size=(1024,768))
  f.Show()
  if (ma is not None) :
    f.set_miller_array(ma)
  elif (settings.data is not None) :
    f.load_reflections_file(settings.data)
  else :
    f.OnLoadFile(None)
  a.SetTopWindow(f)
  a.Bind(wx.EVT_WINDOW_DESTROY, lambda evt: tb_icon.Destroy(), f)
  a.MainLoop()

if (__name__ == "__main__") :
  run(sys.argv[1:])


 *******************************************************************************


 *******************************************************************************
crys3d/command_line/make_install_HKLviewer_ChimeraX.py
# LIBTBX_SET_DISPATCHER_NAME cctbx.make_install_HKLviewer_ChimeraX

from __future__ import absolute_import, division, print_function

import subprocess, sys, shutil, os
from os.path import join as opj
import libtbx.load_env

# Bundle up a python wheel of the HKLviewer for chimeraX and subsequently install it into the local
# chimeraX installation
# Usage:
# cctbx.make_install_HKLviewer_ChimeraX "A:\Program Files\ChimeraX 1.2.5\bin\ChimeraX-console.exe"

if (__name__ == "__main__"):
  print("Bundling up and installing a ChimeraX wheel of cctbx.HKLviewer")
  if len(sys.argv) < 2:
    print("Specify the full path to the chimeraX commandline compiler as argument")
    exit()

  builddir = libtbx.env.under_root(os.path.join("build","ChimeraX_tools","HKLviewer","src"))
  wheeldir = libtbx.env.under_root(os.path.join("build","ChimeraX_tools","HKLviewer"))
  distdir = libtbx.env.under_dist("crys3d","hklviewer")

  shutil.copytree(opj(distdir,"chimeraX_wheel_src"), builddir, dirs_exist_ok=True)
  shutil.copy(opj(builddir,"bundle_info.xml"), wheeldir )
  os.remove(opj(builddir,"bundle_info.xml"))

  shutil.copy(opj(distdir,"helpers.py"), builddir)
  shutil.copy(opj(distdir,"HKLviewer.py"), builddir)
  shutil.copy(opj(distdir,"HKLviewerGui.py"), builddir)
  shutil.copy(opj(distdir,"qt.py"), builddir)
  shutil.copy(opj(distdir,"QtChromiumCheck.py"), builddir)

  cmdargs =  r'"%s" --nogui --cmd "devel install . ; exit"' %sys.argv[1]
  curdir = os.getcwd()
  os.chdir(wheeldir)
  buildproc = subprocess.Popen( cmdargs, shell=True, cwd=wheeldir,
                                    universal_newlines=True,
                                    stdin=subprocess.PIPE,
                                    stdout=subprocess.PIPE,
                                    stderr=subprocess.PIPE)
  out, err = buildproc.communicate()
  print(out)
  print(err)
  os.chdir(curdir)


 *******************************************************************************


 *******************************************************************************
crys3d/command_line/model_viewer.py
from __future__ import absolute_import, division, print_function
# LIBTBX_PRE_DISPATCHER_INCLUDE_SH export PHENIX_GUI_ENVIRONMENT=1
# LIBTBX_PRE_DISPATCHER_INCLUDE_SH export BOOST_ADAPTBX_FPE_DEFAULT=1

import cStringIO
from crys3d.wx_selection_editor import selection_editor_mixin
import wx
import libtbx.load_env
import sys, os, time

########################################################################
# CLASSES AND METHODS FOR STANDALONE VIEWER
#
class App (wx.App) :
  def __init__ (self, title="crys3d.wx_model_viewer", default_size=(800,600),
      viewer_class=selection_editor_mixin) :
    self.title = title
    self.default_size = default_size
    self.viewer_class = viewer_class
    wx.App.__init__(self, 0)

  def OnInit (self) :
    self.frame = wx.Frame(None, -1, self.title, pos=wx.DefaultPosition,
      size=self.default_size)
    self.frame.CreateStatusBar()
    box = wx.BoxSizer(wx.VERTICAL)
    self.view_objects = self.viewer_class(self.frame, size=(800,600))
    box.Add(self.view_objects, wx.EXPAND, wx.EXPAND)
    self.frame.SetSizer(box)
    box.SetSizeHints(self.frame)
    return True

def run (args, viewer_class=selection_editor_mixin) :
  import cStringIO
  pdb_files = []
  cif_files = []
  show_ss_restraints = False
  fast_connectivity = True
  for arg in args :
    if os.path.isfile(arg) :
      import iotbx.pdb
      if iotbx.pdb.is_pdb_file(arg) :
        pdb_files.append(os.path.abspath(arg))
      elif arg.endswith(".cif") :
        cif_files.append(os.path.abspath(arg))
    elif arg == "--ss" :
      show_ss_restraints = True
    elif arg in ["--thorough", "--slow", "--use_monomer_library"] :
      fast_connectivity = False
  if len(pdb_files) == 0 :
    print("Please specify a PDB file (and optional CIFs) on the command line.")
    return
  a = App(viewer_class=viewer_class)
  a.frame.Show()
  out = sys.stdout
  if not "--debug" in args :
    out = cStringIO.StringIO()
  for file_name in pdb_files :
    print("Reading PDB file %s" % file_name)
    import iotbx.pdb
    from mmtbx.monomer_library import pdb_interpretation
    from mmtbx import secondary_structure
    t1 = time.time()
    if fast_connectivity :
      pdb_in = iotbx.pdb.input(file_name)
      pdb_hierarchy = pdb_in.construct_hierarchy()
      atomic_bonds = pdb_hierarchy.distance_based_simple_two_way_bond_sets()
      acp_selection = None
    else :
      processed_pdb_file = pdb_interpretation.run(args=[file_name]+cif_files,
        log=out)
      pdb_hierarchy = processed_pdb_file.all_chain_proxies.pdb_hierarchy
      pdb_hierarchy.atoms().reset_i_seq()
      grm = processed_pdb_file.geometry_restraints_manager()
      acp_selection = processed_pdb_file.all_chain_proxies.selection
      if grm is None or grm.shell_sym_tables is None :
        raise Sorry("Atomic bonds could not be calculated for this model. "+
          "This is probably due to a missing CRYST1 record in the PDB file.")
      atomic_bonds = grm.shell_sym_tables[0].full_simple_connectivity()
    t2 = time.time()
    print("%.2fs" % (t2-t1))
    a.view_objects.add_model(file_name, pdb_hierarchy, atomic_bonds,
      mmtbx_selection_function=acp_selection)
    sec_str = secondary_structure.manager(
      pdb_hierarchy=pdb_hierarchy,
      xray_structure=None)
    a.view_objects.set_sec_str(file_name, sec_str.selections_as_ints())
    if show_ss_restraints and acp_selection is not None :
      bonds_table = secondary_structure.process_structure(params=None,
        processed_pdb_file=processed_pdb_file,
        tmp_dir=os.getcwd(),
        log=sys.stderr)
      a.view_objects.set_noncovalent_bonds(file_name, bonds_table.bonds)
      a.view_objects.flag_show_noncovalent_bonds = True
      a.view_objects.set_model_base_color([1.0,1.0,1.0], file_name)
      a.view_objects.set_color_mode("element")
  a.view_objects.force_update(recenter=True)
  a.MainLoop()

if __name__ == "__main__" :
  if "--test" in sys.argv :
    pdb_file = libtbx.env.find_in_repositories(
      relative_path="phenix_regression/pdb/1ywf.pdb",
      test=os.path.isfile)
    run([pdb_file, "--ss"])
  else :
    run(sys.argv[1:])


 *******************************************************************************


 *******************************************************************************
crys3d/command_line/multiplicity_viewer.py
# LIBTBX_SET_DISPATCHER_NAME cctbx.multiplicity_viewer
# LIBTBX_PRE_DISPATCHER_INCLUDE_SH export PHENIX_GUI_ENVIRONMENT=1
# LIBTBX_PRE_DISPATCHER_INCLUDE_SH export BOOST_ADAPTBX_FPE_DEFAULT=1

from __future__ import absolute_import, division, print_function
from crys3d.hklview.frames import *
from wxtbx import icons
import wxtbx.app
import iotbx.phil
import libtbx.load_env
from cctbx import crystal
import wx
if wx.VERSION >= (4, 0):
  import wx.adv

import sys
from six.moves import range
from six.moves import zip


master_phil = iotbx.phil.parse("""
  include scope cctbx.miller.display.master_phil
  unit_cell = None
    .type = unit_cell
  space_group = None
    .type = space_group
""", process_includes=True)


def run (args) :
  ma = None
  show_2d = False
  if ("--2d" in args) :
    show_2d = True
    args.remove("--2d")
  pcl = iotbx.phil.process_command_line_with_files(
    args=args,
    master_phil=master_phil,
    reflection_file_def="data",
    pdb_file_def="symmetry_file",
    usage_string="%s f_obs.mtz [options]" %libtbx.env.dispatcher_name)
  settings = pcl.work.extract()
  a = wxtbx.app.CCTBXApp(0)
  if wx.VERSION >= (4,0):
    app_icon = wx.Icon()
  else:
    app_icon = wx.EmptyIcon()
  app_icon.CopyFromBitmap(icons.hklview_3d.GetBitmap())
  if wx.VERSION >= (4,0):
    tb_icon = wx.adv.TaskBarIcon(wx.adv.TBI_DOCK)
  else:
    tb_icon = wx.TaskBarIcon(wx.TBI_DOCK)
  tb_icon.SetIcon(app_icon, "CCTBX multiplicity viewer")
  a.hklview_settings = settings
  viewer_class = MultiplicityViewFrame
  if (show_2d) :
    viewer_class = MultiplicityViewFrame2D
  f = viewer_class(None, -1, "Reflection multiplicity viewer", size=(1024,768))
  f.Show()
  if (ma is not None) :
    f.set_miller_array(ma)
  elif (settings.data is not None) :
    f.load_reflections_file(settings.data)
  else :
    f.OnLoadFile(None)
  a.SetTopWindow(f)
  a.Bind(wx.EVT_WINDOW_DESTROY, lambda evt: tb_icon.Destroy(), f)
  a.MainLoop()


class MultiplicityViewFrame(HKLViewFrame):
  def __init__ (self, *args, **kwds) :
    HKLViewFrame.__init__(self, *args, **kwds)
    self.create_colour_bar_panel()
    self.sizer.Add(self.colour_bar, 0, wx.EXPAND)
    self.SetSizer(self.sizer)
    self.sizer.SetSizeHints(self)
    self.viewer.SetFocus()

  def create_settings_panel(self):
    self.settings_panel = multiplicity_settings_window(self, -1, style=wx.RAISED_BORDER)
    self.settings.scale_radii_multiplicity = True
    self.settings.scale_colors_multiplicity = True

  def update_settings_for_merged(self, enable_multiplicity=False):
    pass

  def set_miller_array (self, array) :
    if (array is None) : return
    array, array_info = self.process_miller_array(array)
    self.statusbar.SetStatusText("Data: %s %s (Space group: %s  Unit Cell: %s)"
      % (array_info.labels, array_info.details_str, array_info.sg,
          array_info.uc))
    self.settings_panel.d_min_ctrl.SetValue(array.d_min())
    self.settings_panel.d_min_ctrl.SetRange(array.d_min(), 20.0)
    self.settings_panel.set_index_span(array.index_span())
    #self.settings_panel.update_space_group_choices(array)
    self.settings.spheres = False
    self.settings_panel.spheres_ctrl.SetValue(False)
    self.miller_array = array
    self.viewer.set_miller_array(array, zoom=True, merge=array_info.merge)
    self.viewer.Refresh()
    self.colour_bar.Refresh()
    if (self.view_2d is not None) :
      self.view_2d.set_miller_array(array)

  def load_reflections_file (self, file_name, set_array=True,
      data_only=True) :
    if (file_name != "") :
      from iotbx.reflection_file_reader import any_reflection_file
      from iotbx.gui_tools.reflections import get_array_description
      try :
        hkl_file = any_reflection_file(file_name)
      except Exception as e :
        raise Sorry(str(e))
      arrays = hkl_file.as_miller_arrays(merge_equivalents=False,
        )#observation_type_callback=misc_dialogs.get_shelx_file_data_type)
      #arrays = f.file_server.miller_arrays
      valid_arrays = []
      array_info = []
      for array in arrays :
        if array.is_hendrickson_lattman_array() :
          continue
        elif (data_only) :
          if (not array.is_real_array()) and (not array.is_complex_array()) :
            continue
        labels = array.info().label_string()
        desc = get_array_description(array)
        array_info.append("%s (%s)" % (labels, desc))
        valid_arrays.append(array)
      if (len(valid_arrays) == 0) :
        msg = "No arrays of the supported types in this file."
        raise Sorry(msg)
      elif (len(valid_arrays) >= 1) :
        if (set_array) :
          self.set_miller_array(valid_arrays[0])
        return valid_arrays[0]
    raise Abort()

  def process_miller_array (self, array) :
    if (array is None) : return
    if (array.is_hendrickson_lattman_array()) :
      raise Sorry("Hendrickson-Lattman coefficients are not supported.")
    info = array.info()
    if isinstance(info, str) :
      labels = "TEST DATA"
    else :
      labels = info.label_string()
    if self.settings.unit_cell is not None:
      symm = crystal.symmetry(unit_cell=self.settings.unit_cell,
                              space_group=array.space_group())
      array = array.customized_copy(crystal_symmetry=symm).set_info(info)
    if self.settings.space_group is not None:
      symm = crystal.symmetry(unit_cell=array.unit_cell(),
                              space_group=self.settings.space_group.group())
      array = array.customized_copy(crystal_symmetry=symm).set_info(info)
    if (array.unit_cell() is None) or (array.space_group() is None) :
      dlg = wxtbx.symmetry_dialog.SymmetryDialog(self, -1, "Enter symmetry")
      dlg.SetUnitCell(array.unit_cell())
      dlg.SetSpaceGroup(array.space_group_info())
      if (dlg.ShowModal() == wx.ID_OK) :
        symm = dlg.GetSymmetry()
        array = array.customized_copy(crystal_symmetry=symm).set_info(info)
      wx.CallAfter(dlg.Destroy)
    details = []
    merge = True
    details.append("merged")
    self.update_settings_for_merged(True)
    if array.is_complex_array() :
      array = array.amplitudes().set_info(info)
      details.append("as amplitudes")
    from iotbx.reflection_file_utils import looks_like_r_free_flags_info
    if (array.is_integer_array()) and (looks_like_r_free_flags_info(info)) :
      from iotbx.reflection_file_utils import get_r_free_flags_scores
      score_array = get_r_free_flags_scores([array], None)
      test_flag_value = score_array.test_flag_values[0]
      array = array.customized_copy(data=(array.data() == test_flag_value))
      array.set_info(info)
    sg = "%s" % array.space_group_info()
    uc = "a=%g b=%g c=%g angles=%g,%g,%g" % array.unit_cell().parameters()
    details_str = ""
    if (len(details) > 0) :
      details_str = "(%s)" % ", ".join(details)
    array_info = group_args(
      labels=labels,
      details_str=details_str,
      merge=merge,
      sg=sg,
      uc=uc)
    return array, array_info

  def OnShow2D (self, evt) :
    if (self.view_2d is None) :
      self.view_2d = MultiplicityViewFrame2D(self, -1, "2D data viewer")
      self.view_2d.set_miller_array(self.viewer.miller_array)
      self.view_2d.Show()
      if (wxtbx.MAC_OS_X_MAVERICKS) :
        wx.GetApp().SafeYield(self.view_2d, True)
    self.view_2d.Raise()

  def create_colour_bar_panel(self):
    self.colour_bar = ColourBar(parent=self, size=(100,640))
    self.colour_bar.SetMinSize((100,640))
    self.colour_bar.viewer = self.viewer

  def OnActive (self, event) :
    HKLViewFrame.OnActive(self, event)


  def update_settings (self, *args, **kwds) :
    if (self.miller_array is None) :
      return False
    self.viewer.update_settings(*args, **kwds)
    self.colour_bar.update_settings(*args, **kwds)


class multiplicity_settings_window(settings_window):

  def add_controls (self) :
    self._index_span = None
    self._last_sg_sel = None
    # d_min control
    self.d_min_ctrl = floatspin.FloatSpin(parent=self, increment=0.05, digits=2)
    self.d_min_ctrl.Bind(wx.EVT_SET_FOCUS, lambda evt: None)
    if (wx.VERSION >= (2,9)) : # XXX FloatSpin bug in 2.9.2/wxOSX_Cocoa
      self.d_min_ctrl.SetBackgroundColour(self.GetBackgroundColour())
    box = wx.BoxSizer(wx.HORIZONTAL)
    self.panel_sizer.Add(box)
    label = wx.StaticText(self,-1,"High resolution:")
    box.Add(label, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
    box.Add(self.d_min_ctrl, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
    self.Bind(floatspin.EVT_FLOATSPIN, self.OnChangeResolution, self.d_min_ctrl)
    #
    ctrls = self.create_controls(
      setting="black_background",
      label="Black background")
    self.panel_sizer.Add(ctrls[0], 0, wx.ALL, 5)
    ctrls = self.create_controls(
      setting="show_axes",
      label="Show h,k,l axes")
    self.panel_sizer.Add(ctrls[0], 0, wx.ALL, 5)
    if (not self.is_3d_view) :
      ctrls = self.create_controls(
        setting="uniform_size",
        label="Use same radius for all points")
      self.panel_sizer.Add(ctrls[0], 0, wx.ALL, 5)
    if (self.is_3d_view) :
      ctrls = self.create_controls(
        setting="expand_to_p1",
        label="Expand data to P1")
      ctrls2 = self.create_controls(
        setting="expand_anomalous",
        label="show Friedel pairs")
      box = wx.BoxSizer(wx.HORIZONTAL)
      self.panel_sizer.Add(box)
      box.Add(ctrls[0], 0, wx.ALL, 5)
      box.Add(ctrls2[0], 0, wx.ALL, 5)
      ctrls = self.create_controls(
        setting="spheres",
        label="Display reflections as spheres")
      self.panel_sizer.Add(ctrls[0], 0, wx.ALL, 5)
      self.spheres_ctrl = ctrls[0]
    else :
      self.spheres_ctrl = oop.null()
    box = wx.BoxSizer(wx.HORIZONTAL)
    self.panel_sizer.Add(box)
    txt = wx.StaticText(self.panel, -1, "Color scheme:")
    box.Add(txt, 0, wx.TOP|wx.BOTTOM|wx.LEFT|wx.ALIGN_CENTER_VERTICAL, 5)
    self.color_ctrl = wx.Choice(self.panel, -1,
      choices=["rainbow","heatmap","redblue","grayscale","monochrome"])
    self.color_ctrl.SetStringSelection(self.settings.color_scheme)
    box.Add(self.color_ctrl, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
    self.Bind(wx.EVT_CHOICE, self.OnChangeColor, self.color_ctrl)
    ctrls = self.create_controls(
      setting="show_missing",
      label="Show missing reflections")
    ctrls2 = self.create_controls(
      setting="show_only_missing",
      label="only")
    box = wx.BoxSizer(wx.HORIZONTAL)
    self.panel_sizer.Add(box)
    box.Add(ctrls[0], 0, wx.ALL, 5)
    box.Add(ctrls2[0], 0, wx.ALL, 5)
    ctrls = self.create_controls(
      setting="show_systematic_absences",
      label="Show systematic absences")
    self.panel_sizer.Add(ctrls[0], 0, wx.ALL, 5)
    ctrls = self.create_controls(
      setting="show_anomalous_pairs",
      label="Show anomalous pairs")
    self.panel_sizer.Add(ctrls[0], 0, wx.ALL, 5)
    if (self.is_3d_view) :
      ctrls = self.create_controls(
        setting="sphere_detail",
        label="Sphere detail level",
        min=4,
        max=20)
      box = wx.BoxSizer(wx.HORIZONTAL)
      box.Add(ctrls[0], 0, wx.TOP|wx.BOTTOM|wx.LEFT|wx.ALIGN_CENTER_VERTICAL, 5)
      box.Add(ctrls[1], 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
      self.panel_sizer.Add(box)
    else:
      box2 = wx.BoxSizer(wx.HORIZONTAL)
      box2.Add(wx.StaticText(self.panel, -1, "View slice:"), 0,
        wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
      ctrls = self.create_controls
      self.hkl_choice = wx.Choice(self.panel, -1, choices=["h","k","l"])
      self.hkl_choice.SetStringSelection(self.settings.slice_axis)
      box2.Add(self.hkl_choice, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
      box2.Add(wx.StaticText(self.panel, -1, "="), 0,
        wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
      self.slice_index = wx.SpinCtrl(self.panel, -1)
      self.slice_index.SetValue(self.settings.slice_index)
      box2.Add(self.slice_index, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
      self.panel_sizer.Add(box2)
      self.Bind(wx.EVT_CHOICE, self.OnSetSlice, self.hkl_choice)
      self.Bind(wx.EVT_SPINCTRL, self.OnSetSlice, self.slice_index)

  def update_reflection_info (self, hkl, d_min, value) :
    return


class multiplicity_settings_window_2d (multiplicity_settings_window) :
  is_3d_view = False


class MultiplicityViewFrame2D(MultiplicityViewFrame, HKLViewFrame2D):

  def create_settings_panel (self) :
    self.settings.scale_radii_multiplicity = True
    self.settings.scale_colors_multiplicity = True
    self.settings.expand_to_p1 = True
    self.settings.expand_anomalous = True
    self.settings.slice_mode = True
    #self.settings.black_background = False
    self.settings_panel = multiplicity_settings_window_2d(self, -1, style=wx.RAISED_BORDER)

  def OnShow3D (self, evt) :
    if (self.view_3d is None) :
      self.view_3d = MultiplicityViewFrame(self, -1, "3D data viewer")
      self.view_3d.Show()
      if (self.viewer.miller_array is not None) :
        self.view_3d.set_miller_array(self.viewer.miller_array)
    self.view_3d.Raise()


class ColourBar(wx.Panel):
  def __init__ (self, *args, **kwds) :
    wx.Panel.__init__(self, *args, **kwds)
    font = wx.Font(14, wx.MODERN, wx.NORMAL, wx.NORMAL)
    self.SetFont(font)
    self.Bind(wx.EVT_PAINT, self.OnPaint)
    #self.Bind(wx.EVT_LEFT_DOWN, self.OnLeftClick, self)
    #self.Bind(wx.EVT_LEFT_UP, self.OnLeftUp, self)
    #self.Bind(wx.EVT_MOTION, self.OnMouseMotion, self)
    self.viewer = None
    self.parent = self.GetParent()
    self.settings = self.parent.settings
    self.setup_colors()

  @property
  def scene(self):
    if self.viewer is not None:
      return self.viewer.scene

  def paint(self, gc):
    font = self.GetFont()
    font.SetFamily(wx.FONTFAMILY_MODERN)
    if (self.settings.black_background) :
      gc.SetFont(gc.CreateFont(font, (255,255,255)))
    else :
      gc.SetFont(gc.CreateFont(font, (0,0,0)))
    self.render(gc)

  def render (self, canvas) :
    from scitbx.array_family import flex
    from libtbx.utils import frange
    import math
    size = self.GetSize()
    border = 10
    i_rows = flex.double_range(border, size[1]-border)
    scene = self.scene
    if self.scene.settings.scale_colors_multiplicity:
      data = self.scene.multiplicities.data()
    else:
      data = self.scene.data
      if self.settings.sqrt_scale_colors:
        data = flex.sqrt(data)
    min_data = flex.min(data)
    max_data = flex.max(data)
    data_for_colors = flex.double(frange(
      max_data, min_data, -(max_data-min_data)/len(i_rows)))
    tick_step = int(math.ceil((max_data-min_data)/10))
    i_row_ticks = []
    tick_text = []
    start_tick = math.floor(max_data)
    i_tick = 0
    for i in range(len(data_for_colors)-1):
      tick_d = start_tick - tick_step * i_tick
      if abs(data_for_colors[i]-tick_d) < abs(data_for_colors[i+1]-tick_d):
        i_row_ticks.append(i_rows[i])
        tick_text.append(str(int(tick_d)))
        i_tick += 1
    tick_d = start_tick - tick_step * i_tick
    if tick_d == min_data:
      i_row_ticks.append(i_rows[-1])
      tick_text.append(str(int(tick_d)))

    from scitbx import graphics_utils
    if (self.settings.color_scheme in ["rainbow", "heatmap", "redblue"]) :
      colors = graphics_utils.color_by_property(
        properties=data_for_colors,
        selection=flex.bool(data_for_colors.size(), True),
        color_all=False,
        gradient_type=self.settings.color_scheme)
    elif (self.settings.color_scheme == "grayscale") :
      colors = graphics_utils.grayscale_by_property(
        properties=data_for_colors,
        selection=flex.bool(data_for_colors.size(), True),
        shade_all=False,
        invert=self.settings.black_background)
    else :
      if (self.settings.black_background) :
        base_color = (1.0,1.0,1.0)
      else :
        base_color = (0.0,0.0,0.0)
      colors = flex.vec3_double(data_for_colors.size(), base_color)

    l_padding = border
    r_padding = 4 * border

    for i_row, color in zip(i_rows, colors):
      self.draw_line(canvas, l_padding, i_row, size[0]-r_padding, i_row, color=color)

    for i_row, text in zip(i_row_ticks, tick_text):
      self.draw_text(canvas, text, size[0]-0.8*r_padding, i_row-5)
      self.draw_line(canvas, size[0]-r_padding-10, i_row, size[0]-r_padding, i_row)

  def setup_colors (self) :
    if (self.settings.black_background) :
      self._background = (0.,0.,0.)
      self._foreground = (0.95,0.95,0.95)
      if (self.settings.color_scheme == "heatmap") :
        self._missing = (0.,1.,0.)
      elif (not self.settings.color_scheme in ["rainbow", "redblue"]) :
        self._missing = (1.,0.,0.)
      else :
        self._missing = (1.,1.,1.)
    else :
      self._background = (1.,1.,1.)
      self._foreground = (0.,0.,0.)
      if (self.settings.color_scheme == "heatmap") :
        self._missing = (0.,1.,0.)
      elif (not self.settings.color_scheme in ["rainbow", "redblue"]) :
        self._missing = (1.,0.,0.)
      else :
        self._missing = (0.,0.,0.)

  def get_color (self, c) :
    return (int(c[0]*255), int(c[1]*255), int(c[2]*255))

  def draw_line (self, canvas, x1, y1, x2, y2, color=None) :
    gc = canvas
    x_axis = gc.CreatePath()
    x_axis.MoveToPoint(x1, y1)
    x_axis.AddLineToPoint(x2, y2)
    x_axis.CloseSubpath()
    if (color is None) :
      color = self._foreground
    gc.SetPen(wx.Pen(self.get_color(color)))
    gc.PushState()
    gc.StrokePath(x_axis)
    gc.PopState()

  def draw_text (self, canvas, text, x, y) :
    gc = canvas
    gc.SetPen(wx.Pen(self.get_color(self._foreground)))
    gc.DrawText(text, x, y)

  def OnPaint (self, event) :
    if (self.scene is None) :
      return
    if (self.settings.black_background) :
      self.SetBackgroundColour((0,0,0))
    else :
      self.SetBackgroundColour((255,255,255))
    dc = wx.AutoBufferedPaintDCFactory(self)
    if (self.settings.black_background) :
      dc.SetBackground(wx.BLACK_BRUSH)
    else :
      dc.SetBackground(wx.WHITE_BRUSH)
    dc.Clear()
    gc = wx.GraphicsContext.Create(dc)
    self.paint(gc)

  def update_settings (self) :
    self.Refresh()

if (__name__ == "__main__") :
  run(sys.argv[1:])


 *******************************************************************************


 *******************************************************************************
crys3d/command_line/qttbx.view_structure.py
from __future__ import absolute_import, division, print_function
from cctbx import xray
from crys3d.qttbx import xray_structure_viewer
try:
  import durham_structures
except ImportError:
  durham_structures = None
import sys, os

name = sys.argv[1]
filename = os.path.expanduser(name)
if os.path.exists(filename):
  xs = xray.structure.from_shelx(filename=filename, strictly_shelxl=False)
elif durham_structures:
  xs = durham_structures.some([name]).next().xray_structure
else:
  print("%s not found" % name)
  sys.exit(1)
xray_structure_viewer.display(xray_structure=xs, name=name)


 *******************************************************************************


 *******************************************************************************
crys3d/command_line/visualize_r_factors.py

# LIBTBX_SET_DISPATCHER_NAME cctbx.visualize_r_factors
# LIBTBX_PRE_DISPATCHER_INCLUDE_SH export PHENIX_GUI_ENVIRONMENT=1
# LIBTBX_PRE_DISPATCHER_INCLUDE_SH export BOOST_ADAPTBX_FPE_DEFAULT=1

from __future__ import absolute_import, division, print_function
from crys3d.hklview.frames import *
from cctbx.miller.display import master_phil
from wxtbx import icons
from libtbx.utils import Sorry
import wx
import sys

class RfactorFrame (HKLViewFrame) :
  def add_view_specific_functions (self) :
    pass

  def load_reflections_file (self, file_name, **kwds) :
    if (isinstance(file_name, unicode)) :
      file_name = str(file_name)
    if (file_name != "") :
      from iotbx.reflection_file_reader import any_reflection_file
      from cctbx import miller
      from scitbx.array_family import flex
      try :
        hkl_file = any_reflection_file(file_name)
      except Exception as e :
        raise Sorry(str(e))
      arrays = hkl_file.as_miller_arrays(merge_equivalents=True)
      f_obs = f_model = None
      for array in arrays :
        labels = array.info().label_string()
        if labels.startswith("F-obs-filtered") :
          f_obs = array
        elif labels.startswith("F-model") :
          f_model = array
      if (f_obs is None) or (f_model is None) :
        raise Sorry("This does not appear to be a phenix.refine output "+
          "file.  The MTZ file should contain data arrays for the filtered "+
          "amplitudes (F-obs) and F-model.")
      f_delta = f_obs.customized_copy(sigmas=None,
        data=flex.abs(f_obs.data()-abs(f_model).data())).set_info(
          miller.array_info(labels=["abs(F_obs - F_model)"]))
      self.set_miller_array(f_delta)

def run (args) :
  import iotbx.phil
  pcl = iotbx.phil.process_command_line_with_files(
    args=args,
    master_phil=master_phil,
    reflection_file_def="data",
    usage_string="""\
cctbx.visualize_r_factors refine_001.mtz

Display the absolute difference between scaled and filtered F-obs and F-model,
which are used to calculate R-factors.
""")
  settings = pcl.work.extract()
  a = wx.App(0)
  app_icon = wx.EmptyIcon()
  app_icon.CopyFromBitmap(icons.hklview_3d.GetBitmap())
  if (wx.VERSION >= (2,9)) :
    tb_icon = wx.TaskBarIcon(wx.TBI_DOCK)
  else :
    tb_icon = wx.TaskBarIcon()
  tb_icon.SetIcon(app_icon, "PHENIX data viewer")
  a.hklview_settings = settings
  f = RfactorFrame(None, -1, "F-model versus F-obs", size=(1024,768))
  f.Show()
  if (settings.data is not None) :
    f.load_reflections_file(settings.data)
  else :
    f.OnLoadFile(None)
  a.SetTopWindow(f)
  a.Bind(wx.EVT_WINDOW_DESTROY, lambda evt: tb_icon.Destroy(), f)
  a.MainLoop()

if (__name__ == "__main__") :
  run(sys.argv[1:])


 *******************************************************************************


 *******************************************************************************
crys3d/hklview/__init__.py
from __future__ import absolute_import, division, print_function
# for backwards compatibility
from cctbx.miller.display import *


 *******************************************************************************


 *******************************************************************************
crys3d/hklview/comparison.py
from __future__ import absolute_import, division, print_function

from crys3d.hklview.frames import *
from crys3d.hklview import view_2d
import wx
import os

class twin_settings_window (settings_window) :
  def add_value_widgets (self, sizer) :
    sizer.SetRows(4)
    sizer.Add(wx.StaticText(self.panel, -1, "Value 1:"), 0,
      wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
    self.value_info_1 = wx.TextCtrl(self.panel, -1, size=(80,-1),
      style=wx.TE_READONLY)
    sizer.Add(self.value_info_1, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
    sizer.Add(wx.StaticText(self.panel, -1, "Value 2:"), 0,
      wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
    self.value_info_2 = wx.TextCtrl(self.panel, -1, size=(80,-1),
      style=wx.TE_READONLY)
    sizer.Add(self.value_info_2, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)

  def update_reflection_info (self, hkl, d_min, value_1, value_2) :
    print(hkl, value_1, value_2)
    if (hkl is None) :
      self.hkl_info.SetValue("")
      self.d_min_info.SetValue("")
      self.value_info.SetValue("")
    else :
      self.hkl_info.SetValue("%d, %d, %d" % hkl)
      d_min_str = format_value("%.3g", d_min)
      self.d_min_info.SetValue(d_min_str)
      value_str_1 = format_value("%.3g", value_1, replace_none_with="---")
      self.value_info_1.SetValue(value_str_1)
      value_str_2 = format_value("%.3g", value_2, replace_none_with="---")
      self.value_info_2.SetValue(value_str_2)

class twin_viewer_panel (wx.Panel) :
  def __init__ (self, *args, **kwds) :
    wx.Panel.__init__(self, *args, **kwds)
    self.settings = self.GetParent().settings
    szr = wx.BoxSizer(wx.HORIZONTAL)
    self.SetSizer(szr)
    self.view_1 = view_2d.hklview_2d(self, -1, size=(480,480))
    self.view_2 = view_2d.hklview_2d(self, -1, size=(480,480))
    self.view_1.SetMinSize((480,480))
    self.view_2.SetMinSize((480,480))
    szr.Add(self.view_1, 1, wx.EXPAND)
    szr.Add(self.view_2, 1, wx.EXPAND)
    self.SetMinSize((960,480))
    szr.Fit(self)

  def add_view_specific_functions (self) :
    pass

  def _propagate_action (self, name, *args, **kwds) :
    for viewer in [self.view_1, self.view_2] :
      getattr(viewer, name)(*args, **kwds)

  def clear_labels (self) :
    self._propagate_action("clear_labels")

  def set_miller_arrays (self, array1, array2) :
    self.view_1.set_miller_array(array1)
    self.view_2.set_miller_array(array2)
    self.Refresh()

  def update_settings (self, *args, **kwds) :
    self.view_1.update_settings(*args, **kwds)
    self.view_2.update_settings(*args, **kwds)
    self.Refresh()

  def update_clicked (self, index) :
    hkl_1, d_min_1, value_1 = self.view_1.scene.get_reflection_info(index)
    hkl_2, d_min_2, value_2 = self.view_2.scene.get_reflection_info(index)
    assert (hkl_1 == hkl_2)
    self.GetParent().update_reflection_info(
      hkl=hkl_1,
      d_min=d_min_1,
      value_1=value_1,
      value_2=value_2)

  def save_screen_shot (self, file_name, extensions=None) :
    base, ext = os.path.splitext(file_name)
    file_1 = base + "_1" + ext
    file_2 = base + "_2" + ext
    self.view_1.save_screen_shot(file_1)
    self.view_2.save_screen_shot(file_2)

class ComparisonFrame (HKLViewFrame) :
  def __init__ (self, *args, **kwds) :
    HKLViewFrame.__init__(self, *args, **kwds)
    self._array1 = None
    self._array2 = None

  def create_viewer_panel (self) :
    self.viewer = twin_viewer_panel(self)
    self.viewer.SetMinSize((960, 480))

  def update_reflection_info (self, *args, **kwds) :
    self.settings_panel.update_reflection_info(*args, **kwds)

  def create_settings_panel (self) :
    self.settings.expand_to_p1 = True
    self.settings.expand_anomalous = True
    self.settings.slice_mode = True
    #self.settings.black_background = False
    self.settings_panel = twin_settings_window(self, style=wx.RAISED_BORDER)

  def update_settings_for_merged (self) :
    self.settings.expand_to_p1 = True
    self.settings.expand_anomalous = True

  def update_settings (self, *args, **kwds) :
    if (None in [self._array1, self._array2]) :
      return False
    self.viewer.update_settings(*args, **kwds)

  def SetupMenus (self) :
    self.menubar = wx.MenuBar(-1)
    self.file_menu = wx.Menu()
    self.menubar.Append(self.file_menu, "File")
    item = wx.MenuItem(self.file_menu, -1, "Load data...\tCtrl-O")
    self.Bind(wx.EVT_MENU, self.OnLoadFile, item)
    self.file_menu.AppendItem(item)

  def OnLoadFile (self, evt) :
    file_name_1 = wx.FileSelector("Reflections file 1",
      wildcard="Reflection files (*.mtz, *.sca, *.hkl)|*.mtz;*.sca;*.hkl",
      default_path="",
      flags=wx.FD_OPEN)
    file_name_2 = wx.FileSelector("Reflections file 2",
      wildcard="Reflection files (*.mtz, *.sca, *.hkl)|*.mtz;*.sca;*.hkl",
      default_path="",
      flags=wx.FD_OPEN)
    self.load_files(file_name_1, file_name_2)

  def load_files (self, file_name_1, file_name_2) :
    array1 = self.load_reflections_file(file_name_1, set_array=False,
      data_only=True)
    array2 = self.load_reflections_file(file_name_2, set_array=False,
      data_only=True)
    symm1 = array1.crystal_symmetry()
    symm2 = array2.crystal_symmetry()
    if (symm1 is None) :
      raise Sorry(("No crystal symmetry found in %s!  Please convert to a "+
        "more appropriate format.") % file_name_1)
    if (symm2 is None) :
      raise Sorry(("No crystal symmetry found in %s!  Please convert to a "+
        "more appropriate format.") % file_name_2)
    if (symm1.unit_cell() is None) :
      symm1 = symm1.customized_copy(unit_cell=symm2.unit_cell())
      array1 = array1.customized_copy(crystal_symmetry=symm1)
    if (symm2.unit_cell() is None) :
      symm2 = symm2.customized_copy(unit_cell=symm1.unit_cell())
      array2 = array2.customized_copy(crystal_symmetry=symm2)
    if (not array1.is_similar_symmetry(array2)) :
      from cctbx import crystal
      space_group_1 = array1.space_group_info()
      space_group_2 = array2.space_group_info()
      if (str(space_group_1) != str(space_group_2)) :
        # TODO need to figure out if these are really incompatible!
        confirm = wx.MessageBox(("The space groups for the two datasets are "+
          "different (%s versus %s).  The space group from the first dataset "+
          "will be used for both.") % (space_group_1, space_group_2),
          style=wx.OK)
      unit_cell_1 = array1.unit_cell()
      unit_cell_2 = array2.unit_cell()
      if (not unit_cell_1.is_similar_to(unit_cell_2)) :
        uc_str_1 = "%g %g %g %g %g %g" % unit_cell_1.parameters()
        uc_str_2 = "%g %g %g %g %g %g" % unit_cell_2.parameters()
        confirm = wx.MessageBox(("The unit cells for the two datasets are "+
          "different (%s versus %s).  The unit cell from the first dataset "+
          "will be used to calculated the resolution of clicked reflections.")%
            (uc_str_1, uc_str_2),
          style=wx.OK)
      symm = crystal.symmetry(
        space_group_info=space_group_1,
        unit_cell=unit_cell_1)
      array2 = array2.customized_copy(crystal_symmetry=symm)
    if (array1.anomalous_flag() != array2.anomalous_flag()) :
      wx.MessageBox("Warning: only one array contains anomalous data; to "+
        "allow comparison, Bijvoet mates will be generated for the "+
        "non-anomalous array.")
      if (not array1.anomalous_flag()) :
        array1 = array1.generate_bijvoet_mates()
      else :
        array2 = array2.generate_bijvoet_mates()
    array1 = array1.common_set(other=array2)
    array2 = array2.common_set(other=array1)
    is_intensities = [ array1.is_xray_intensity_array(),
                       array2.is_xray_intensity_array() ]
    if (len(set(is_intensities)) == 2) :
      convert = wx.MessageBox("You appear to be comparing intensities with "+
        "another type of data.  Do you want to convert the intensities to "+
        "amplitudes?  If you leave them as intensities the program will "+
        "still run, but the scale of the data may be much different.",
        style=wx.YES_NO)
      if (convert == wx.YES) :
        if (array1.is_xray_intensity_array()) :
          array1 = array1.f_sq_as_f()
        else :
          array2 = array2.f_sq_as_f()
    self._array1 = array1
    self._array2 = array2
    self.settings_panel.d_min_ctrl.SetValue(array1.d_min())
    self.settings_panel.d_min_ctrl.SetRange(array1.d_min(), 20.0)
    self.settings_panel.set_index_span(array1.index_span())
    self.settings_panel.update_space_group_choices(array1)
    self.viewer.set_miller_arrays(array1, array2)

  def add_view_specific_functions (self) :
    pass

  def delete_miller_index (self, hkl) :
    self._array1 = self._array1.delete_index(hkl)
    self._array2 = self._array2.delete_index(hkl)
    self.viewer.set_miller_arrays(self._array1, self._array2)


 *******************************************************************************


 *******************************************************************************
crys3d/hklview/frames.py
from __future__ import absolute_import, division, print_function

# TODO:
#  - prompt user for missing symmetry
#  - cached scenes

from crys3d.hklview import view_2d, view_3d
from cctbx.miller.display import settings
from wxtbx.phil_controls import simple_dialogs
from wxtbx import misc_dialogs
from wxtbx import icons
from wxtbx import bitmaps
import wxtbx.symmetry_dialog
import wxtbx.utils
import wx.glcanvas
from wx.lib.agw import floatspin
import wx
from libtbx import object_oriented_patterns as oop
from libtbx.str_utils import format_value
from libtbx.utils import Sorry, Abort, to_str
import libtbx.load_env
from libtbx import group_args
from math import sqrt
import copy
import os

class settings_window (wxtbx.utils.SettingsPanel) :
  is_3d_view = True
  def __init__ (self, *args, **kwds) :
    wxtbx.utils.SettingsPanel.__init__(self, *args, **kwds)
    self.Bind(wx.EVT_CHAR, self.OnChar)

  def OnChar (self, event) :
    self.GetParent().viewer.OnChar(event)

  def add_controls (self) :
    '''
    All the buttoms on the lef hand panel is defined here
    '''
    self._index_span = None
    self._last_sg_sel = None
    # # d_min control
    self.d_min_ctrl = floatspin.FloatSpin(parent=self, increment=0.05, digits=2)
    self.d_min_ctrl.Bind(wx.EVT_SET_FOCUS, lambda evt: None)
    if (wx.VERSION >= (2,9)) : # XXX FloatSpin bug in 2.9.2/wxOSX_Cocoa
      self.d_min_ctrl.SetBackgroundColour(self.GetBackgroundColour())
    box = wx.BoxSizer(wx.HORIZONTAL)
    self.panel_sizer.Add(box)
    label = wx.StaticText(self,-1,"High resolution:")
    box.Add(label, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
    box.Add(self.d_min_ctrl, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
    self.Bind(floatspin.EVT_FLOATSPIN, self.OnChangeResolution, self.d_min_ctrl)

##Kau added start
    self.column_ctrl = oop.null()
    self.column_ctrl = wx.Choice(self.panel, -1,
        # choices=["jinga","manga","linga","some lable", "ranga"],
        choices=[],
        size=(160,-1))
    # self.Bind(wx.EVT_CHOICE, self.OnChangeSpaceGroup, self.array_ctrl)
    self.Bind(wx.EVT_CHOICE, self.OnChangeColumn, self.column_ctrl)
    # example_file=os.path.join("combine_4zg3.mtz")
    box = wx.BoxSizer(wx.HORIZONTAL)
    self.panel_sizer.Add(box)
    box.Add(wx.StaticText(self.panel, -1, "labels :"), 0, wx.ALL, 5)
    box.Add(self.column_ctrl, 0, wx.ALL, 5)


##This is to include I/SigI column details
    self.IoverSigI_ctrl = floatspin.FloatSpin(parent=self, increment=0.25, digits=2)
    self.IoverSigI_ctrl.Bind(wx.EVT_SET_FOCUS, lambda evt: None)
    if (wx.VERSION >= (2,9)) : # XXX FloatSpin bug in 2.9.2/wxOSX_Cocoa
      self.IoverSigI_ctrl.SetBackgroundColour(self.GetBackgroundColour())
    box = wx.BoxSizer(wx.HORIZONTAL)
    self.panel_sizer.Add(box)
    label = wx.StaticText(self,-1,"I/SigI:")
    box.Add(label, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
    box.Add(self.IoverSigI_ctrl, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
    self.Bind(floatspin.EVT_FLOATSPIN, self.OnChangeIoverSigI, self.IoverSigI_ctrl)
##Kau added ends


    # # scale control
    # box = wx.BoxSizer(wx.HORIZONTAL)
    # self.panel_sizer.Add(box)
    # label = wx.StaticText(self, -1, "Scale:")
    # box.Add(label, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
    # self.scale_ctrl = wx.Slider(self, size=(120,-1), style=wx.SL_AUTOTICKS)
    # self.scale_ctrl.SetMin(0)
    # self.scale_ctrl.SetMax(16)
    # self.scale_ctrl.SetTickFreq(4, 1)
    # self.Bind(wx.EVT_SLIDER, self.OnSetScale, self.scale_ctrl)
    # for x in [0, 4, 8, 12, 16] :
    #   self.scale_ctrl.SetTick(x)
    # self.scale_ctrl.SetValue((self.settings.scale * 4) - 4)
    # box.Add(self.scale_ctrl, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
    # #

###Kau added starts here
    # # information control
    # box = wx.BoxSizer(wx.HORIZONTAL)
    # self.panel_sizer.Add(box)
    # label = wx.StaticText(self, -1, "Information content:")
    # box.Add(label, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
    # self.scale_ctrl = wx.Slider(self, size=(120,-1), style=wx.SL_AUTOTICKS)
    # self.scale_ctrl.SetMin(0)
    # self.scale_ctrl.SetMax(16)
    # self.scale_ctrl.SetTickFreq(4, 1)
    # self.Bind(wx.EVT_SLIDER, self.OnSetScale, self.scale_ctrl)
    # for x in [0, 4, 8, 12, 16] :
    #   self.scale_ctrl.SetTick(x)
    # self.scale_ctrl.SetValue((self.settings.scale * 4) - 4)
    # box.Add(self.scale_ctrl, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
    # #
###Kau added ends here

    ctrls = self.create_controls(
      setting="black_background",
      label="Black background")
    self.panel_sizer.Add(ctrls[0], 0, wx.ALL, 5)
    ctrls = self.create_controls(
      setting="show_axes",
      label="Show h,k,l axes")
    self.panel_sizer.Add(ctrls[0], 0, wx.ALL, 5)
    # ctrls = self.create_controls(
    #   setting="show_data_over_sigma",
    #   label="Use I or F over sigma")
    # self.panel_sizer.Add(ctrls[0], 0, wx.ALL, 5)
    if (not self.is_3d_view) :
    #   ctrls = self.create_controls(
    #     setting="uniform_size",
    #     label="Use same radius for all points")
    #   self.panel_sizer.Add(ctrls[0], 0, wx.ALL, 5)
    # ctrls = self.create_controls(
    #   setting="sqrt_scale_radii",
    #   label="Scale radii to sqrt(value)")
    # self.panel_sizer.Add(ctrls[0], 0, wx.ALL, 5)
    # ctrls = self.create_controls(
    #   setting="sqrt_scale_colors",
    #   label="Scale colors to sqrt(value)")
    # self.panel_sizer.Add(ctrls[0], 0, wx.ALL, 5)
        self.sg_ctrl = oop.null()
    if (self.is_3d_view) :
      self.sg_ctrl = wx.Choice(self.panel, -1,
        choices=[],
        size=(160,-1))
      self.Bind(wx.EVT_CHOICE, self.OnChangeSpaceGroup, self.sg_ctrl)
      box = wx.BoxSizer(wx.HORIZONTAL)
      self.panel_sizer.Add(box)
      box.Add(wx.StaticText(self.panel, -1, "Space group:"), 0, wx.ALL, 5)
      box.Add(self.sg_ctrl, 0, wx.ALL, 5)

      ctrls = self.create_controls(
        setting="expand_to_p1",
        label="Expand data to P1")
      ctrls2 = self.create_controls(
        setting="expand_anomalous",
        label="show Friedel pairs")
      box = wx.BoxSizer(wx.HORIZONTAL)
      self.panel_sizer.Add(box)
      box.Add(ctrls[0], 0, wx.ALL, 5)
      box.Add(ctrls2[0], 0, wx.ALL, 5)
      ctrls = self.create_controls(
        setting="spheres",
        label="Display reflections as spheres")
      self.panel_sizer.Add(ctrls[0], 0, wx.ALL, 5)
      self.spheres_ctrl = ctrls[0]
    else :
      self.spheres_ctrl = oop.null()

    ###Kau added start
        # d_min control
      # self.d_min_ctrl = floatspin.FloatSpin(parent=self, increment=0.05, digits=2)
      # self.d_min_ctrl.Bind(wx.EVT_SET_FOCUS, lambda evt: None)
      # if (wx.VERSION >= (2,9)) : # XXX FloatSpin bug in 2.9.2/wxOSX_Cocoa
      #   self.d_min_ctrl.SetBackgroundColour(self.GetBackgroundColour())
      # box = wx.BoxSizer(wx.HORIZONTAL)
      # self.panel_sizer.Add(box)
      # label = wx.StaticText(self,-1,"High resolution:")
      # box.Add(label, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
      # box.Add(self.d_min_ctrl, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
      # self.Bind(floatspin.EVT_FLOATSPIN, self.OnChangeResolution, self.d_min_ctrl)
##kau added end

    box = wx.BoxSizer(wx.HORIZONTAL)
    self.panel_sizer.Add(box)
    txt = wx.StaticText(self.panel, -1, "Color scheme:")
    box.Add(txt, 0, wx.TOP|wx.BOTTOM|wx.LEFT|wx.ALIGN_CENTER_VERTICAL, 5)
    self.color_ctrl = wx.Choice(self.panel, -1,
      choices=["rainbow","heatmap","redblue","grayscale","monochrome"])
    self.color_ctrl.SetStringSelection(self.settings.color_scheme)
    box.Add(self.color_ctrl, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
    self.Bind(wx.EVT_CHOICE, self.OnChangeColor, self.color_ctrl)
    ctrls = self.create_controls(
      setting="show_missing",
      label="Show missing reflections")
    ctrls2 = self.create_controls(
      setting="show_only_missing",
      label="only")
    box = wx.BoxSizer(wx.HORIZONTAL)
    self.panel_sizer.Add(box)
    box.Add(ctrls[0], 0, wx.ALL, 5)
    box.Add(ctrls2[0], 0, wx.ALL, 5)
    ctrls = self.create_controls(
      setting="show_systematic_absences",
      label="Show systematic absences")
    self.panel_sizer.Add(ctrls[0], 0, wx.ALL, 5)
    if (self.is_3d_view) :
      ctrls = self.create_controls(
        setting="sphere_detail",
        label="Sphere detail level",
        min=4,
        max=20)
      box = wx.BoxSizer(wx.HORIZONTAL)
      box.Add(ctrls[0], 0, wx.TOP|wx.BOTTOM|wx.LEFT|wx.ALIGN_CENTER_VERTICAL, 5)
      box.Add(ctrls[1], 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
      self.panel_sizer.Add(box)
      ctrls = self.create_controls(
        setting="slice_mode",
        label="Show only a slice through reciprocal space")
      self.panel_sizer.Add(ctrls[0], 0, wx.ALL, 5)
      self.slice_ctrl = ctrls[0]
      ctrls = self.create_controls(
        setting="keep_constant_scale",
        label="Keep scale constant across all slices")
      self.panel_sizer.Add(ctrls[0], 0, wx.ALL, 5)
    box2 = wx.BoxSizer(wx.HORIZONTAL)
    box2.Add(wx.StaticText(self.panel, -1, "View slice:"), 0,
      wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
    ctrls = self.create_controls
    self.hkl_choice = wx.Choice(self.panel, -1, choices=["h","k","l"])
    self.hkl_choice.SetStringSelection(self.settings.slice_axis)
    box2.Add(self.hkl_choice, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
    box2.Add(wx.StaticText(self.panel, -1, "="), 0,
      wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
    self.slice_index = wx.SpinCtrl(self.panel, -1)
    self.slice_index.SetValue(self.settings.slice_index)
    box2.Add(self.slice_index, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
    self.panel_sizer.Add(box2)
    self.Bind(wx.EVT_CHOICE, self.OnSetSlice, self.hkl_choice)
    self.Bind(wx.EVT_SPINCTRL, self.OnSetSlice, self.slice_index)
    # reflection info box
    box = wx.StaticBox(self.panel, -1, "Reflection info")
    box_szr = wx.StaticBoxSizer(box, wx.VERTICAL)
    self.panel_sizer.Add((1,10))
    self.panel_sizer.Add(box_szr, 0, wx.EXPAND|wx.ALL)
    grid_szr = wx.FlexGridSizer(3, 2, 0, 0)
    box_szr.Add(grid_szr, 0, wx.EXPAND|wx.ALL)
    grid_szr.Add(wx.StaticText(self.panel, -1, "Clicked:"), 0,
      wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
    self.hkl_info = wx.TextCtrl(self.panel, -1, size=(80,-1),
      style=wx.TE_READONLY)
    grid_szr.Add(self.hkl_info, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
    grid_szr.Add(wx.StaticText(self.panel, -1, "Resolution:"), 0,
      wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
    self.d_min_info = wx.TextCtrl(self.panel, -1, size=(80,-1),
      style=wx.TE_READONLY)
    grid_szr.Add(self.d_min_info, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
    self.add_value_widgets(grid_szr)

  def add_value_widgets (self, sizer) :
    sizer.Add(wx.StaticText(self.panel, -1, "Value:"), 0,
      wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
    self.value_info = wx.TextCtrl(self.panel, -1, size=(80,-1),
      style=wx.TE_READONLY)
    sizer.Add(self.value_info, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)

  def set_index_span (self, index_span) :
    self._index_span = index_span

  def update_reflection_info (self, hkl, d_min, value) :
    print(hkl, value)
    if (hkl is None) :
      self.hkl_info.SetValue("")
      self.d_min_info.SetValue("")
      self.value_info.SetValue("")
    else :
      self.hkl_info.SetValue("%d, %d, %d" % hkl)
      d_min_str = format_value("%.3g", d_min)
      self.d_min_info.SetValue(d_min_str)
      value_str = format_value("%.3g", value, replace_none_with="---")
      self.value_info.SetValue(value_str)

  def clear_reflection_info (self) :
    self.update_reflection_info(None, None, None)

  def update_space_group_choices (self, miller_array) :
    from cctbx.sgtbx.subgroups import subgroups
    from cctbx import sgtbx
    sg_info  = miller_array.space_group_info()
    subgrs = subgroups(sg_info).groups_parent_setting()
    choices = []
    for subgroup in subgrs :
      subgroup_info = sgtbx.space_group_info(group=subgroup)
      choices.append(str(subgroup_info))
    if (str(sg_info) in choices) :
      current = choices.index(str(sg_info))
    else :
      choices.insert(0, str(sg_info))
      current = 0
    self.sg_ctrl.SetItems(choices)
    self.sg_ctrl.SetSelection(current)
    self._last_sg_sel = str(sg_info)

# XXXXXXXXXXXXXXXXXXXXXX
# Kau added starts here

  # def update_column_choices (self, array_info,valid_arrays,sel) :

  def update_column_choices (self,array_info,arrays,sel) :
    choices=[]
        # print("Kau printing array_info from within function", array_info)
    for labels in array_info:
        choices.append(str(labels))
    self.column_ctrl.SetItems(choices)
    # for f in valid_arrays:
    #     print("Kau last array selected is ", valid_arrays)
    current=sel
    self.column_ctrl.SetItems(choices)
    self.column_ctrl.SetSelection(current)
    self._last_column_sel = str(sel)

# Kau added ends here
# XXXXXXXXXXXXXXXXXXXXXX
  def OnSetSlice (self, event) :
    if (self._index_span is None) :
      self.slice_index.SetValue(0)
      return
    self.settings.slice_axis = str(self.hkl_choice.GetStringSelection())
    axis_index = ["h","k","l"].index(self.settings.slice_axis)
    min_value = self._index_span.min()[axis_index]
    max_value = self._index_span.max()[axis_index]
    self.settings.slice_index = self.slice_index.GetValue()
    self.slice_index.SetRange(min_value, max_value)
    if (self.settings.slice_index > max_value) :
      self.settings.slice_index = max_value
      self.slice_index.SetValue(max_value)
    elif (self.settings.slice_index < min_value) :
      self.settings.slice_index = min_value
      self.slice_index.SetValue(min_value)
    if (not self.is_3d_view) or (self.slice_ctrl.GetValue()) :
      try :
        self.parent.update_settings()
      except ValueError as e : # TODO set limits
        raise Sorry(str(e))

  def OnChangeSpaceGroup (self, event) :
    sg_sel = str(self.sg_ctrl.GetStringSelection())
    if (sg_sel != self._last_sg_sel) :
      from cctbx import sgtbx
      sg_info = sgtbx.space_group_info(sg_sel)
      self.parent.set_space_group(sg_info)

####Kau added starts here
  def OnChangeColumn (self, event) :
    column_sel = self.column_ctrl.GetSelection()
    if (column_sel != self._last_column_sel) :
        self.parent.set_column(column_sel)
# ####Kau added ends here

  def OnChangeResolution (self, event) :
    self.settings.d_min = self.d_min_ctrl.GetValue()
    self.parent.update_settings()


####Kau added starts here
  def OnChangeIoverSigI (self, event) :
    i_on_sig_i = self.IoverSigI_ctrl.GetValue()
    self.settings.d_min = self.parent.miller_array.sigma_filter(i_on_sig_i).d_min()
    self.parent.update_settings()
# ####Kau added ends here

  def OnChangeColor (self, event) :
    self.settings.color_scheme = str(self.color_ctrl.GetStringSelection())
    self.parent.update_settings()

  def OnSetScale (self, event) :
    self.settings.scale = (self.scale_ctrl.GetValue() + 4) / 4
    self.parent.update_settings()

##kau added starts here
  # def OnInformationColorChange(self,event):
  #   self.settings.color_scheme = (self.color_ctrl.GetValue()+4) / 4
  #   set.parent.update_settings()
##Kau added ends here

class HKLViewFrame (wx.Frame) :
  def __init__ (self, *args, **kwds) :
    wx.Frame.__init__(self, *args, **kwds)
    self.parent = self.GetParent()
    self.view_2d = None
    self.view_3d = None # used by 2D subclass
    self.statusbar = self.CreateStatusBar()
    self.sizer = wx.BoxSizer(wx.HORIZONTAL)
    self.miller_array = None
    app = wx.GetApp()
    if (getattr(app, "hklview_settings", None) is not None) :
      # XXX copying the initial settings avoids awkward interactions when
      # multiple viewer windows are opened
      self.settings = copy.deepcopy(app.hklview_settings)
    else :
      self.settings = settings()
    self.create_settings_panel()
    self.sizer.Add(self.settings_panel, 0, wx.EXPAND)
    self.create_viewer_panel()
    self.sizer.Add(self.viewer, 1, wx.EXPAND|wx.ALL)
    self.SetupToolbar()
    self.SetupMenus()
    self.add_view_specific_functions()
    self.SetMenuBar(self.menubar)
    self.toolbar.Realize()
    self.SetSizerAndFit(self.sizer)
    self.SetMinSize(self.settings_panel.GetSize())
    self.Bind(wx.EVT_CLOSE, self.OnClose, self)
    self.Bind(wx.EVT_WINDOW_DESTROY, self.OnDestroy, self)
    self.Bind(wx.EVT_ACTIVATE, self.OnActive)
    self.viewer.SetFocus()

  def SetupToolbar (self) :
    self.toolbar = self.CreateToolBar(style=wx.TB_TEXT)
    if wx.VERSION < (4,0):
      self.toolbar.AddTool = self.toolbar.AddLabelTool
    self.toolbar.SetToolBitmapSize((32,32))
    btn = self.toolbar.AddTool(-1,
      label="Load file",
      bitmap=icons.hkl_file.GetBitmap(),
      shortHelp="Load file",
      kind=wx.ITEM_NORMAL)
    self.Bind(wx.EVT_MENU, self.OnLoadFile, btn)
    btn = self.toolbar.AddTool(-1,
      label="Save image",
      bitmap=icons.save_all.GetBitmap(),
      shortHelp="Save image",
      kind=wx.ITEM_NORMAL)
    self.Bind(wx.EVT_MENU, self.OnSave, btn)
    btn = self.toolbar.AddTool(-1,
      label="Delete reflection",
      bitmap=bitmaps.fetch_icon_bitmap("actions","editdelete"), # FIXME
      shortHelp="Delete reflection",
      kind=wx.ITEM_NORMAL)
    self.Bind(wx.EVT_MENU, self.OnDeleteReflection, btn)

  def SetupMenus (self) :
    self.menubar = wx.MenuBar(-1)
    self.file_menu = wx.Menu()
    if wx.VERSION < (4,0):
      self.file_menu.Append = self.file_menu.AppendItem
    self.menubar.Append(self.file_menu, "File")
    item = wx.MenuItem(self.file_menu, -1, "Load data...\tCtrl-O")
    self.Bind(wx.EVT_MENU, self.OnLoadFile, item)
    self.file_menu.Append(item)
    if (libtbx.env.has_module("phenix")) :
      phenix_dir = os.path.dirname(libtbx.env.dist_path("phenix"))
      examples_dir = os.path.join(phenix_dir, "phenix_examples")
      if (os.path.isdir(examples_dir)) :
        submenu = wx.Menu()
        if wx.VERSION < (4,0):
          submenu.Append = self.file_menu.AppendItem
        self.file_menu.AppendSubMenu(submenu, "Load example data")
        examples_and_data = [
          ("p9-sad", "p9.sca"),
          ("sec17-sad", "sec17.sca"),
          ("rnase-s", "rnase25.mtz"),
          ("porin-twin", "porin.mtz"),
        ]
        for subdir, data in examples_and_data :
          example_file = os.path.join(examples_dir, subdir, data)
          item = wx.MenuItem(submenu, -1, subdir)
          submenu.Append(item)
          self.Bind(wx.EVT_MENU,
            lambda evt, f=example_file: self.load_reflections_file(f), item)

  def OnActive (self, event) :
    if (self.IsShown()) and (type(self.viewer).__name__ != "_wxPyDeadObject") :
      self.viewer.Refresh()

  def create_viewer_panel (self) :
    self.viewer = view_3d.hklview_3d(parent=self, size=(800,600),
      style=wx.glcanvas.WX_GL_DOUBLEBUFFER)

  def create_settings_panel (self) :
    self.settings_panel = settings_window(self, -1, style=wx.RAISED_BORDER)
    # print("I am printing type", type(self.settings_panel))

  def add_view_specific_functions (self) :
    item = wx.MenuItem(self.file_menu, -1, "Show 2D view")
    self.file_menu.Append(item)
    self.Bind(wx.EVT_MENU, self.OnShow2D, item)
    btn = self.toolbar.AddTool(-1,
      label="Show 2D view",
      bitmap=icons.hklview_2d.GetBitmap(),
      shortHelp="Show 2D view",
      kind=wx.ITEM_NORMAL)
    self.Bind(wx.EVT_MENU, self.OnShow2D, btn)
    btn = self.toolbar.AddTool(-1,
      label="Clear labels",
      bitmap=icons.clear_left.GetBitmap(),
      shortHelp="Clear labels",
      kind=wx.ITEM_NORMAL)
    self.Bind(wx.EVT_MENU, self.OnClearLabels, btn)

  def update_clicked (self, index) :#hkl, d_min=None, value=None) :
    if (index is None) :
      self.settings_panel.clear_reflection_info()
    else :
      hkl, d_min, value = self.viewer.scene.get_reflection_info(index)
      self.settings_panel.update_reflection_info(hkl, d_min, value)

  def update_settings_for_unmerged (self) :
    self.settings.expand_to_p1 = False
    self.settings.expand_anomalous = False
    self.settings_panel.get_control("expand_to_p1").SetValue(False)
    self.settings_panel.get_control("expand_to_p1").Enable(False)
    self.settings_panel.get_control("expand_anomalous").SetValue(False)
    self.settings_panel.get_control("expand_anomalous").Enable(False)
    self.settings_panel.get_control("scale_radii_multiplicity").Enable(False)

  def update_settings_for_merged (self, enable_multiplicity=False) :
    self.settings_panel.get_control("expand_to_p1").Enable(True)
    self.settings_panel.get_control("expand_anomalous").Enable(True)
    if (enable_multiplicity) :
      self.settings_panel.get_control("scale_radii_multiplicity").Enable(True)
    else :
      self.settings_panel.get_control("scale_radii_multiplicity").Enable(False)

  def process_miller_array (self, array) :
    if (array is None) : return
    if (array.is_hendrickson_lattman_array()) :
      raise Sorry("Hendrickson-Lattman coefficients are not supported.")
    info = array.info()
    if isinstance(info, str) :
      labels = "TEST DATA"
    else :
      labels = info.label_string()
    if (array.unit_cell() is None) or (array.space_group() is None) :
      dlg = wxtbx.symmetry_dialog.SymmetryDialog(self, -1, "Enter symmetry")
      dlg.SetUnitCell(array.unit_cell())
      dlg.SetSpaceGroup(array.space_group_info())
      if (dlg.ShowModal() == wx.ID_OK) :
        symm = dlg.GetSymmetry()
        array = array.customized_copy(crystal_symmetry=symm).set_info(info)
      wx.CallAfter(dlg.Destroy)
    details = []
    merge = None
    if (not array.is_unique_set_under_symmetry()) :
      merge = wx.MessageBox("The data in the selected array are not symmetry-"+
        "unique, which usually means they are unmerged (but could also be due "+
        "to different indexing conventions).  Do you want to merge equivalent "+
        "observations (preserving anomalous data if present), or view the "+
        "array unmodified?  (Note that if you do not merge the array, the "+
        "options to expand to P1 or generate Friedel pairs will be be disabled"+
        ", and the 2D view will only show indices present in the file, rather "+
        "than a full pseudo-precession view.)",
        style=wx.YES_NO)
      if (merge == wx.YES) :
        merge = True
        #array = array.merge_equivalents().array().set_info(info)
        details.append("merged")
        self.update_settings_for_merged(True)
      else :
        merge = False
        details.append("unmerged data")
        self.update_settings_for_unmerged()
    else :
      self.update_settings_for_merged()
    if array.is_complex_array() :
      array = array.amplitudes().set_info(info)
      details.append("as amplitudes")
    from iotbx.reflection_file_utils import looks_like_r_free_flags_info
    if (array.is_integer_array()) and (looks_like_r_free_flags_info(info)) :
      from iotbx.reflection_file_utils import get_r_free_flags_scores
      score_array = get_r_free_flags_scores([array], None)
      test_flag_value = score_array.test_flag_values[0]
      array = array.customized_copy(data=(array.data() == test_flag_value))
      array.set_info(info)
    sg = "%s" % array.space_group_info()
    uc = "a=%g b=%g c=%g angles=%g,%g,%g" % array.unit_cell().parameters()
    details_str = ""
    if (len(details) > 0) :
      details_str = "(%s)" % ", ".join(details)
    array_info = group_args(
      labels=labels,
      details_str=details_str,
      merge=merge,
      sg=sg,
      uc=uc)
    return array, array_info

  def set_miller_array (self, array) :
    if (array is None) : return
    array, array_info = self.process_miller_array(array)
    self.statusbar.SetStatusText("Data: %s %s (Space group: %s  Unit Cell: %s)"
      % (array_info.labels, array_info.details_str, array_info.sg,
          array_info.uc))
    self.settings_panel.d_min_ctrl.SetValue(array.d_min())
    self.settings_panel.d_min_ctrl.SetRange(array.d_min(), 20.0)
##kau added starts
    # self.settings_panel.IoverSigI_ctrl.SetValue(array.sigma_filter(0.0).d_min())
    # self.settings_panel.IoverSigI_ctrl.SetRange(array.sigma_filter(0.5).d_min(), 100.0)
    self.settings_panel.IoverSigI_ctrl.SetValue(0.0)
    self.settings_panel.IoverSigI_ctrl.SetRange(0.0, 100.0)

##Kau added ends
    self.settings_panel.set_index_span(array.index_span())
    self.settings_panel.update_space_group_choices(array)
    # self.settings_panel.update_column_choices(array) # kau added
    if (type(self).__name__ == "HKLViewFrame") :
      if (array.indices().size() > 100000) :
        if (self.settings.spheres) :
          cnf = wx.MessageBox(message="Warning: this is a lot of reflections; "+
            "unless you have a very powerful graphics card, displaying "+
            "spheres may be slow and/or unstable, especially if data are "+
            "expanded to P1.  Do you want to switch to a faster rendering "+
            "style?", style=wx.YES|wx.NO)
          if (cnf == wx.YES) :
            self.settings.spheres = False
            self.settings_panel.spheres_ctrl.SetValue(False)
    self.miller_array = array
    # print("kau this is array ",type(array))
    self.viewer.set_miller_array(array, zoom=True, merge=array_info.merge)
    self.viewer.Refresh()
    if (self.view_2d is not None) :
      self.view_2d.set_miller_array(array)

  def update_settings (self, *args, **kwds) :
    if (self.miller_array is None) :
      return False
    self.viewer.update_settings(*args, **kwds)

  def set_space_group (self, space_group_info) :
    # print("kau printing space_group_info ", space_group_info)
    if (self.miller_array is None) :
      raise Sorry("No data loaded!")
    from cctbx import crystal
    symm = crystal.symmetry(
      space_group_info=space_group_info,
      unit_cell=self.miller_array.unit_cell())
    array = self.miller_array.expand_to_p1().customized_copy(
      crystal_symmetry=symm)
    print("MERGING 2")
    array = array.merge_equivalents().array().set_info(self.miller_array.info())
    self.viewer.set_miller_array(array, zoom=False)
    self.viewer.Refresh()

#kau added starts here
  def set_column (self, column_sel) :
    # print("kau printing column_sel ", column_sel)
    self.set_miller_array(self.valid_arrays[column_sel])
    if (self.miller_array is None) :
      raise Sorry("No data loaded!")
    # from cctbx import crystal
    # symm = crystal.symmetry(
    #   space_group_info=space_group_info,
    #   unit_cell=self.miller_array.unit_cell())
    # array = self.miller_array.expand_to_p1().customized_copy(
    #   crystal_symmetry=symm)
    # print "MERGING 2"
    # array = array.merge_equivalents().array().set_info(self.miller_array.info())
    # array=self.miller_array.column_root_label(column_sel)
    # print("Kau this is array from set_column ", array)
    # settings_panel.array_storage()
    # self.viewer.set_miller_array(array[column_sel], zoom=False)
    self.viewer.Refresh()
##kau added ends here

  def delete_miller_index (self, hkl) :
    if (self.miller_array is None) :
      raise Sorry("No data loaded!")
    info = self.miller_array.info()
    self.miller_array = self.miller_array.delete_index(hkl).set_info(info)
    self.viewer.set_miller_array(self.miller_array, zoom=True)
    self.viewer.Refresh()

  def load_reflections_file (self, file_name, set_array=True,
      data_only=False) :
    file_name = to_str(file_name)
    if (file_name != "") :
      from iotbx.reflection_file_reader import any_reflection_file
      from iotbx.gui_tools.reflections import get_array_description
      try :
        hkl_file = any_reflection_file(file_name)
      except Exception as e :
        raise Sorry(to_str(e))
      arrays = hkl_file.as_miller_arrays(merge_equivalents=False,
        )#observation_type_callback=misc_dialogs.get_shelx_file_data_type)
      #arrays = f.file_server.miller_arrays
      valid_arrays = []
      array_info = []
      for array in arrays :
        if array.is_hendrickson_lattman_array() :
          continue
        elif (data_only) :
          if (not array.is_real_array()) and (not array.is_complex_array()) :
            continue
        labels = array.info().label_string()
        desc = get_array_description(array)
        array_info.append("%s (%s)" % (labels, desc))
        valid_arrays.append(array)
      self.valid_arrays = valid_arrays
      if (len(valid_arrays) == 0) :
        msg = "No arrays of the supported types in this file."
        raise Sorry(msg)
      elif (len(valid_arrays) == 1) :
        if (set_array) :
          self.set_miller_array(valid_arrays[0])
        return valid_arrays[0]
      else :
        #dlg = SelectArrayDialog(self, -1, "Select data")
        dlg = wx.SingleChoiceDialog(parent=None,
          message="Please select the data you wish to view:",
          caption="Select data",
          choices=array_info)
        # print("kau labels info is", array_info) #Kau added
        # print("Kau printing array_info from calling ", array_info)

        if (dlg.ShowModal() == wx.ID_OK) :
          sel = dlg.GetSelection()
          if (set_array) :
            self.set_miller_array(valid_arrays[sel])
          wx.CallAfter(dlg.Destroy)
          self.settings_panel.update_column_choices(array_info, valid_arrays,sel) # kau added
          # self.settings_panel.update_column_choices(array_info,valid_arrays,sel) # kau added
          return valid_arrays[sel]
        wx.CallAfter(dlg.Destroy)

    raise Abort()

  def OnLoadFile (self, evt) :
    file_name = wx.FileSelector("Reflections file",
      wildcard="Reflection files (*.mtz, *.sca, *.hkl)|*.mtz;*.sca;*.hkl",
      default_path=os.getcwd(),
      flags=wx.FD_OPEN)
    self.load_reflections_file(to_str(file_name))

  def OnSave (self, evt) :
    output_file = wx.FileSelector("Save image as:",
      default_path=os.getcwd(),
      default_filename="hklview.png",
      wildcard="PNG image (*.png)|*.png",
      flags=wx.FD_SAVE)
    if (output_file != "") :
      self.viewer.save_screen_shot(file_name=to_str(output_file),
        extensions=["png"])

  def OnShow2D (self, evt) :
    if (self.view_2d is None) :
      self.view_2d = HKLViewFrame2D(self, -1, "2D data viewer")
      self.view_2d.set_miller_array(self.viewer.miller_array)
      self.view_2d.Show()
      if (wxtbx.MAC_OS_X_MAVERICKS) :
        wx.GetApp().SafeYield(self.view_2d, True)
    self.view_2d.Raise()

  def OnDeleteReflection (self, event) :
    hkl = simple_dialogs.get_miller_index(
      parent=self,
      title="Delete reflection",
      label="h,k,l",
      caption="Please specify the Miller index (h,k,l) of the reflection "+
        "to delete.  This will only delete a single value; Friedel mates "+
        "and unmerged symmetry-related observations will not be affected.")
    if (hkl is not None) :
      self.delete_miller_index(hkl)

  def OnClearLabels (self, evt) :
    self.viewer.clear_labels()

  def OnClose (self, event) :
    self.Unbind(wx.EVT_ACTIVATE)
    self.Destroy()
    event.Skip()

  def OnDestroy (self, event) :
    if (self.parent is not None) :
      self.parent.view_3d = None
    event.Skip()

  def Destroy(self):
    self.Hide()
    return True

class settings_window_2d (settings_window) :
  is_3d_view = False

class HKLViewFrame2D (HKLViewFrame) :
  def create_viewer_panel (self) :
    self.viewer = view_2d.hklview_2d(parent=self, size=(640,640))
    self.viewer.SetMinSize((640,640))

  def create_settings_panel (self) :
    self.settings.expand_to_p1 = True
    self.settings.expand_anomalous = True
    self.settings.slice_mode = True
    #self.settings.black_background = False
    self.settings_panel = settings_window_2d(self, -1, style=wx.RAISED_BORDER)

  def add_view_specific_functions (self) :
    item = wx.MenuItem(self.file_menu, -1, "Show 3D view")
    self.file_menu.Append(item)
    self.Bind(wx.EVT_MENU, self.OnShow3D, item)
    btn = self.toolbar.AddTool(-1,
      label="Show 3D view",
      bitmap=icons.hklview_3d.GetBitmap(),
      shortHelp="Show 3D view",
      kind=wx.ITEM_NORMAL)
    self.Bind(wx.EVT_MENU, self.OnShow3D, btn)

  def update_settings_for_merged (self, enable_multiplicity=False) :
    self.settings.expand_to_p1 = True
    self.settings.expand_anomalous = True
    if (enable_multiplicity) :
      self.settings_panel.get_control("scale_radii_multiplicity").Enable(True)
    else :
      self.settings_panel.get_control("scale_radii_multiplicity").Enable(False)

  def OnClose (self, evt) :
    self.Destroy()
    evt.Skip()

  def OnDestroy (self, event) :
    if (self.parent is not None) :
      self.parent.view_2d = None
    event.Skip()

  def OnShow2D (self, evt) :
    pass

  def OnShow3D (self, evt) :
    if (self.view_3d is None) :
      self.view_3d = HKLViewFrame(self, -1, "3D data viewer")
      self.view_3d.Show()
      if (self.viewer.miller_array is not None) :
        self.view_3d.set_miller_array(self.viewer.miller_array)
    self.view_3d.Raise()


 *******************************************************************************


 *******************************************************************************
crys3d/hklview/view_2d.py
from __future__ import absolute_import, division, print_function

# TODO:
#  - cached scenes

from crys3d import hklview
import cctbx.miller.display
import wx
from math import sqrt
import sys

class hklview_2d (wx.Panel, cctbx.miller.display.render_2d) :
  def __init__ (self, *args, **kwds) :
    wx.Panel.__init__(self, *args, **kwds)
    font = wx.Font(14, wx.MODERN, wx.NORMAL, wx.NORMAL)
    self.SetFont(font)
    self.Bind(wx.EVT_PAINT, self.OnPaint)
    self.Bind(wx.EVT_LEFT_DOWN, self.OnLeftClick, self)
    self.Bind(wx.EVT_LEFT_UP, self.OnLeftUp, self)
    self.Bind(wx.EVT_MOTION, self.OnMouseMotion, self)
    self.scene = None
    self.miller_array = None
    self.parent = self.GetParent()
    self.settings = self.parent.settings
    self.was_dragged = False
    self.initLeft = None, None
    self._points_2d = []
    self._radii_2d = []
    self._clicked = None

  def GetSize (self) :
    return wx.Panel.GetSize(self)

  # XXX silent keyword 'zoom=False' is for compatibility with view_3d.py
  def set_miller_array (self, array, zoom=False, merge=None) :
    self.miller_array = array
    self.merge = merge
    if (array is not None) :
      self.construct_reciprocal_space(merge=merge)

  def construct_reciprocal_space (self, merge=None) :
    self.scene = hklview.scene(miller_array=self.miller_array,
      merge=merge,
      settings=self.settings)
    self._clicked = None
    self.setup_colors()

  def update_settings (self) :
    self.construct_reciprocal_space(merge=self.merge)
    self.Refresh()

  def get_color (self, c) :
    return (int(c[0]*255), int(c[1]*255), int(c[2]*255))

  def draw_line (self, canvas, x1, y1, x2, y2) :
    gc = canvas
    x_axis = gc.CreatePath()
    x_axis.MoveToPoint(x1, y1)
    x_axis.AddLineToPoint(x2, y2)
    x_axis.CloseSubpath()
    gc.SetPen(wx.Pen(self.get_color(self._foreground)))
    gc.PushState()
    gc.StrokePath(x_axis)
    gc.PopState()

  def draw_text (self, canvas, text, x, y) :
    gc = canvas
    gc.SetPen(wx.Pen(self.get_color(self._foreground)))
    gc.DrawText(text, x, y)

  def draw_open_circle (self, canvas, x, y, radius, color=None) :
    gc = canvas
    path = gc.CreatePath()
    path.AddCircle(0, 0, radius)
    path.CloseSubpath()
    gc.PushState()
    gc.Translate(x,y)
    gc.SetBrush(wx.TRANSPARENT_BRUSH)
    if (color is None) :
      color = self._foreground
    pen = wx.Pen(self.get_color(color))
    gc.SetPen(pen)
    gc.StrokePath(path)
    gc.PopState()

  def draw_filled_circle (self, canvas, x, y, radius, color) :
    gc = canvas
    path = gc.CreatePath()
    path.AddCircle(0, 0, radius)
    path.CloseSubpath()
    gc.PushState()
    gc.Translate(x,y)
    if (color is None) :
      color = self._foreground
    pen = wx.Pen(self.get_color(color))
    brush = wx.Brush(self.get_color(color))
    gc.SetPen(pen)
    gc.SetBrush(brush)
    gc.FillPath(path)
    gc.PopState()

  def paint (self, gc) :
    font = self.GetFont()
    font.SetFamily(wx.FONTFAMILY_MODERN)
    if (self.settings.black_background) :
      gc.SetFont(gc.CreateFont(font, (255,255,255)))
    else :
      gc.SetFont(gc.CreateFont(font, (0,0,0)))
    self.render(gc)

  def save_screen_shot (self, **kwds) :
    pass

  def process_pick_points (self, x, y) :
    context = wx.ClientDC( self )
    w, h = self.GetClientSize()
    if wx.VERSION[0] > 3:
      bitmap = wx.Bitmap( w, h, -1 )
    else:
      # https://discuss.wxpython.org/t/wx-bitmap-x-y-and-wx-bitmap-create-x-y-vs-wx-emptybitmap-x-y/29463
      bitmap = wx.EmptyBitmap(w, h, -1)
    memory = wx.MemoryDC(bitmap)
    memory.SelectObject(bitmap)
    memory.Blit(0, 0, w, h, context, 0, 0)
    memory.SelectObject(wx.NullBitmap)
    if (wx.Platform == '__WXMAC__') :
      pixelData = wx.AlphaPixelData(bitmap)
      pixelAccessor = pixelData.GetPixels()
      pixelAccessor.MoveTo(pixelData, x, y)
      c = pixelAccessor.Get()
    else :
      c = memory.GetPixel(x, y)
    bg = self.GetBackgroundColour()
    self._clicked = None
    min_dist = sys.maxsize
    closest_hkl = None
    for k, (x2,y2) in enumerate(self._points_2d) :
      dist = sqrt((x2-x)**2 + (y2-y)**2)
      if (dist <= (self._radii_2d[k] + 2)) :
        self._clicked = k
        break
    hkl = d_min = value = None
    if (self._clicked is not None) :
      self.GetParent().update_clicked(self._clicked)
    self.Refresh()

  # placeholder - mimics gltbx.wx_viewer.wxGLWindow.fit_into_viewport
  def fit_into_viewport (self) :
    pass

  # mimics gltbx.wx_viewer.wxGLWindow.save_screen_shot
  def save_screen_shot (self, file_name, extensions=None) :
    rect = self.GetRect()
    if wx.VERSION[0] > 3:
      bitmap = wx.Bitmap(rect.width, rect.height)
    else:
      # https://discuss.wxpython.org/t/wx-bitmap-x-y-and-wx-bitmap-create-x-y-vs-wx-emptybitmap-x-y/29463
      bitmap = wx.EmptyBitmap(rect.width, rect.height)
    memory_dc = wx.MemoryDC()
    memory_dc.SelectObject(bitmap)
    #memory_dc.SetBackgroundMode(wx.TRANSPARENT)
    if (self.settings.black_background) :
      memory_dc.SetBackground(wx.BLACK_BRUSH)
    else :
      memory_dc.SetBackground(wx.WHITE_BRUSH)
    memory_dc.Clear()
    gc = wx.GraphicsContext.Create(memory_dc)
    self.paint(gc)
    bitmap.SaveFile(file_name, wx.BITMAP_TYPE_PNG)

  def OnPaint (self, event) :
    if (self.scene is None) :
      return
    if (self.settings.black_background) :
      self.SetBackgroundColour((0,0,0))
    else :
      self.SetBackgroundColour((255,255,255))
    dc = wx.AutoBufferedPaintDCFactory(self)
    if (self.settings.black_background) :
      dc.SetBackground(wx.BLACK_BRUSH)
    else :
      dc.SetBackground(wx.WHITE_BRUSH)
    dc.Clear()
    gc = wx.GraphicsContext.Create(dc)
    self.paint(gc)

  def OnLeftClick (self, evt) :
    self.initLeft = evt.GetX(), evt.GetY()

  def OnLeftUp (self, evt) :
    x = evt.GetX()
    y = evt.GetY()
    if (not self.was_dragged) :
      if (x == self.initLeft[0]) and (y == self.initLeft[1]) :
        self.process_pick_points(x,y)
    self.was_dragged = False

  def OnMouseMotion (self, evt) :
    if (not evt.Dragging()) :
      return
    elif (evt.LeftIsDown()) :
      self.was_dragged = True

  def OnChar (self, evt) :
    pass


 *******************************************************************************


 *******************************************************************************
crys3d/hklview/view_3d.py

# TODO:
#  - cached scenes

from __future__ import absolute_import, division, print_function
from crys3d import hklview
#from crys3d.leapmotion import wxGLWindowLeapEnabled as wxGLWindow
from gltbx.wx_viewer import wxGLWindow
import gltbx.viewer_utils
import gltbx.gl_managed
import gltbx.quadrics
import gltbx.util
import gltbx.fonts
from gltbx.glu import *
from gltbx.gl import *
import wx

class hklview_3d (wxGLWindow) :
  def __init__ (self, *args, **kwds) :
    wxGLWindow.__init__(self, *args, **kwds)
    self.Bind(wx.EVT_LEFT_DCLICK, self.OnDoubleClick)
    self.Bind(wx.EVT_ERASE_BACKGROUND, lambda evt: None)
    # FIXME orthographic is definitely best for this application, but it isn't
    # working properly right now
    #self.orthographic = True
    parent = self.GetParent()
    if (parent is None) :
      parent = kwds.get("parent")
    assert (parent is not None)
    self.settings = parent.settings
    self.buffer_factor = 2.0
    self.min_slab = 4
    self.min_viewport_use_fraction = 0.1
    self.min_dist = 4.0
    self.flag_show_fog = True
    self.flag_use_lights = True
    self.flag_use_quadrics = False
    self.minimum_covering_sphere = None
    self.spheres_display_list = None
    self.points_display_list = None
    self.labels_display_list = None
    self.miller_array = None
    self.d_min = None
    self.scene = None
    self.animation_time = 0
    #self.fps = gltbx.viewer_utils.fps_monitor()
    # XXX prevent exception when no data are loaded
    from scitbx.math import minimum_covering_sphere
    from scitbx.array_family import flex
    points = flex.vec3_double([(0.0,0.0,0.0),(1.0,1.0,1.0)])
    mcs = minimum_covering_sphere(points=points, epsilon=0.1)
    self.minimum_covering_sphere = mcs
    #self.Bind(wx.EVT_SHOW, self.OnPaint, self)

  def set_miller_array (self, miller_array, zoom=False, merge=None) :
    self.miller_array = miller_array
    self.merge = merge
    self.d_min = miller_array.d_min()
    self.construct_reciprocal_space(merge=merge)
    # XXX for some reason InitGL does not get called until well after the
    # window is shown on (at least) Windows 7, so we need to check whether
    # it's safe to make OpenGL calls before zooming
    if (zoom) and (not self.GL_uninitialised) :
      self.fit_into_viewport()

  def construct_reciprocal_space (self, merge=None) :
    self.scene = hklview.scene(miller_array=self.miller_array,
      merge=merge,
      settings=self.settings)
    from scitbx.math import minimum_covering_sphere
    mcs = minimum_covering_sphere(points=self.scene.points,
                                  epsilon=0.1)
    self.minimum_covering_sphere = mcs
    self.spheres_display_list = None
    self.points_display_list = None
    self.labels_display_list = None
    self.rotation_center = (0,0,0)

  #--- OpenGL methods
  def InitGL(self):
    gltbx.util.handle_error()
    if (self.settings.black_background) :
      glClearColor(0.,0.,0.,0.)
    else :
      glClearColor(0.95,0.95,0.95,0.)
    self.minimum_covering_sphere_display_list = None
    glDepthFunc(GL_LESS)
    glEnable(GL_ALPHA_TEST)
    glEnable(GL_DEPTH_TEST)
    glEnable(GL_BLEND)
    glEnable(GL_LINE_SMOOTH)
    glHint(GL_LINE_SMOOTH_HINT, GL_NICEST)
    self.initialize_modelview()
    glPolygonMode(GL_FRONT_AND_BACK, GL_FILL)
    self.proto_sphere = gltbx.quadrics.proto_ellipsoid(slices=8, stacks=8)
    gltbx.util.handle_error()

  def OnRedrawGL (self, event=None) :
    if (self.minimum_covering_sphere is None) :
      gltbx.util.handle_error()
      glClear(GL_COLOR_BUFFER_BIT)
      glClear(GL_DEPTH_BUFFER_BIT)
      glFlush()
      self.SwapBuffers()
      gltbx.util.handle_error()
    else :
      wxGLWindow.OnRedrawGL(self, event)

  def initialize_modelview (self) :
    if (self.minimum_covering_sphere is not None) :
      wxGLWindow.initialize_modelview(self)
    else :
      self.setup_lighting()

  def DrawGL(self):
    if (self.GL_uninitialised) or (self.miller_array is None) :
      return
    if (self.settings.show_axes) :
      self.draw_axes()
    if (self.settings.spheres) :
      self.draw_spheres()
    else :
      self.draw_points()
    if (self.settings.show_labels) :
      self.draw_labels()
    #self.fps.update()

  def draw_spheres (self) :
    glMatrixMode(GL_MODELVIEW)
    glShadeModel(GL_SMOOTH)
    glEnable(GL_DEPTH_TEST)
    glEnable(GL_LIGHTING)
    glEnable(GL_LIGHT0)
    glEnable(GL_NORMALIZE)
    glPolygonMode(GL_FRONT_AND_BACK, GL_FILL)
    if (self.spheres_display_list is None) :
      self.spheres_display_list = gltbx.gl_managed.display_list()
      self.spheres_display_list.compile()
      colors = self.scene.colors
      radii = self.scene.radii
      points = self.scene.points
      sphere = self.proto_sphere
      max_radius = self.scene.max_radius
      scale_factor = self.settings.sphere_detail / self.scene.max_radius
      assert (colors.size() == radii.size() == self.scene.points.size())
      glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, [0.1, 0.1, 0.1, 1.0])
      glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, [0.1, 0.1, 0.1, 1.0])
      for i, hkl in enumerate(points) :
        col = list(colors[i]) + [1.0]
        #glColor3f(*colors[i])
        glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, col)
        if (self.flag_use_quadrics) :
          r = max(radii[i] / 10, 0.001)
          sphere.draw(hkl, (r, r, r, 0, 0, 0))
        else :
          detail = max(4, int(radii[i] * scale_factor))
          glPushMatrix()
          glTranslated(*hkl)
          gltbx.util.SolidSphere(radius=radii[i],
            slices=detail,
            stacks=detail)
          glPopMatrix()
      self.spheres_display_list.end()
    self.spheres_display_list.call()

  def draw_points (self) :
    glMatrixMode(GL_MODELVIEW)
    glDisable(GL_LIGHTING)
    if (self.points_display_list is None) :
      self.points_display_list = gltbx.gl_managed.display_list()
      self.points_display_list.compile()
      colors = self.scene.colors
      radii = self.scene.radii
      glLineWidth(2.0)
      gltbx.viewer_utils.draw_stars(
        points=self.scene.points,
        colors=colors,
        points_visible=self.scene.visible_points,
        radii=radii)
      self.points_display_list.end()
    self.points_display_list.call()

  def draw_axes (self) :
    h_axis = self.scene.axes[0]
    k_axis = self.scene.axes[1]
    l_axis = self.scene.axes[2]
    gltbx.fonts.ucs_bitmap_8x13.setup_call_lists()
    glDisable(GL_LIGHTING)
    if (self.settings.black_background) :
      glColor3f(1.0, 1.0, 1.0)
    else :
      glColor3f(0.,0.,0.)
    glLineWidth(1.0)
    glBegin(GL_LINES)
    glVertex3f(0.,0.,0.)
    glVertex3f(h_axis[0]*100, h_axis[1]*100, h_axis[2]*100)
    glEnd()
    glRasterPos3f(0.5+h_axis[0]*100, 0.2+h_axis[1]*100, 0.2+h_axis[2]*100)
    gltbx.fonts.ucs_bitmap_8x13.render_string("h")
    glBegin(GL_LINES)
    glVertex3f(0.,0.,0.)
    glVertex3f(k_axis[0]*100, k_axis[1]*100, k_axis[2]*100)
    glEnd()
    glRasterPos3f(0.2+k_axis[0]*100, 0.5+k_axis[1]*100, 0.2+k_axis[2]*100)
    gltbx.fonts.ucs_bitmap_8x13.render_string("k")
    glBegin(GL_LINES)
    glVertex3f(0.,0.,0.)
    glVertex3f(l_axis[0]*100, l_axis[1]*100, l_axis[2]*100)
    glEnd()
    glRasterPos3f(0.2+l_axis[0]*100, 0.5+l_axis[1]*100, 0.2+l_axis[2]*100)
    gltbx.fonts.ucs_bitmap_8x13.render_string("l")
    glEnable(GL_LINE_STIPPLE)
    glLineStipple(4, 0xAAAA)
    glBegin(GL_LINES)
    glVertex3f(0.,0.,0.)
    glVertex3f(-h_axis[0]*100, -h_axis[1]*100, -h_axis[2]*100)
    glEnd()
    glBegin(GL_LINES)
    glVertex3f(0.,0.,0.)
    glVertex3f(-k_axis[0]*100, -k_axis[1]*100, -k_axis[2]*100)
    glEnd()
    glBegin(GL_LINES)
    glVertex3f(0.,0.,0.)
    glVertex3f(-l_axis[0]*100, -l_axis[1]*100, -l_axis[2]*100)
    glEnd()
    glDisable(GL_LINE_STIPPLE)

  def draw_labels (self) :
    glMatrixMode(GL_MODELVIEW)
    glDisable(GL_LIGHTING)
    gltbx.fonts.ucs_bitmap_8x13.setup_call_lists()
    if (self.labels_display_list is None) :
      self.labels_display_list = gltbx.gl_managed.display_list()
      self.labels_display_list.compile()
      colors = self.scene.colors
      points = self.scene.points
      indices = self.scene.indices
      assert (colors.size() == indices.size() == points.size())
      for i_seq in self.scene.label_points :
        x, y, z = points[i_seq]
        glColor3f(*colors[i_seq])
        glRasterPos3f(x+0.5, y+0.5, z+0.5)
        gltbx.fonts.ucs_bitmap_8x13.render_string("%d,%d,%d" % indices[i_seq])
      self.labels_display_list.end()
    self.labels_display_list.call()

  #--- user input and settings
  def update_settings (self) :
    self.construct_reciprocal_space(merge=self.merge)
    if (self.settings.black_background) :
      glClearColor(0.,0.,0.,0.)
    else :
      glClearColor(0.95,0.95,0.95,0.)
    self.Refresh()

  def process_pick_points (self) :
    self.closest_point_i_seq = None
    if (self.pick_points is not None) and (self.scene is not None) :
      closest_point_i_seq = gltbx.viewer_utils.closest_visible_point(
        points=self.scene.points,
        atoms_visible=self.scene.visible_points,
        point0=self.pick_points[0],
        point1=self.pick_points[1])
      if (closest_point_i_seq is not None) :
        self.closest_point_i_seq = closest_point_i_seq
    if (self.closest_point_i_seq is not None) :
      self.scene.label_points.add(self.closest_point_i_seq)
      self.labels_display_list = None
      self.GetParent().update_clicked(index=self.closest_point_i_seq)
      #hkl, d_min, value = self.scene.get_reflection_info(
      #  self.closest_point_i_seq)
      #self.GetParent().update_clicked(hkl, d_min, value)
    else :
      self.GetParent().update_clicked(index=None)

  def clear_labels (self) :
    if (self.scene is not None) :
      self.scene.clear_labels()
      self.labels_display_list = None
      self.Refresh()

  def OnChar (self, event) :
    key = event.GetKeyCode()
    if (key == ord("m")) :
      self.OnScale(0.02)
    elif (key == ord("n")) :
      self.OnScale(-0.02)
    elif (key == ord("d")) :
      self.adjust_slab(-0.04)
    elif (key == ord("f")) :
      self.adjust_slab(0.04)
    elif (key == ord("Q")) :
      self.flag_use_quadrics = not self.flag_use_quadrics
      self.spheres_display_list = None
    elif (key == wx.WXK_UP) :
      self.rotate_view(0, 0, 0, 5, event.ShiftDown())
    elif (key == wx.WXK_DOWN) :
      self.rotate_view(0, 0, 0, -5, event.ShiftDown())
    elif (key == wx.WXK_LEFT) :
      self.rotate_view(0, 0, -5, 0, event.ShiftDown())
    elif (key == wx.WXK_RIGHT) :
      self.rotate_view(0, 0, 5, 0, event.ShiftDown())
    self.OnRedrawGL()

  def OnDoubleClick (self, event) :
    self.get_pick_points((event.GetX(), event.GetY()))
    self.process_pick_points()
    if self.closest_point_i_seq is not None :
      self.rotation_center = self.scene.points[self.closest_point_i_seq]
      self.move_to_center_of_viewport(self.rotation_center)

  def OnMouseWheel (self, event) :
    scale = event.GetWheelRotation()
    self.adjust_slab(0.01 * scale)
    self.OnRedrawGL()


 *******************************************************************************


 *******************************************************************************
crys3d/hklviewer/HKLviewer.py
# -*- coding: utf-8 -*-
#-------------------------------------------------------------------------------
# Name:        module1
# Purpose:
#
# Author:      oeffner
#
# Created:     09/05/2019
# Copyright:   (c) oeffner 2019
# Licence:     <your licence>
#-------------------------------------------------------------------------------
from __future__ import absolute_import, division, print_function

import sys, zmq, subprocess, time, traceback, zlib, io, os, math, os.path, re
if sys.version_info[0] < 3:
  print("HKLviewer GUI must be run from Python 3")
  sys.exit(-42)

os.environ['QT_MAC_WANTS_LAYER'] = '1'

from .qt import Qt, QtCore, QCoreApplication, QEvent, QItemSelectionModel, QSize, QSettings, QTimer, QUrl
from .qt import (  QAction, QAbstractScrollArea, QCheckBox, QColorDialog, QComboBox, QDialog, QDoubleSpinBox,
    QFileDialog, QFrame, QGridLayout, QGroupBox, QHeaderView, QHBoxLayout, QInputDialog, QLabel, QLineEdit, QCloseEvent,
    QMainWindow, QMenu, QMenuBar, QMessageBox, QPalette, QPlainTextEdit, QProgressBar, QPushButton, QRadioButton, QRect,
    QScrollBar, QSizePolicy, QSlider, QSpinBox, QSplitter, QStyleFactory, QStatusBar, QTableView, QTableWidget,
    QTableWidgetItem, QTabWidget, QTextEdit, QTextBrowser, QWidget )

from .qt import QColor, QFont, QIcon, QCursor, QDesktopServices
from .qt import ( QWebEngineView, QWebEngineProfile, QWebEnginePage )


from . import hklviewer_gui
from .helpers import ( MillerArrayTableView, MillerArrayTableForm, MyhorizontalHeader, MyQPlainTextEdit,
    MillerArrayTableModel, MPLColourSchemes, MillerTableColumnHeaderDialog, MyQDoubleSpinBox, FindDialog )


class MakeNewDataForm(QDialog):
  def __init__(self, parent=None):
    super(MakeNewDataForm, self).__init__(parent.window)
    self.setWindowFlag(Qt.WindowContextHelpButtonHint,False);
    self.setWindowTitle("Create a new reflection dataset")
    self.setSizeGripEnabled(True)
    layout = QGridLayout()
    sp = QSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
    sp.setVerticalStretch(10)
    parent.operationtxtbox.setSizePolicy(sp)
    parent.operationtxtbox.setMinimumSize(QSize(0, 30))

    sp2 = QSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
    sp2.setVerticalStretch(0)
    parent.operationlabeltxt.setSizePolicy(sp2)

    layout.addWidget(parent.operationlabeltxt,     0, 0, 1, 2)
    layout.addWidget(parent.MillerComboBox,        1, 0, 1, 1)
    layout.addWidget(parent.MillerLabel2,          1, 1, 1, 1)
    layout.addWidget(parent.MillerLabel3,          2, 0, 1, 2)
    layout.addWidget(parent.operationtxtbox,       3, 0, 1, 2)
    layout.addWidget(parent.newlabelLabel,         4, 0, 1, 1)
    layout.addWidget(parent.newlabeltxtbox,        4, 1, 1, 1)
    layout.addWidget(parent.operationbutton,       5, 0, 1, 2)
    layout.setRowStretch (0, 1)
    layout.setRowStretch (1 ,0)
    self.setLayout(layout)
    m = self.fontMetrics().width( "asdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdf")


class AboutForm(QDialog):
  def __init__(self, parent=None):
    super(AboutForm, self).__init__(parent.window)
    self.setWindowTitle("About HKLviewer")
    self.setWindowFlags(Qt.Tool)
    mainLayout = QGridLayout()
    self.aboutlabel = QLabel()
    self.aboutlabel.setWordWrap(True)
    self.aboutlabel.setTextInteractionFlags(Qt.TextBrowserInteraction);
    self.aboutlabel.setOpenExternalLinks(True);
    self.aboutlabel.setMaximumSize(QSize(16777215, 16777215))
    self.writeAboutstr("")
    self.copyrightstxt = QTextEdit()
    self.copyrightstxt.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOn)
    self.copyrightstxt.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOn)
    self.copyrightstxt.setReadOnly(True)
    self.copyrightstxt.setLineWrapMode(QTextEdit.LineWrapMode.NoWrap)
    self.copyrightstxt.setMaximumSize(QSize(16777215, 16777215))
    sp = QSizePolicy(QSizePolicy.Preferred, QSizePolicy.Preferred)
    self.copyrightstxt.setMinimumSize(QSize(350, 150))
    self.copyrightstxt.setSizePolicy(sp)
    self.aboutlabel.setSizePolicy(sp)
    self.OKbtn = QPushButton()
    self.OKbtn.setText("OK")
    self.OKbtn.clicked.connect(self.onOK)
    mainLayout.addWidget(self.aboutlabel,  0, 0, 1, 3)
    mainLayout.addWidget(self.copyrightstxt,  1, 0, 1, 3)
    mainLayout.addWidget(self.OKbtn,  2, 1, 1, 1)
    self.setLayout(mainLayout)
    self.setMinimumSize(QSize(400, 300))
    self.setSizePolicy(sp)
    self.setFixedSize( self.sizeHint() )
  def writeAboutstr(self, versionstr):
    aboutstr = """<html><head/><body><p>
    <span style=" font-weight:600;">HKLviewer, </span>
    CCTBX version: """ + versionstr + \
    """
    <br/>A reflection data viewer for crystallography
    <br/>Developers: Robert D. Oeffner<br/>
    Cambridge Institute for Medical Research, University of Cambridge.<br/>
    HKLviewer is part of the <a href="http://cci.lbl.gov/docs/cctbx/"> CCTBX library</a>
    as well as derived software thereof.<br/>
    HKLviewer uses functionality provided by the
    <a href="https://github.com/nglviewer/ngl">NGL Viewer</a> project and
    the <a href="https://github.com/niklasvh/html2canvas">html2canvas</a> project.
    Refer to robert@oeffner.net or cctbx@cci.lbl.gov for queries or bug reports.
    </p></body></html>"""
    self.aboutlabel.setText(aboutstr)
  def onOK(self):
    self.hide()


class SettingsForm(QDialog):
  def __init__(self, parent=None):
    super(SettingsForm, self).__init__(parent.window)
    self.setWindowTitle("HKLviewer Settings")
    self.setWindowFlags(Qt.Tool)
    myGroupBox = QGroupBox()
    layout = QGridLayout()
    layout.addWidget(parent.mousespeed_labeltxt,     0, 0, 1, 1)
    layout.addWidget(parent.mousemoveslider,         0, 1, 1, 3)
    layout.addWidget(parent.mousesensitxtbox,        0, 4, 1, 1)
    layout.addWidget(parent.Fontsize_labeltxt,       1, 0, 1, 1)
    layout.addWidget(parent.fontspinBox,             1, 4, 1, 1)
    layout.addWidget(parent.BrowserFontsize_labeltxt, 2, 0, 1, 1)
    layout.addWidget(parent.browserfontspinBox,      2, 4, 1, 1)
    layout.addWidget(parent.vectorWidth_labeltxt,    3, 0, 1, 1)
    layout.addWidget(parent.vectorWidthspinBox,      3, 4, 1, 1)
    layout.addWidget(parent.cameraPerspectCheckBox,  4, 0, 1, 1)
    layout.addWidget(parent.bufsize_labeltxt,        5, 0, 1, 1)
    layout.addWidget(parent.bufsizespinBox,          5, 4, 1, 1)
    layout.addWidget(parent.clearbufbtn,             6, 0, 1, 1)
    layout.addWidget(parent.wraptextbtn,             6, 2, 1, 2)
    layout.addWidget(parent.ttiplabeltxt,            7, 0, 1, 1)
    layout.addWidget(parent.ttipClickradio,          7, 1, 1, 1)
    layout.addWidget(parent.ttipHoverradio,          7, 2, 1, 1)
    layout.addWidget(parent.ttipalphalabeltxt,       7, 3, 1, 1)
    layout.addWidget(parent.ttipalpha_spinBox,       7, 4, 1, 1)

    layout.setRowStretch (0, 1)
    layout.setRowStretch (1 ,0)
    myGroupBox.setLayout(layout)
    mainLayout = QGridLayout()
    mainLayout.addWidget(myGroupBox,                       0, 0, 1, 3)
    mainLayout.addWidget(parent.resetlabeltxt,             1, 0, 1, 2)
    mainLayout.addWidget(parent.resetFactoryDefaultbtn,    1, 2, 1, 1)
    mainLayout.addWidget(parent.showphillabeltxt,          2, 0, 1, 2)
    mainLayout.addWidget(parent.showphilbtn,               2, 2, 1, 1)
    self.setLayout(mainLayout)
    self.setFixedSize( self.sizeHint() )


class WebEngineDebugForm(QDialog):
  def __init__(self, parent=None):
    super(WebEngineDebugForm, self).__init__(None,
                        Qt.WindowMinimizeButtonHint | # Want minimise and maximise buttons on window.
                        Qt.WindowMaximizeButtonHint | # As they are not the default for QDialog we
                        Qt.WindowCloseButtonHint |    # add them with flags at creation
                        Qt.CustomizeWindowHint |
                        Qt.WindowTitleHint |
                        Qt.WindowSystemMenuHint
                        )
    self.setWindowTitle("Chromium QWebEngineDebug")
    browser = QWebEngineView()
    mainLayout = QGridLayout()
    mainLayout.addWidget(browser, 0, 0)
    self.setLayout(mainLayout)
    webpage = QWebEnginePage( parent.webprofile, browser)
    browser.setPage(webpage)
    browser.page().setInspectedPage(parent.webpage )
    self.show()


class MyQMainWindow(QMainWindow):
  def __init__(self, parent):
    super(MyQMainWindow, self).__init__()
    self.parent = parent

  def closeEvent(self, event):
    self.parent.closeEvent(event)
    event.accept()


class MyQMainDialog(QDialog):
  def __init__(self, parent):
    super(MyQMainDialog, self).__init__()
    self.parent = parent

  def closeEvent(self, event):
    self.parent.closeEvent(event)
    event.accept()

"""
# hklviewer_gui.py should be generated from the Qtdesigner output file, HKLviewer4.ui, with the commandline:

"C:\\Program Files\\Python38\\Lib\\site-packages\\PySide2\\uic.exe" HKLviewer6.ui -o hklviewer_gui.py -g python

# Replace the autogenerated imports in hklviewer_gui.py with:

from .qt import QWebEngineView
try: # if invoked by cctbx.python or some such
  from crys3d.hklviewer.helpers import HeaderDataTableWidget, MyQDoubleSpinBox # implicit import
except Exception as e: # if invoked by a generic python that doesn't know cctbx modules
  from .helpers import HeaderDataTableWidget, MyQDoubleSpinBox # implicit import

from .qt import ( QCoreApplication, QMetaObject, QRect, QSize, Qt,  # implicit import
 QFont, QAbstractItemView, QAction, QCheckBox, QComboBox, QLineEdit, QDockWidget,
 QDoubleSpinBox, QFrame, QGridLayout, QGroupBox, QLabel, QPlainTextEdit,
 QPushButton, QRadioButton, QScrollArea, QSlider, QSplitter, QSizePolicy, QSpinBox,
 QTableWidget, QTabWidget, QTextEdit, QWidget, QIcon, QAbstractScrollArea, )

# For allowing embedding in ChimeraX comment out the line:

MainWindow.setCentralWidget(self.centralwidget)

from  the function hklviewer_gui.Ui_MainWindow.setupUi()

"""
timer = QTimer()

class NGL_HKLViewer(hklviewer_gui.Ui_MainWindow):
  # qversion() comes out like '5.12.5'. We just want '5.12'
  Qtversion = "Qt" + ".".join( QtCore.qVersion().split(".")[0:2])
  settings = QSettings("CCTBX", "HKLviewer" )
  reset_to_factorydefaults = False

  def __init__(self, thisapp, isembedded=False): #, cctbxpython=None):
    self.datatypedict = { }
    self.browserfontsize = None
    self.vectorwidth = None
    self.mousespeedscale = 2000
    self.isembedded = isembedded
    self.philfname = "" # for regression tests
    self.image_fname = "testimage.png"
    print("version " + self.Qtversion)
    self.colnames_select_dict = {}
    self.lasttime = time.monotonic()
    self.lastwaittime = time.monotonic()
    self.backgroundcolour = QColor(127,127,127)

    if isembedded:
      self.window = MyQMainDialog(self)
      self.window.hide()
    else:
      self.window = MyQMainWindow(self)
    self.setupUi(self.window)
    if isembedded: # in ChimeraX
      mainLayout = QGridLayout()
      mainLayout.addWidget(self.widget, 0, 0)
      self.window.setLayout(mainLayout)
    else:
      self.window.setCentralWidget(self.centralwidget)
      self.menubar = QMenuBar(self.window)
      self.menubar.setObjectName(u"menubar")
      self.menubar.setGeometry(QRect(0, 0, 1093, 22))
      self.menuFile = QMenu(self.menubar)
      self.menuFile.setObjectName(u"menuFile")
      self.menuHelp = QMenu(self.menubar)
      self.menuHelp.setObjectName(u"menuHelp")
      self.window.setMenuBar(self.menubar)
      self.statusBar = QStatusBar(self.window)
      self.statusBar.setObjectName(u"statusBar")
      self.window.setStatusBar(self.statusBar)
      self.menubar.addAction(self.menuFile.menuAction())
      self.menubar.addAction(self.menuHelp.menuAction())
      self.menuFile.addAction(self.actionOpen_reflection_file)
      self.menuFile.addAction(self.actionSave_reflection_file)
      self.menuFile.addAction(self.actionSettings)
      self.menuFile.addAction(self.actiondebug)
      self.menuFile.addAction(self.actionColour_Gradient)
      self.menuFile.addAction(self.actionBackground_Colour)
      self.menuFile.addAction(self.actionSave_Current_Image)
      self.menuFile.addAction(self.actionExit)
      self.menuHelp.addAction(self.actionLocal_Help)
      self.menuHelp.addAction(self.actionHKLviewer_Tutorial)
      self.menuHelp.addAction(self.actionCCTBXwebsite)
      self.menuHelp.addAction(self.actionNGLmousebindings)
      self.menuHelp.addAction(self.actionAbout)
      self.menuFile.setTitle(QCoreApplication.translate("MainWindow", u"File", None))
      self.menuHelp.setTitle(QCoreApplication.translate("MainWindow", u"Help", None))
    self.nsplitters = 0
    for a in dir(self):
      if isinstance( self.__getattribute__(a), QSplitter):
        self.nsplitters += 1
    self.ntabs = 0
    for a in dir(self):
      if isinstance( self.__getattribute__(a), QTabWidget):
        self.ntabs += 1
    self.factorydefaultfname = os.path.join(os.path.dirname(os.path.abspath(__file__)), "HKLviewerDefaults.ini")
    if not self.ReadPersistedQsettings():
      sys.exit()
    self.buttonsdeflist =[]
    self.app = thisapp
    self.cctbxversion = "unversioned"
    self.actiondebug.setVisible(False)
    self.UseOSBrowser = False
    self.devmode = False
    self.make_new_factory_default_settings = False
    self.XtricorderBtn.setVisible(False)
    self.XtriageBtn.setVisible(True)
    for e in sys.argv:
      if "UseOSBrowser" in e:
        self.UseOSBrowser = True
      if "devmode" in e:
        self.devmode = True
      if  "debug" in e or "devmode" in e:
        self.actiondebug.setVisible(True)
      if "new_factory_defaults" in e:
        self.make_new_factory_default_settings= True

    self.zmq_context = None
    self.unfeedback = False
    self.cctbxpythonversion = None
    self.mousespeed_labeltxt = QLabel()
    self.mousespeed_labeltxt.setText("Mouse speed:")
    self.mousemoveslider = QSlider(Qt.Horizontal)
    self.mousemoveslider.setMinimum(1)
    self.mousemoveslider.setMaximum(200)
    self.mousemoveslider.setValue(float(self.mousespeed)*self.mousespeedscale)
    self.mousemoveslider.sliderReleased.connect(self.onFinalMouseSensitivity)
    self.mousemoveslider.valueChanged.connect(self.onMouseSensitivity)
    self.mousesensitxtbox = QLineEdit('')
    self.mousesensitxtbox.setReadOnly(True)

    self.fontspinBox = MyQDoubleSpinBox()
    self.fontspinBox.setSingleStep(1)
    self.fontspinBox.setRange(4, 50)
    self.font = QFont()
    self.font.setFamily(self.font.defaultFamily())
    self.fontspinBox.setValue(self.font.pointSize())
    self.fontspinBox.editingFinished.connect(self.onFontsizeChanged)
    # valueChanged signal is buggy and gets triggered twice when onFontsizeChanged takes too long
    # This may cause font step=2 rather than step=1
    # Workaround is to use onMouseRelease invoked by MyQDoubleSpinBox.mouseReleaseEvent
    self.fontspinBox.onMouseRelease = self.onFontsizeChanged
    self.texttabfont = QFont("Courier New")
    self.texttabfont.setPointSize(self.font.pointSize())
    self.texttabfont.setBold(True)
    self.finddlg = FindDialog(self.tabText) # show near tabText when making finddlg visible
    self.textAlerts.finddlg = self.finddlg
    self.textInfo.finddlg = self.finddlg
    self.Fontsize_labeltxt = QLabel()
    self.Fontsize_labeltxt.setText("Font size:")
    self.waiting = False

    self.browserfontspinBox = QDoubleSpinBox()
    self.browserfontspinBox.setSingleStep(1)
    self.browserfontspinBox.setRange(4, 50)
    self.browserfontspinBox.setValue(self.font.pointSize())
    self.browserfontspinBox.valueChanged.connect(self.onBrowserFontsizeChanged)
    self.BrowserFontsize_labeltxt = QLabel()
    self.BrowserFontsize_labeltxt.setText("Browser font size:")

    self.vectorWidthspinBox = QSpinBox()
    self.vectorWidthspinBox.setSingleStep(1)
    self.vectorWidthspinBox.setRange(1, 30)
    self.vectorWidthspinBox.setValue(self.vectorwidth)
    self.vectorWidthspinBox.valueChanged.connect(self.onVectorWidthChanged)
    self.vectorWidth_labeltxt = QLabel()
    self.vectorWidth_labeltxt.setText("Thickness of vectors and axes:")

    self.cameraPerspectCheckBox = QCheckBox()
    self.cameraPerspectCheckBox.setText("Perspective camera")
    self.cameraPerspectCheckBox.clicked.connect(self.onCameraPerspect)
    self.cameraPerspectCheckBox.setCheckState(Qt.Unchecked)

    self.bufsizespinBox = QSpinBox()
    self.bufsizespinBox.setSingleStep(1)
    self.bufsizespinBox.setRange(1, 100)
    self.bufsizespinBox.setValue(int(self.textinfosize))
    self.bufsizespinBox.valueChanged.connect(self.onTextbufferSizeChanged)
    self.bufsize_labeltxt = QLabel()
    self.bufsize_labeltxt.setText("Text buffer size (Kbytes):")
    self.clearbufbtn = QPushButton()
    self.clearbufbtn.setText("Clear all text")
    self.clearbufbtn.clicked.connect(self.onClearTextBuffer)
    self.wraptextbtn = QCheckBox()
    self.wraptextbtn.setText("Word wrap text")
    self.wraptextbtn.clicked.connect(self.onWrapTextBuffer)
    self.wraptextbtn.setCheckState(Qt.Checked if self.wraptextinfo else Qt.Unchecked)
    self.ttiplabeltxt = QLabel()
    self.ttiplabeltxt.setText("Tooltips")
    self.ttipalphalabeltxt = QLabel()
    self.ttipalphalabeltxt.setText("Opacity:")
    self.ttipHoverradio = QRadioButton()
    self.ttipHoverradio.setText( "Hovering")
    self.ttipHoverradio.clicked.connect(self.onShowTooltips)
    self.ttipClickradio = QRadioButton()
    self.ttipClickradio.setText( "Clicked")
    self.ttipClickradio.clicked.connect(self.onShowTooltips)
    self.ttipalpha = 0.85
    self.ttipalpha_spinBox = QDoubleSpinBox()
    self.ttipalpha_spinBox.setSingleStep(0.05)
    self.ttipalpha_spinBox.setRange(0.0, 1.0)
    self.ttipalpha_spinBox.setValue(self.ttipalpha)
    self.ttipalpha_spinBox.valueChanged.connect(self.onTooltipAlphaChanged)
    self.ttipalpha_labeltxt = QLabel()
    self.ttipalpha_labeltxt.setText("Tooltip Opacity:")
    self.resetlabeltxt = QLabel()
    self.resetlabeltxt.setWordWrap(True)
    self.resetlabeltxt.setText("Delete user settings and revert to factory defaults for GUI, colour and radii scheme")
    self.resetFactoryDefaultbtn = QPushButton()
    self.resetFactoryDefaultbtn.setText("Reset Settings")
    self.resetFactoryDefaultbtn.clicked.connect(self.onResetFactoryDefault)
    self.showphillabeltxt = QLabel()
    self.showphillabeltxt.setWordWrap(True)
    self.showphillabeltxt.setText("Show current non-default phil parameters")
    self.showphilbtn = QPushButton()
    self.showphilbtn.setText("Show phil")
    self.showphilbtn.clicked.connect(self.onDebugShowPhil)
    # Set the rich text of the SpaceGrpUCellText here rather than in QtDesigner which on windows
    # include MS Font in it. MS Font are not understood by MacOS
    htmlstr = '''<html><head/><body><p><span style=" font-weight:600;">Space group: \t
    </span>P21 21 21<span style=" font-weight:600;"><br/>Unit cell(s): \t</span>(98.371, 98.371, 263.131, 90, 90, 120)</p></body></html> '''
    self.SpaceGrpUCellText.setText(htmlstr )
    self.ColourMapSelectDlg = MPLColourSchemes(self)
    self.select_millertable_column_dlg = MillerTableColumnHeaderDialog(self)
    self.ColourMapSelectDlg.setWindowTitle("HKLviewer Colour Gradient Maps")
    self.ColourMapSelectDlg.hide()
    # colour schemes and radii mapping for types of datasets stored in jsview_3d.py but persisted here:
    # colourmap=brg, colourpower=1, powerscale=1, radiiscale=1
    self.settingsform = SettingsForm(self)
    self.aboutform = AboutForm(self)
    self.webpagedebugform = None

    self.BgrndColourDlg = QColorDialog(self.window)
    self.BgrndColourDlg.setOption(QColorDialog.NoButtons)
    self.BgrndColourDlg.setWindowTitle("HKLviewer Background Colour")
    self.BgrndColourDlg.currentColorChanged.connect(self.onBackgroundColourChanged)

    self.MillerComboBox = QComboBox()
    self.MillerComboBox.activated.connect(self.onMillerComboSelchange)
    self.operationlabeltxt = QLabel()
    self.operationlabeltxt.setWordWrap(True)
    self.MillerLabel2 = QLabel()
    self.MillerLabel2.setText("is represented by array2")
    self.MillerLabel3 = QLabel()
    self.MillerLabel3.setText("""<html><head/><body><p>
    For examples on creating a dataset from existing ones see
    <a href="http://cci.lbl.gov/docs/cctbx/doc_hklviewer/#making-a-new-dataset">Making a new dataset</a>.
    <br>
    For details on python scripting cctbx.miller.array see
    <a href="https://cctbx.github.io/cctbx/cctbx.miller.html#the-miller-array">cctbx.miller arrays</a>.
    """)
    self.MillerLabel3.setTextInteractionFlags(Qt.TextBrowserInteraction);
    self.MillerLabel3.setOpenExternalLinks(True);

    self.newlabelLabel = QLabel()
    self.newlabelLabel.setText("Column label for new reflection dataset:")
    self.newlabeltxtbox = QLineEdit('')
    self.operationtxtbox = QTextEdit('')
    self.operationtxtbox.setAcceptRichText(False)
    self.operationtxtbox.setPlaceholderText("""Example:
dat = array1.data()/array1.sigmas() * array2.normalize().data()
sigs = 2*flex.exp(1/array2.sigmas())
newarray._data = dat
newarray._sigmas = sigs
    """)
    self.operationtxtbox.setToolTip(u"<html><head/><body><p>Rather than using math.exp(), math.pow(), etc. " +
                                  "use flex.exp(), flex.pow() etc when operating on flex.array variables.</p></body></html>")
    self.operationbutton = QPushButton("Compute new reflection dataset")
    self.operationbutton.clicked.connect(self.onMakeNewData)
    self.makenewdataform = MakeNewDataForm(self)
    self.makenewdataform.setModal(True)

    self.millerarraytable = MillerArrayTableView(self.window)
    self.millerarraytable.setSortingEnabled(False)
    self.millerarraytable.horizontalHeader().setDefaultAlignment(Qt.AlignLeft)
    self.millerarraytableform = MillerArrayTableForm(self)
    self.millerarraytablemodel = None
    self.millerarraytable.installEventFilter(self.millerarraytableform) # for keyboard copying to clipboard
    self.millerarraytable.setToolTip("Double-click the column and row of a reflection for the "+
                                     "viewer to zoom in on that.\nRight-click a reflection in " +
                                     "the viewer to locate its entry in this table.")

    self.createExpansionBox()
    self.createFileInfoBox()
    self.CreateSliceTabs()
    self.createRadiiScaleGroupBox()
    self.createBinsBox()
    self.CreateVectorsBox()
    self.functionTabWidget.setDisabled(True)

    self.cpath = ""
    if self.UseOSBrowser==False:
      self.InitBrowser()
    else:
      self.BrowserBox.setMaximumWidth(0)

    self.window.setWindowTitle("HKLviewer")
    self.cctbxproc = None
    self.LaunchCCTBXPython()
    self.out = None
    self.err = None
    self.comboviewwidth = 0
    self.currentphilstringdict = {}
    self.hklscenes_arrays = []
    self.millerarraylabels = []
    self.scenearraylabeltypes = []
    self.array_infotpls = []
    self.ano_spg_tpls = []
    self.colnames_select_lst = []
    self.currentmillarray_idx = None
    self.matching_arrays = []
    self.bin_infotpls = None
    self.bin_opacities= None
    self.nbins = 1
    self.lowerbinvals = []
    self.upperbinvals = []
    self.html_url = None
    self.spacegroups = {}
    self.info = []
    self.current_labels = None
    self.infostr = ""
    self.alertstr = ""
    self.fileisvalid = False
    self.currentfileName = None
    self.NewFileLoaded = False
    self.NewMillerArray = False
    self.NewHKLscenes = False
    self.binstableitemchanges = False
    self.canexit = False
    self.filterlst = ["MTZ Files (*.mtz)", "CIF Files (*.cif)", "HKL Files (*.hkl)",
                      "SCA Files (*.sca)", "All Files (*)"]
    self.ipresetbtn = -1
    self.isfirsttime = False
    self.closing = False
    self.indices = None
    self.datalst = []
    self.tabulate_miller_array = None
    self.binTableCheckState = None
    self.millertablemenu = QMenu(self.window)
    self.millertablemenu.triggered.connect(self.onMillerTableMenuAction)
    self.functionTabWidget.setDisabled(True)
    self.Statusbartxtbox = None
    self.chimeraxprocmsghandler = None
    self.chimeraxsession = None
    self.XtricorderBtn.clicked.connect(self.onXtricorderRun)
    self.XtriageBtn.clicked.connect(self.onXtriageRun)
    self.tabText.setCurrentIndex(0)
    self.tabText.currentChanged.connect( self.onTabtextChanged )
    if not isembedded:
      self.window.statusBar().showMessage("")
      self.hklLabel = QLabel()
      self.hklLabel.setText("X,Y,Z axes as HKL coordinates:")
      self.Statusbartxtbox = QLineEdit('')
      self.Statusbartxtbox.setReadOnly(True)
      self.Statusbartxtbox.setAlignment(Qt.AlignRight)
      self.window.statusBar().addPermanentWidget(self.hklLabel)
      self.window.statusBar().addPermanentWidget(self.Statusbartxtbox, 1)
      self.actionOpen_reflection_file.triggered.connect(self.onOpenReflectionFile)
      self.actionLocal_Help.triggered.connect(self.onOpenHelpFile)
      self.actionHKLviewer_Tutorial.triggered.connect(self.onOpenTutorialHelpFile)
      self.actionCCTBXwebsite.triggered.connect(self.onOpenCCTBXwebsite)
      self.actionNGLmousebindings.triggered.connect(self.onNGLmouseControlswebsite)
      self.actiondebug.triggered.connect(self.DebugInteractively)
      self.actionSave_Current_Image.triggered.connect(self.onSaveImage)
      self.actionSave_Current_Image.setDisabled(True)
      self.actionSettings.triggered.connect(self.SettingsDialog)
      self.actionAbout.triggered.connect(self.aboutform.show)
      self.actionExit.triggered.connect(self.window.close)
      self.actionSave_reflection_file.triggered.connect(self.onSaveReflectionFile)
      self.actionSave_reflection_file.setDisabled(True)
      self.actionColour_Gradient.triggered.connect(self.ColourMapSelectDlg.show)
      self.actionBackground_Colour.triggered.connect(self.BgrndColourDlg.show)
    else:
      self.tabText.setVisible(False) # stdout sent to chimeraX's console instead
    self.functionTabWidget.setCurrentIndex(0) # if accidentally set to a different tab in the Qtdesigner
    self.tabWidget.setCurrentIndex(0) # if accidentally set to a different tab in the Qtdesigner
    self.window.show()


  def onOpenHelpFile(self):
    QDesktopServices.openUrl(QUrl("https://cci.lbl.gov/docs/cctbx/doc_hklviewer/"))


  def onOpenTutorialHelpFile(self):
    QDesktopServices.openUrl(QUrl("https://cci.lbl.gov/docs/cctbx/tuto_hklviewer/"))


  def onOpenCCTBXwebsite(self):
    QDesktopServices.openUrl(QUrl("https://cci.lbl.gov/docs/cctbx/"))


  def onNGLmouseControlswebsite(self):
    QDesktopServices.openUrl(QUrl("https://nglviewer.org/ngl/api/manual/interaction-controls.html#controls"))


  def onPresetbtn_click(self):
    for i,((btnname, label, philstr), isenabled, datalabel, moniker_veclabels) in enumerate(self.buttonsdeflist):
      vectorscombobox = None
      #if moniker_veclabels:
      if moniker_veclabels is not None and moniker_veclabels[0] != "" and len(moniker_veclabels[1]):
        vectorscombobox = self.__getattribute__(btnname + "_vectors")
        vectorscombobox.setEnabled(False)
      if self.__getattribute__(btnname).isChecked():
        if vectorscombobox is not None:
          vectorscombobox.setEnabled(True)
          if vectorscombobox.currentIndex() > -1:
            currentvecname = vectorscombobox.currentText()
            philstr = re.sub(moniker_veclabels[0], currentvecname, philstr)
        self.send_message(philstr, msgtype = "preset_philstr")
        self.ipresetbtn = i
      else:
        if vectorscombobox is not None:
          vectorscombobox.setEnabled(False)


  def onVectorsComboSelchange(self, i):
    self.onPresetbtn_click()


  def closeEvent(self, event=QCloseEvent()): # provide default value when called explicitly below
    self.send_message('action = is_terminating')
    self.closing = True
    self.finddlg.setVisible(False)
    self.settingsform.setVisible(False)
    self.aboutform.setVisible(False)
    self.millerarraytableform.setVisible(False)
    self.ColourMapSelectDlg.setVisible(False)
    self.select_millertable_column_dlg.setVisible(False)
    self.ControlsWidget.setVisible(False)
    self.InfoWidget.setVisible(False)
    self.window.setVisible(False)
    self.BgrndColourDlg.close()

    if self.UseOSBrowser == False:
      self.webpage.deleteLater() # avoid "Release of profile requested but WebEnginePage still not deleted. Expect troubles !"
    print("HKLviewer closing down")
    nc = 0
    sleeptime = 0.2
    maxtime = 3
    while not self.canexit and nc < maxtime: # until cctbx.python has finished or after maxtime sec
      time.sleep(sleeptime)
      print(".", end='', flush=True)
      self.ProcessMessages()
      nc += sleeptime
    try:
      #self.cctbxproc.terminate()
      self.out, self.err = self.cctbxproc.communicate(input="exit()", timeout=maxtime)
      print(str(self.out) + "\n" + str(self.err))
    except Exception as e:
      print("\nExterminating unresponsive cctbx.python process, unconditionally, at will, with impunity, effective immediately!")
      import psutil
      parent_pid = self.cctbxproc.pid   # my example
      parent = psutil.Process(parent_pid)
      for child in parent.children(recursive=True):  # or parent.children() for recursive=False
        child.kill()
      parent.kill()
    if self.UseOSBrowser == False:
      if self.webpagedebugform and self.devmode:
        self.webpagedebugform.close()
        self.webpagedebugform.deleteLater()
      self.BrowserBox.close()
      self.BrowserBox.deleteLater()
    if not self.reset_to_factorydefaults:
      self.PersistQsettings()
    if not self.isembedded:
      event.accept()


  def InitBrowser(self):
    # omitting name for QWebEngineProfile() means it is private/off-the-record with no cache files
    self.webprofile = QWebEngineProfile(parent=self.BrowserBox)
    self.webpage = QWebEnginePage( self.webprofile, self.BrowserBox)
    if self.devmode:
      if hasattr(self.webpage, "setInspectedPage"): # older versions of Qt5 hasn't got chromium debug kit
        self.webpage.setUrl("chrome://gpu")
        self.webpagedebugform = WebEngineDebugForm(self)
        self.webpagedebugform.resize( self.window.size())
      else:
        self.webpage.setUrl("https://webglreport.com/")
    else:
      #self.webpage.setUrl("https://cctbx.github.io/")
      self.webpage.setUrl(QUrl("http://cci.lbl.gov/docs/cctbx/doc_hklviewer/"))
    self.cpath = self.webprofile.cachePath()
    self.BrowserBox.setPage(self.webpage)
    self.BrowserBox.setAttribute(Qt.WA_DeleteOnClose)


  def Browser_download_requested(self, download_item):
    options = QFileDialog.Options()
    fileName, filtr = QFileDialog.getSaveFileName(self.window,
            "Save screenshot to file", download_item.path(),
            "PNG Files (*.png);;All Files (*)", "", options)
    if fileName:
      download_item.setPath(fileName)
      download_item.accept()
      self.download_item = download_item
      download_item.finished.connect(self._download_finished)


  def _download_finished(self):
    file_path = self.download_item.path()
    print("File Downloaded to: %s" %file_path)


  def setWindowFilenameTitles(self, fname):
    self.window.setWindowTitle("HKLviewer: " + fname)
    self.ControlsWidget.setWindowTitle("HKLviewer Controls: " + fname)
    self.InfoWidget.setWindowTitle("HKLviewer Info: " + fname)
    self.current_labels = None
    self.textInfo.setPlainText("")
    self.textAlerts.setPlainText("")
    self.fileisvalid = False
    self.MillerComboBox.clear()
    self.millertable.clearContents()
    self.expandP1checkbox.setChecked(False)
    self.expandAnomalouscheckbox.setChecked(False)
    self.sysabsentcheckbox.setChecked(False)
    self.missingcheckbox.setChecked(False)
    self.onlymissingcheckbox.setChecked(False)


  def onOpenReflectionFile(self):
    options = QFileDialog.Options()
    self.currentfileName, filtr = QFileDialog.getOpenFileName(self.window,
            "Open a reflection file", "",
            ";;".join(self.filterlst), "", options)
    if self.openReflectionFile():
      # Rearrange filters to use the current filter as default for next time we open a file
      # The default filter is the first one. So promote the one chosen to be first in the list for next time
      idx = self.filterlst.index(filtr) # find its place in the list of filters
      self.filterlst.pop(idx ) # remove it from the list
      # make a new list with it as the first element
      newfilterlst = [filtr]
      newfilterlst.extend(self.filterlst)
      self.filterlst = newfilterlst


  def openReflectionFile(self):
    if self.currentfileName:
      self.setWindowFilenameTitles( self.currentfileName)
      self.send_message('openfilename = "%s"' %self.currentfileName )
      return True
    return False


  def onSaveReflectionFile(self):
    if len(self.millertable.selectedrows) ==0:
      QMessageBox.warning(self.window, "HKLviewer",
        "First highlight one or more datasets in the table of datasets on the details tab to save them as a new datafile", buttons=QMessageBox.Ok)
      return
    datasets2savestr = "', '".join([ self.millertable.item(i, 0).text() for i in self.millertable.selectedrows ] )
    options = QFileDialog.Options()
    fileName, filtr = QFileDialog.getSaveFileName(self.window,
            "Save datasets '%s' to a reflection file" %datasets2savestr, "",
            "MTZ Files (*.mtz);;CIF Files (*.cif);;All Files (*)", "", options)
    if fileName:
      self.send_message('''
savefilename = "%s"
datasets_to_save = %s'''
                        %(fileName, " ".join([ str(e) for e in self.millertable.selectedrows] ))
                        )


  def SettingsDialog(self):
    self.settingsform.show()
    # don't know why valueChanged.connect() method only takes effect from here on
    #self.fontspinBox.valueChanged.connect(self.onFontsizeChanged)
    self.settingsform.activateWindow()


  def onColourChartSelect(self, selcolmap, colourpowscale):
    # called when user clicks OK in helpers.MPLColourSchemes.EnactColourMapSelection()
    if selcolmap != "":
      self.send_message("""hkls.color_scheme = %s
hkls.color_powscale = %s""" %(selcolmap, colourpowscale) )


  def onBackgroundColourChanged(self, color):
    self.backgroundcolour = color
    pal = QPalette()
    pal.setColor(self.BrowserBox.backgroundRole(), self.backgroundcolour)
    self.BrowserBox.setPalette(pal)
    self.send_message("NGL.background_colour = 'rgb(%d, %d, %d)'" %(color.red(), color.green(), color.blue()) )


  def onSelect_millertable_column_dlg(self):
    """
    Dialog for choosing what columns of the miller table should be displayed
    Invoked by helpers.MyhorizontalHeader()
    """
    self.select_millertable_column_dlg.show()
    self.select_millertable_column_dlg.activateWindow()


  def SaveImage(self):
    self.send_message('save_image_name = "%s"' %self.image_fname)


  def SetFirstScene(self):
    self.send_message("viewer.scene_id = 0")


  def SetStateFromPHILfile(self):
    with open(self.philfname, "r") as f:
      self.AddAlertsText("Processing PHIL file: %s\n" %self.philfname)
      PHILstr = f.read()
      self.send_message(PHILstr, msgtype = "preset_philstr")


  def onXtricorderRun(self):
    if not self.currentfileName:
      QMessageBox.warning(self.window, "HKLviewer",
        "To run Xtricorder you must first open a datafile in the HKLviewer", buttons=QMessageBox.Ok)
      return
    if "_xtricorder.mtz" in self.currentfileName:
      self.AddInfoText("File looks like it has already been processed by Xtricorder. Try loading another reflection file.\n")
      return
    if "expanded" in self.currentfileName:
      self.AddInfoText("Datasets appear to have been expanded to a subgroup. Save these to a new file and load that to run Xtricorder\n")
      return
    self.XtricorderBtn.setEnabled(False)
    self.XtriageBtn.setEnabled(False)
    self.send_message("external_cmd = 'runXtricorder'" )
    self.AddInfoText("Running Xtricorder")
    self.AddAlertsText("Running Xtricorder")
    self.waiting = True


  def onXtriageRun(self):
    if not self.current_labels:
      QMessageBox.warning(self.window, "HKLviewer",
        "To run Xtriage you must first display an observation dataset", buttons=QMessageBox.Ok)
      return
    if "expanded" in self.currentfileName:
      self.AddInfoText("Datasets appear to have been expanded to a subgroup. Save these to a new file and load that to run Xtriage\n")
      return
    self.XtricorderBtn.setEnabled(False)
    self.XtriageBtn.setEnabled(False)
    self.send_message("external_cmd = 'runXtriage'" )
    self.AddInfoText("Running Xtriage")
    self.AddAlertsText("Running Xtriage")
    self.waiting = True


  def ProcessMessages(self):
    """
    Deal with the messages posted to this GUI by hklview_frame.HKLViewFrame.SendInfoToGUI()
    """
    if self.webpagedebugform is not None:
      try: # During shutdown this may fail if webpagedebugform exits before message handler terminates
        self.webpagedebugform.update()
      except Exception as e:
        pass
    if self.zmq_context:
      if self.cctbxproc.poll() is not None and not self.closing:
        print("Critical Error: CCTBX process has terminated. Please restart HKLviewer.", flush=True)
        timer.stop()
        self.closeEvent()

      if (time.monotonic() - 5) > self.lasttime: # send Isoldes clipper data every 5 sec
        self.lasttime = time.monotonic()
        if self.chimeraxsession is not None and self.chimeraxsession.HKLviewer is not None \
         and hasattr(self.chimeraxsession, "isolde"):
          self.chimeraxsession.HKLviewer.isolde_clipper_data_to_dict()
          self.send_message(str(self.chimeraxsession.HKLviewer.clipper_crystdict),
                            msgtype="clipper_crystdict")

      if self.waiting and (time.monotonic() - 0.5) > self.lastwaittime:
        self.lastwaittime = time.monotonic() # reassure the user we have not crashed
        self.AddInfoText(".")
        self.AddAlertsText(".")

      try:
        binmsg = self.socket.recv(flags=zmq.NOBLOCK) #To empty the socket from previous messages
        msg = zlib.decompress(binmsg)
        nan = float("nan") # workaround for "evaluating" any NaN or inf values in the messages received
        inf = math.inf

        msgstr = msg.decode()

        if "cctbx.python.version:" in msgstr:
          self.cctbxpythonversion = msgstr
          self.send_message("""NGL {
  fontsize = %s
  vector_width = %s
  show_tooltips = %s
}
""" %(self.browserfontsize, self.vectorwidth, self.ttip_click_invoke) )

          if self.cctbxpythonversion == 'cctbx.python.version: 2':
            # use NGL's download feature for images since websocket_server fails to handle large streams
            self.webpage.profile().downloadRequested.connect(self.Browser_download_requested)
          return
        self.infodict = eval(msgstr)
        if self.infodict:

          if self.infodict.get("AddXtricorderButton", False):
            self.XtricorderBtn.setVisible(True)

          if self.infodict.get("closing_time"): # notified by cctbx in regression tests
            QTimer.singleShot(10000, self.closeEvent )

          if self.infodict.get("current_phil_strings"):
            philstringdict = self.infodict.get("current_phil_strings", {})
            for unlikely_dict_keyname, val in philstringdict.items():
              try:
                self.currentphilstringdict[unlikely_dict_keyname] = eval(val)
              except Exception as e:
                self.currentphilstringdict[unlikely_dict_keyname] = val
            self.UpdateGUI()

          if self.infodict.get("copyrights"):
            self.copyrightpaths = self.infodict["copyrights"]
            txts = ""
            for copyrighttitle, fname in self.copyrightpaths:
              with open(fname,"r") as f:
                txts = txts + " "*20 + copyrighttitle + ":\n\n"
                txts = txts + f.read()
                txts = txts + "\n" + "#" * 50  + "\n"
            self.aboutform.copyrightstxt.setText(txts)
            self.aboutform.setFixedSize( self.aboutform.sizeHint() )
          if self.infodict.get("cctbxversion"):
            self.cctbxversion = self.infodict["cctbxversion"]
            self.aboutform.writeAboutstr( self.cctbxversion )

          if self.infodict.get("scene_array_label_types"):
            self.scenearraylabeltypes = self.infodict.get("scene_array_label_types", [])

          if self.infodict.get("array_infotpls", None) is not None:
            self.array_infotpls = self.infodict["array_infotpls"]
            self.millerarraylabels =  [e[1][0] for e in self.array_infotpls]
            self.make_new_millertable()

            self.MillerComboBox.clear()
            self.MillerComboBox.addItem("", userData=[-1, ""])
            for k,lbl in enumerate(self.millerarraylabels):
              self.MillerComboBox.addItem(lbl, userData= [k, self.scenearraylabeltypes[k][1]] )

            self.MillerComboBox.setCurrentIndex(0) # select the first item which is no miller array
            self.comboviewwidth = 0
            for e in self.millerarraylabels:
              self.comboviewwidth = max(self.comboviewwidth, self.MillerComboBox.fontMetrics().width( e) )
            self.MillerComboBox.view().setMinimumWidth(self.comboviewwidth)

          if self.infodict.get("show_log_file_from_external_cmd"):
            if self.infodict.get("show_log_file_from_external_cmd") != -42:
              tabname, fname = self.infodict.get("show_log_file_from_external_cmd")
              mstr = ""
              with open(fname, 'r') as f:
                mstr += f.read() + '\\n'
              self.add_another_text_tab(fname, mstr, os.path.abspath(fname))
            self.waiting = False
            self.XtricorderBtn.setEnabled(True)
            self.XtriageBtn.setEnabled(True)
            self.AddInfoText("\n")
            self.AddAlertsText("\n")

          if self.infodict.get("ano_spg_tpls"):
            # needed for determining if expansion checkbox for P1 and friedel are enabled or disabled
            self.ano_spg_tpls = self.infodict.get("ano_spg_tpls",[])

          if self.infodict.get("current_labels", None) is not None:
            # needed in case we run xtriage on this miller array
            self.current_labels = self.infodict.get("current_labels")

          if self.infodict.get("colnames_select_lst", None) is not None:
            self.colnames_select_lst = self.infodict["colnames_select_lst"]
            self.select_millertable_column_dlg.make_new_selection_table()

          if self.infodict.get("bin_infotpls"):
            self.bin_infotpls = self.infodict["bin_infotpls"]

            self.nbins = len(self.bin_infotpls)
            self.binstable.clearContents()
            self.binstable.setRowCount(self.nbins)
            self.lowerbinvals = []
            self.upperbinvals = []
            self.binstable_isready = False
            for row,bin_infotpl in enumerate(self.bin_infotpls):
              for col,elm in enumerate(bin_infotpl):
                # only allow changing the last column with opacity values
                if col == 0:
                  item = QTableWidgetItem(str(elm))
                  item.setFlags(item.flags() ^ Qt.ItemIsEditable)
                if col==1:
                  self.lowerbinvals.append(elm)
                if col==2:
                  item = QTableWidgetItem(str(elm))
                  item.setFlags(item.flags() ^ Qt.ItemIsEditable)
                  self.upperbinvals.append(elm)
                if col == 1: # allow changing bin thresholds
                  item = QTableWidgetItem(str(elm))
                  item.setFlags(item.flags() | Qt.ItemIsEditable)
                  item.setToolTip("Change a bin threshold by entering a preferred value in the " +
                                  "\"lower bin value\" column for a particular bin.")
                if col == 3:
                  item = QTableWidgetItem()
                  item.setFlags(Qt.ItemIsUserCheckable | Qt.ItemIsEnabled)
                  item.setCheckState(Qt.Checked)
                  item.setToolTip("Change visibility of bins either by ticking or unticking the check " +
                                  "boxes or by entering opacity values between 0 and 1. Reflections with "+
                                  "values less than 0.3 will not respond to mouse clicks.")
                self.binstable.setItem(row, col, item)
            self.binstable_isready = True
            if self.bin_opacities:
              self.update_table_opacities()

          if self.infodict.get("bin_opacity"):
            self.bin_opacities = self.infodict["bin_opacity"]
            if self.binstable.rowCount() > 0:
              self.update_table_opacities()

          if self.infodict.get("html_url") and self.html_url is None:
            self.html_url = self.infodict["html_url"]
            if self.UseOSBrowser==False:
              self.BrowserBox.setUrl(QUrl(self.html_url))
              # workaround for background colour bug in chromium
              # https://bugreports.qt.io/browse/QTBUG-41960
              self.BrowserBox.page().setBackgroundColor(QColor(127, 127, 127, 1) )
              pal = QPalette()
              self.BrowserBox.setAutoFillBackground(True)
              pal.setColor(self.BrowserBox.backgroundRole(), self.backgroundcolour)
              self.BrowserBox.setPalette(pal)
              self.send_message("Loading %s in QwebEngine" %self.html_url, msgtype="debug_info")

          if self.infodict.get("spacegroups"):
            spgs = self.infodict.get("spacegroups",[])
            self.spacegroups = { i : e for i,e in enumerate(spgs) }
            self.SpaceGroupComboBox.clear()
            self.SpaceGroupComboBox.addItems( list(self.spacegroups.values()) )

          currentinfostr = ""
          if self.infodict.get("info"):
            currentinfostr = self.infodict.get("info","")
            if "Destroying HKLViewFrame" in currentinfostr:
              self.canexit = True

          currentalertstr = ""
          if self.infodict.get("alert") or self.infodict.get("info"):
            currentalertstr = self.infodict.get("alert","") + self.infodict.get("info","")
            if self.closing: # Qt GUI has gone so print oending strings to the shell
              print(currentalertstr)

          if self.infodict.get("tabulate_miller_array"):
            currentinfostr = "Received table data\n"
            self.tabulate_miller_array = self.infodict["tabulate_miller_array"]
            self.indices = self.tabulate_miller_array[0]
            #labels = ["H", "K", "L"] + [ ld[0] for ld in self.tabulate_miller_array[1:] ]
            labels = [ ld[0] for ld in self.tabulate_miller_array ]
            self.datalst =  [ ld[1] for ld in self.tabulate_miller_array ]

            if self.millerarraytable.model():
              self.millerarraytable.model().clear()
            self.millerarraytablemodel = MillerArrayTableModel(self.datalst, labels, self)
            self.millerarraytable.setModel(self.millerarraytablemodel)
            self.millerarraytable.horizontalHeader().setHighlightSections(False)
            self.millerarraytable.setSortingEnabled(False)

            self.millerarraytable_sortorder = ["unsorted"] * (len(self.datalst) + 3)
            self.millerarraytable.resizeColumnsToContents()
            self.millerarraytableform.layout.setRowStretch (0, 0)
            self.millerarraytableform.mainLayout.setRowStretch (0, 0)
            tablewidth = 0
            for e in range(self.millerarraytablemodel.columnCount()):
              tablewidth +=  self.millerarraytable.columnWidth(e)
            self.millerarraytable.resizeColumnsToContents()

            self.millerarraytableform.SortComboBox.clear()
            self.millerarraytableform.SortComboBox.addItems(["unsorted"] + labels )
            self.millerarraytableform.SortComboBox.view().setMinimumWidth(self.comboviewwidth)
            self.millerarraytableform.resize(tablewidth, self.millerarraytable.rowHeight(0)*15)
            self.millerarraytableform.show()
            self.millerarraytableform.activateWindow()

          self.unfeedback = True
          if self.infodict.get("all_vectors") is not None:
            self.rotvec = None
            self.all_vectors = self.infodict.get("all_vectors",[])

            self.clipplane_normal_vector_combo.clear()
            self.vectortable2.clearContents()
            self.vectortable2.setRowCount(len(self.all_vectors)+1)
            cw = 0
            for row, (opnr, label, order, cartvec, hklop, hkls, abcs, length) in enumerate(self.all_vectors):
              for col,elm in enumerate((label, hklop, hkls, abcs)):
                item = QTableWidgetItem(str(elm))
                if col == 0:
                  item.setFlags((Qt.ItemIsUserCheckable | Qt.ItemIsEnabled) ^ Qt.ItemIsEditable)
                  item.setCheckState(Qt.Unchecked)
                  item.setData(Qt.UserRole, opnr)
                item.setFlags(item.flags() ^ Qt.ItemIsEditable)
                self.vectortable2.setItem(row, col, item)
              self.clipplane_normal_vector_combo.addItem(label, userData=length)
              cw = max(cw, self.clipplane_normal_vector_combo.fontMetrics().width( label) )
            self.clipplane_normal_vector_combo.view().setMinimumWidth(cw)

            rc = self.vectortable2.rowCount()-1 # last row is for user defined vector
            item = QTableWidgetItem("new vector")
            item.setFlags((Qt.ItemIsUserCheckable | Qt.ItemIsEnabled) ^ Qt.ItemIsEditable)
            item.setCheckState(Qt.Unchecked)
            self.vectortable2.setItem(rc, 0, item)

            item = QTableWidgetItem()
            item.setFlags(item.flags() | Qt.ItemIsEditable)
            self.vectortable2.setItem(rc, 1, item)

            item = QTableWidgetItem()
            item.setFlags(item.flags() | Qt.ItemIsEditable)
            self.vectortable2.setItem(rc, 2, item)

            item = QTableWidgetItem()
            item.setFlags(item.flags() | Qt.ItemIsEditable)
            self.vectortable2.setItem(rc, 3, item)
            self.vectortable2.resizeColumnsToContents()
          self.unfeedback = False
          if self.infodict.get("file_name"):
            self.currentfileName = self.infodict.get("file_name", "")
            self.setWindowFilenameTitles( self.currentfileName)
            for tabname in ["xtricorder.log",  "xtriage.log"]:
              self.removeNamedTab(tabname)

          if self.infodict.get("NewFileLoaded"):
            self.NewFileLoaded = self.infodict.get("NewFileLoaded",False)
            self.currentmillarray_idx = None
            self.vectortable2.clearContents()
            self.ShowAllVectorsBtn.setCheckState(Qt.Unchecked)
            self.functionTabWidget.setDisabled(True)
            self.AlignVectorGroupBox.setChecked( False)
            for tabname in ["xtricorder.log",  "xtriage.log"]:
              self.removeNamedTab(tabname)
            # display only those miller table columns that have been persisted if any
            stored_colnames_select_lst = []
            current_philstr = "selected_info {\n"
            for philname, caption, value in self.colnames_select_lst:
              is_selected = value
              if self.colnames_select_dict.get(philname, -42) != -42:
                is_selected = bool(self.colnames_select_dict[philname])
              stored_colnames_select_lst.append( (philname, caption, is_selected) )
              current_philstr += "  %s = %s\n" %(philname, is_selected)
            current_philstr += "}\n"
            self.send_message(current_philstr)
            self.colnames_select_lst = stored_colnames_select_lst
            self.select_millertable_column_dlg.make_new_selection_table()
    # Notify CCTBX that GUI has been initiated and it can now process messages.
    # This is critical as it releases a waiting semaphore in CCTBX
            self.send_message("", msgtype="initiated_gui")

          if self.infodict.get("NewHKLscenes"):
            self.NewHKLscenes = self.infodict.get("NewHKLscenes",False)

          if self.infodict.get("NewMillerArray"):
            self.NewMillerArray = self.infodict.get("NewMillerArray",False)

          if self.infodict.get("StatusBar") and self.Statusbartxtbox is not None:
            self.Statusbartxtbox.setText(self.infodict.get("StatusBar", "") )

          if self.infodict.get("include_tooltip_lst"):
            self.include_tooltip_lst = self.infodict.get("include_tooltip_lst", [])

          if self.infodict.get("clicked_HKL"):
            (h,k,l) = self.infodict.get("clicked_HKL", ( ) )
          if self.infodict.get("orig_hkl_ids"):
            if self.millerarraytablemodel is not None and self.millerarraytable.isVisible() :
              if self.millerarraytableform.SortComboBox.currentIndex() == 0:
                # can only match hkls in the unsorted table
                orig_hkl_ids = self.infodict.get("orig_hkl_ids", [])
                mode = QItemSelectionModel.Select | QItemSelectionModel.Rows
                self.millerarraytable.activateWindow()
                self.millerarraytable.setFocus()
                for ids in orig_hkl_ids:
                  self.millerarraytable.selectRow(ids)
              else:
                self.AddInfoText("Un-sort the table in order to highlight data corresponding " \
                  "to reflection that was clicked by the mouse.\n")

          if self.infodict.get("ColourChart") and self.infodict.get("ColourPowerScale"):
            self.ColourMapSelectDlg.selcolmap = self.infodict.get("ColourChart", "brg")
            self.ColourMapSelectDlg.setPowerScaleSliderVal( self.infodict.get("ColourPowerScale", 1.0))
            if self.infodict.get("ShowColourMapDialog"):
              self.ColourMapSelectDlg.show()
              self.ColourMapSelectDlg.activateWindow()

          if self.infodict.get("CurrentDatatype"):
            # sent by jsview_3d.HKLview_3d.DrawNGLJavaScript() once reflection have been rendered
            self.ColourMapSelectDlg.setDataType(self.infodict.get("CurrentDatatype", ""))
            self.actionSave_Current_Image.setDisabled(False)

          if self.infodict.get("bin_labels_type_idxs"):
            bin_labels_type_idxs = self.infodict.get("bin_labels_type_idxs",False)
            self.BinDataComboBox.clear()
            # fill combobox with labels of data that can be used for binning
            for label,labeltype,idx in bin_labels_type_idxs:
              self.BinDataComboBox.addItem(label, (labeltype, idx) )
            self.BinDataComboBox.view().setMinimumWidth(self.comboviewwidth)

          if self.infodict.get("binner_idx"):
            self.BinDataComboBox.setCurrentIndex(self.infodict.get("binner_idx", 0))

          if self.infodict.get("used_nth_power_scale_radii", None) is not None:
            self.unfeedback = True
            self.power_scale_spinBox.setValue( self.infodict.get("used_nth_power_scale_radii", 0.0))
            self.unfeedback = False

          if self.infodict.get("datatype_dict"):
            self.datatypedict = self.infodict.get("datatype_dict", {} )

          if self.infodict.get("enable_disable_preset_buttons"):
            newlist = eval(self.infodict.get("enable_disable_preset_buttons", "[]" ))
            if newlist != self.buttonsdeflist:
              self.buttonsdeflist = newlist

              for i in reversed(range(self.gridLayout_24.count())):
                # first delete any previous widgets from last time a file was loaded
                widgetToRemove = self.gridLayout_24.itemAt(i).widget()
                self.gridLayout_24.removeWidget(widgetToRemove)
                widgetToRemove.setParent(None)
              # programmatically create preset buttons on the self.gridLayout_24 from the QtDesigner
              for i,((btnname, label, _), datalabel, tooltip, moniker_veclabels) in enumerate(self.buttonsdeflist):
                moniker = ""
                veclabels = []
                if moniker_veclabels:
                  (moniker, veclabels) = moniker_veclabels
                self.__dict__[btnname] = QRadioButton(self.PresetButtonsFrame)
                pbutton = self.__getattribute__(btnname)
                pbutton.setObjectName(btnname)
                # since QRadioButton cannot wrap text the text for pbutton goes in
                # btnlabel below which is a QLabel where text can be wrapped if needed
                pbutton.setText("")
                pbutton.setToolTip(tooltip)
                pbutton.clicked.connect(self.onPresetbtn_click)
                sizePolicy1 = QSizePolicy(QSizePolicy.Minimum, QSizePolicy.Fixed)
                sizePolicy1.setHorizontalStretch(0)
                sizePolicy1.setVerticalStretch(0)
                sizePolicy1.setHeightForWidth(pbutton.sizePolicy().hasHeightForWidth())
                pbutton.setSizePolicy(sizePolicy1)
                self.gridLayout_24.addWidget(pbutton, i, 0, 1, 1)
                btnlabel = QLabel(self.widget)
                sizePolicy2 = QSizePolicy(QSizePolicy.Preferred, QSizePolicy.Preferred)
                sizePolicy2.setHorizontalStretch(1)
                sizePolicy2.setVerticalStretch(1)
                sizePolicy2.setHeightForWidth(btnlabel.sizePolicy().hasHeightForWidth())
                btnlabel.setSizePolicy(sizePolicy2)
                btnlabel.setWordWrap(True)
                btnlabel.setToolTip(tooltip)
                btnlabel.setText(label + " (using " + datalabel + ")")
                self.gridLayout_24.addWidget(btnlabel, i, 1, 1, 1)

                if moniker != "" and len(veclabels):
                  comboboxname = btnname + "_vectors"
                  self.__dict__[comboboxname] = QComboBox(self.PresetButtonsFrame)
                  vectorscombobox = self.__getattribute__(comboboxname)
                  vectorscombobox.addItems( veclabels )
                  vectorscombobox.activated.connect(self.onVectorsComboSelchange)
                  self.gridLayout_24.addWidget(vectorscombobox, i, 2, 1, 1)

                if self.ipresetbtn == i:
                  pbutton.setChecked(True)

          if self.infodict.get("spacegroup_info"):
            spacegroup_info = self.infodict.get("spacegroup_info",False)
            unitcell_info = self.infodict.get("unitcell_info",False)
            htmlstr = '''<html><head/><body><p><span style=" font-weight:600;">Space group: \t
            </span>%s<span style=" font-weight:600;"><br/>Unit cell(s): \t</span>%s</p></body></html> '''
            self.SpaceGrpUCellText.setText(htmlstr %(spacegroup_info, "<br/>".join(unitcell_info)) )
          self.fileisvalid = True

          if currentinfostr:
            self.AddInfoText(currentinfostr)

          if currentalertstr:
            self.AddAlertsText(currentalertstr)

          if (self.NewFileLoaded or self.NewMillerArray) or self.NewHKLscenes:
            self.NewMillerArray = False
            if self.millerarraytablemodel:
              self.millerarraytablemodel.clear()
              self.millerarraytablemodel = MillerArrayTableModel([[]], [], self)

            self.make_new_millertable()
            #self.UsePersistedQsettings
            self.NewFileLoaded = False
            self.actionSave_reflection_file.setDisabled(False)

          if self.NewHKLscenes:
            self.NewHKLscenes = False

      except Exception as e:
        errmsg = str(e)
        if "Resource temporarily unavailable" not in errmsg: # ignore errors from no connection to ZMQ socket
          print( errmsg  +  traceback.format_exc(limit=10) )


  def tabTextScrollDownShow(self, textbox):
    # If tab is not the current one shown scroling down to the bottom of the textbox is exceeded by one pagestep
    # So subtract a pagestep from the scroll value (and then some) to display the latest addition to the text output
    textbox.verticalScrollBar().setValue( textbox.verticalScrollBar().maximum() - (textbox.verticalScrollBar().pageStep()-2) )
    ctextbox = self.tabText.widget( self.tabText.currentIndex() ).children()[1]
    ctextbox.verticalScrollBar().setValue( ctextbox.verticalScrollBar().maximum()  )


  def onTabtextChanged(self, i):
    self.finddlg.hide() # if it is present from a recent string search


  def AddInfoText(self, currentinfostr):
    if self.isembedded:
      print(currentinfostr)
    else:
      self.infostr += currentinfostr
      # display no more than self.bufsize Kbytes of text
      self.infostr = self.infostr[-1000*self.textinfosize:]
      self.textInfo.setPlainText(self.infostr)
      self.tabTextScrollDownShow(self.textInfo)


  def AddAlertsText(self, currentalertstr):
    if self.isembedded:
      print(currentalertstr)
    else:
      self.alertstr += currentalertstr
      # display no more than self.bufsize Kbytes of text
      self.alertstr = self.alertstr[-1000*self.textinfosize:]
      self.textAlerts.setPlainText(self.alertstr)
      self.tabTextScrollDownShow(self.textAlerts)


  def removeNamedTab(self, tabsubstr):
    for n in range(self.tabText.count()):
      tabname = self.tabText.tabText(n)
      if tabsubstr in tabname:
        self.tabText.removeTab( self.tabText.indexOf(self.__dict__[tabname]) )
        self.__dict__[tabname].setParent(None)


  def add_another_text_tab(self, tabname, mstr, ttip):
    self.removeNamedTab(tabname)
    self.__dict__[tabname] = QWidget()
    gridLayout = QGridLayout(self.__dict__[tabname])
    gridLayout.setSpacing(4)
    gridLayout.setContentsMargins(3, 3, 3, 3)
    gridLayout.setContentsMargins(0, 0, 0, 0)
    newtabedit = MyQPlainTextEdit(self.__dict__[tabname])
    sp = QSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
    sp.setHeightForWidth(newtabedit.sizePolicy().hasHeightForWidth())
    newtabedit.setSizePolicy(sp)
    newtabedit.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOn)
    newtabedit.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOn)
    newtabedit.setSizeAdjustPolicy(QAbstractScrollArea.AdjustToContents)
    newtabedit.setLineWrapMode(QPlainTextEdit.NoWrap)
    newtabedit.setReadOnly(True)
    newtabedit.setPlainText(mstr)
    newtabedit.setFont(self.texttabfont)
    newtabedit.finddlg = self.finddlg
    gridLayout.addWidget(newtabedit, 0, 0, 1, 1)
    self.tabText.addTab(self.__dict__[tabname], tabname)
    idx = self.tabText.indexOf(self.__dict__[tabname])
    self.tabText.setCurrentIndex( idx )
    self.tabText.setTabToolTip(idx, ttip)


  def make_new_millertable(self):
    self.millertable.clearContents()
    if len(self.array_infotpls) == 0:
      return
    self.millertable.setRowCount(len(self.array_infotpls))
    labels = [ e.strip("|").strip() for e in self.array_infotpls[0][0] ]
    self.millertable.setColumnCount(len(labels))
    self.millertable.setHorizontalHeaderLabels(labels)
    self.millertable.horizontalHeader().setDefaultAlignment(Qt.AlignLeft)
    for row,(headerlst,infotpls,fmtstrtpls,fmtstr2tpls) in enumerate(self.array_infotpls):
      for col,elm in enumerate(infotpls):
        self.millertable.setItem(row, col, QTableWidgetItem(fmtstrtpls[col].format(elm)))


  def UpdateGUI(self):
    self.unfeedback = True
    self.ManualPowerScalecheckbox.setChecked( math.isnan( self.currentphilstringdict['hkls.nth_power_scale_radii'] )==False )
    self.power_scale_spinBox.setEnabled( self.ManualPowerScalecheckbox.isChecked() )
    self.radii_scale_spinBox.setValue( self.currentphilstringdict['hkls.scale'])
    self.expandP1checkbox.setChecked( self.currentphilstringdict['hkls.expand_to_p1'])
    self.expandAnomalouscheckbox.setChecked( self.currentphilstringdict['hkls.expand_anomalous'])
    self.ExpandReflsGroupBox.setChecked(self.expandP1checkbox.isChecked() or self.expandAnomalouscheckbox.isChecked())
    self.sysabsentcheckbox.setChecked( self.currentphilstringdict['hkls.show_systematic_absences'])
    self.ttipalpha_spinBox.setValue( self.currentphilstringdict['NGL.tooltip_alpha'])
    self.mousemoveslider.setValue( self.mousespeedscale*self.currentphilstringdict['NGL.mouse_sensitivity'])
    if self.currentphilstringdict['viewer.angle_around_vector'] is not None:
      self.rotvec, dgr = self.currentphilstringdict['viewer.angle_around_vector']
      self.rotavecangle_labeltxt.setText("Reflections rotated around Vector with Angle: %3.1fº" %dgr)

    self.ColourMapSelectDlg.selcolmap = self.currentphilstringdict["hkls.color_scheme"]
    self.ColourMapSelectDlg.setPowerScaleSliderVal( self.currentphilstringdict["hkls.color_powscale"] )

    self.Nbins_spinBox.setValue( self.currentphilstringdict['binning.nbins'])
    if self.currentphilstringdict['spacegroup_choice'] is not None:
      self.SpaceGroupComboBox.setCurrentIndex(  self.currentphilstringdict['spacegroup_choice'] )
    #self.clipParallelBtn.setChecked( self.currentphilstringdict['clip_plane.is_parallel'])
    self.missingcheckbox.setChecked( self.currentphilstringdict['hkls.show_missing'])
    self.onlymissingcheckbox.setEnabled( self.currentphilstringdict['hkls.show_missing'] )
    if self.currentphilstringdict['viewer.scene_id'] is not None:
      self.functionTabWidget.setEnabled(True)
    self.cameraPerspectCheckBox.setChecked( "perspective" in self.currentphilstringdict['NGL.camera_type'])
    if self.currentphilstringdict['clip_plane.clip_width']:
      self.clipwidth_spinBox.setValue( self.currentphilstringdict['clip_plane.clip_width'])
    self.hkldist_spinBox.setValue( self.currentphilstringdict['clip_plane.hkldist'])
    if self.currentphilstringdict['viewer.fixorientation'] == "vector":
      self.AlignVectorGroupBox.setChecked( True)
      self.RotateAroundframe.setEnabled(True)
    else:
      self.AlignVectorGroupBox.setChecked( False)
    self.onlymissingcheckbox.setChecked( self.currentphilstringdict['hkls.show_only_missing'])

    self.DrawRealUnitCellBox.setChecked(self.currentphilstringdict['draw_real_space_unit_cell'])
    self.unitcellslider.setValue( self.currentphilstringdict['real_space_unit_cell_scale_fraction'] * self.unitcellslider.maximum())
    self.DrawReciprocUnitCellBox.setChecked(self.currentphilstringdict['draw_reciprocal_unit_cell'])
    self.reciprocunitcellslider.setValue( self.currentphilstringdict['reciprocal_unit_cell_scale_fraction'] * self.reciprocunitcellslider.maximum())

    if self.currentphilstringdict['viewer.animate_rotation_around_vector'] is not None:
      self.rotvec,speed = self.currentphilstringdict['viewer.animate_rotation_around_vector']
      self.AnimaRotCheckBox.setChecked( speed > 0 )

    self.ClipPlaneChkGroupBox.setChecked(self.currentphilstringdict['clip_plane.clip_width'] != None)
    self.AutoClipWidthCheckBox.setChecked(self.currentphilstringdict['clip_plane.auto_clip_width'] == True)
    self.clipwidth_spinBox.setDisabled(self.AutoClipWidthCheckBox.isChecked() )

    lbl = self.currentphilstringdict['clip_plane.normal_vector']
    idx = -1
    if len(self.all_vectors) > 0:
      for i,(opnr,label,order,cartvec,hklop,hkls,abcs,length) in enumerate(self.all_vectors):
        if lbl == label:
          idx = i
          break
      opnr,label,order,cartvec,hklop,hkls,abcs,length = self.all_vectors[idx]
      if hkls == "" or not self.ClipPlaneChkGroupBox.isChecked():
        self.normal_realspace_vec_btn.setEnabled(False)
        self.normal_realspace_vec_label.setEnabled(False)
      else:
        self.normal_realspace_vec_btn.setEnabled(True)
        self.normal_realspace_vec_label.setEnabled(True)

    if self.currentphilstringdict['viewer.fixorientation'] is not None:
      self.parallel_current_orientation_btn.setChecked( "None" in self.currentphilstringdict['viewer.fixorientation'] \
         or self.currentphilstringdict['viewer.is_parallel'] )
      self.normal_vec_btn.setChecked( "vector" in self.currentphilstringdict['viewer.fixorientation'] and \
        not self.currentphilstringdict['viewer.is_parallel'] and \
        not self.currentphilstringdict['clip_plane.is_assoc_real_space_vector'])
      self.normal_realspace_vec_btn.setChecked( "vector" in self.currentphilstringdict['viewer.fixorientation'] and \
        not self.currentphilstringdict['viewer.is_parallel'] and \
        self.currentphilstringdict['clip_plane.is_assoc_real_space_vector'])

      self.clipplane_normal_vector_combo.setCurrentIndex(idx )
      if isinstance(self.clipplane_normal_vector_combo.currentData(), float) or isinstance(self.clipplane_normal_vector_combo.currentData(), int):
        self.clipplane_normal_vector_length.setText("{:.6g}".format(self.clipplane_normal_vector_combo.currentData()))

    for i in range(self.vectortable2.rowCount()):
      try: # checkboxes are not present first time gui is started
        self.vectortable2.item(i, 0).setCheckState(Qt.Unchecked)
      except Exception as e:
        pass

    if self.currentphilstringdict['viewer.show_vector'] is not None:
      ivecs = self.currentphilstringdict['viewer.show_vector']
      for ivec in ivecs:
        try: # checkboxes are not present first time gui is started
          [i,b] = eval(ivec)
          if i < self.vectortable2.rowCount():
            if b:
              self.vectortable2.item(i, 0).setCheckState(Qt.Checked)
            else:
              self.vectortable2.item(i, 0).setCheckState(Qt.Unchecked)
        except Exception as e:
          pass

    if self.currentphilstringdict['viewer.show_all_vectors'] is not None:
      show_all_vectors = self.currentphilstringdict['viewer.show_all_vectors']
      for rvrow in range(self.vectortable2.rowCount()):
        if self.vectortable2.item(rvrow, 0) is not None:
          if show_all_vectors == 1:
            self.vectortable2.item(rvrow, 0).setCheckState(Qt.Checked)
          if show_all_vectors == -1:
            self.vectortable2.item(rvrow, 0).setCheckState(Qt.Unchecked)

    if self.currentphilstringdict.get('viewer.user_vector', None) is not None:
      self.user_vectors = self.currentphilstringdict['viewer.user_vector']

    self.unfeedback = False



  def onSortComboBoxSelchange(self, i):
    if i==0: # i.e. unsorted
      labels = [ ld[0] for ld in self.tabulate_miller_array ]
      self.datalst =  [ ld[1] for ld in self.tabulate_miller_array ]
      if self.millerarraytable.model():
        self.millerarraytable.model().clear()
      self.millerarraytablemodel = MillerArrayTableModel(self.datalst, labels, self)
      self.millerarraytable.setModel(self.millerarraytablemodel)
      self.millerarraytable.resizeColumnsToContents()
      return
    idx = i-1
    if type(self.millerarraytablemodel._data[0][idx]) is str:
      print("Cannot sort this column.")
      return
    if self.millerarraytableform.sortChkbox.checkState() == Qt.Unchecked:
      self.millerarraytable.sortByColumn(idx, Qt.SortOrder.DescendingOrder)
    else:
      self.millerarraytable.sortByColumn(idx, Qt.SortOrder.AscendingOrder)
    self.millerarraytable.resizeColumnsToContents()


  def onSortChkbox(self):
    self.onSortComboBoxSelchange(self.millerarraytableform.SortComboBox.currentIndex() )


  def onPrecisionChanged(self, val):
    self.millerarraytablemodel.precision = val
    self.millerarraytable.resizeColumnsToContents()


  def onTextbufferSizeChanged(self,val):
    if self.unfeedback:
      return
    self.textinfosize = val


  def onFinalMouseSensitivity(self):
    self.mousespeed = self.mousemoveslider.value()/self.mousespeedscale
    self.send_message('NGL.mouse_sensitivity = "%2.3f"' %self.mousespeed)


  def onMouseSensitivity(self):
    self.mousespeed = self.mousemoveslider.value()/self.mousespeedscale
    self.mousesensitxtbox.setText("%2.1f" %(self.mousemoveslider.value()*10.0/self.mousemoveslider.maximum()) )


  def onTooltipAlphaChanged(self, val):
    if self.unfeedback:
      return
    self.ttipalpha = val
    self.send_message('NGL.tooltip_alpha = %f' %val)


  def onShowTooltips(self, val):
    if self.ttipClickradio.isChecked() or val=="click":
      self.send_message("NGL.show_tooltips = click")
      self.ttip_click_invoke = "click"
    if self.ttipHoverradio.isChecked() or val=="hover":
      self.send_message("NGL.show_tooltips = hover")
      self.ttip_click_invoke = "hover"


  def onFontsizeChanged(self):
    val = self.fontspinBox.value()
    font = self.app.font()
    font.setPointSize(val)
    self.fontsize = val
    self.app.setFont(font)
    self.settingsform.setFixedSize( self.settingsform.sizeHint() )
    self.aboutform.setFixedSize( self.aboutform.sizeHint() )
    self.BgrndColourDlg.setFixedSize( self.BgrndColourDlg.sizeHint() )
    self.ColourMapSelectDlg.setFixedSize( self.ColourMapSelectDlg.sizeHint() )
    self.select_millertable_column_dlg.resize()
    self.SpaceGrpUCellText.setFont(font)
    self.texttabfont = QFont("Courier New")
    self.texttabfont.setBold(True)
    self.texttabfont.setPointSize(val)
    for i in range(self.tabText.count()):
      self.tabText.widget(i).children()[1].setFont(self.texttabfont)


  def onBrowserFontsizeChanged(self, val):
    self.browserfontsize = val
    self.send_message("NGL.fontsize = %d" %val)


  def onVectorWidthChanged(self, val):
    self.vectorwidth = val
    self.send_message("NGL.vector_width = %d" %val)


  def onClearTextBuffer(self):
    self.textInfo.clear()
    self.textAlerts.clear()
    self.infostr = ""
    self.alertstr = ""


  def onDebugShowPhil(self):
    return self.send_message("", msgtype="debug_show_phil")


  def onResetFactoryDefault(self):
    ret = QMessageBox.warning(self.window, "Reset to factory defaults next time HKLviewer starts",
                              "Are you sure?",
                              buttons=QMessageBox.Yes|QMessageBox.No, defaultButton=QMessageBox.No)
    if ret == QMessageBox.Yes:
      self.RemoveQsettings()
      msg = "User settings for %s have been removed. Factory defaults will be used after restart." %self.Qtversion
      self.AddInfoText(msg)
      self.resetFactoryDefaultbtn.setEnabled(False)


  def onWrapTextBuffer(self):
    if self.wraptextbtn.isChecked():
      self.wraptextinfo = True
      self.textInfo.setLineWrapMode(QPlainTextEdit.WidgetWidth)
      self.textAlerts.setLineWrapMode(QPlainTextEdit.WidgetWidth)
    else:
      self.wraptextinfo = False
      self.textInfo.setLineWrapMode(QPlainTextEdit.NoWrap)
      self.textAlerts.setLineWrapMode(QPlainTextEdit.NoWrap)


  def onCameraPerspect(self,val):
    if self.cameraPerspectCheckBox.isChecked():
      self.send_message("NGL.camera_type = perspective")
    else:
      self.send_message("NGL.camera_type = orthographic")


  def ExpandRefls(self):
    if self.unfeedback:
      return
    if self.ExpandReflsGroupBox.isChecked():
      self.send_message('''
      hkls.expand_to_p1 = True
      hkls.expand_anomalous = True
                      ''' )
    else:
      self.send_message('''
      hkls.expand_to_p1 = False
      hkls.expand_anomalous = False
                      ''' )


  def ExpandToP1(self):
    if self.unfeedback:
      return
    if self.expandP1checkbox.isChecked():
      self.send_message('hkls.expand_to_p1 = True' )
    else:
      self.send_message('hkls.expand_to_p1 = False' )


  def ExpandAnomalous(self):
    if self.unfeedback:
      return
    if self.expandAnomalouscheckbox.isChecked():
      self.send_message('hkls.expand_anomalous = True' )
    else:
      self.send_message('hkls.expand_anomalous = False' )


  def showSysAbsent(self):
    if self.unfeedback:
      return
    if self.sysabsentcheckbox.isChecked():
      self.send_message('hkls.show_systematic_absences = True')
    else:
      self.send_message('hkls.show_systematic_absences = False')


  def showMissing(self):
    if self.unfeedback:
      return
    if self.missingcheckbox.isChecked():
      self.send_message('hkls.show_missing = True')
      self.onlymissingcheckbox.setEnabled(True)
    else:
      self.send_message("""hkls.show_missing = False
                             hkls.show_only_missing = False
                          """)
      self.onlymissingcheckbox.setEnabled(False)


  def showOnlyMissing(self):
    if self.unfeedback:
      return
    if self.onlymissingcheckbox.isChecked():
      self.send_message('hkls.show_only_missing = True')
    else:
      self.send_message('hkls.show_only_missing = False')


  def onBindataComboSelchange(self, i):
    if self.BinDataComboBox.currentText():
      binner_idx = self.BinDataComboBox.currentIndex()
      self.send_message('binning.binner_idx = %d' % binner_idx )
      bin_opacitieslst = []
      for j in range(self.nbins):
        bin_opacitieslst.append((1.0, j))
      self.bin_opacities = bin_opacitieslst
      self.OpaqueAllCheckbox.setCheckState(Qt.Checked)


  def update_table_opacities(self, allalpha=None):
    bin_opacitieslst = self.bin_opacities
    self.binstable_isready = False
    for binopacity in bin_opacitieslst:
      if not allalpha:
        alpha = binopacity[0]
      else:
        alpha = allalpha
      bin = binopacity[1]
      item = QTableWidgetItem()
      item.setFlags(Qt.ItemIsUserCheckable | Qt.ItemIsEnabled)
      if alpha == 0.0:
        item.setCheckState(Qt.Unchecked)
      if alpha > 0.0 and alpha < 1.0:
        item.setCheckState(Qt.PartiallyChecked)
      if alpha == 1.0:
        item.setCheckState(Qt.Checked)
      item.setText(str(alpha))
      item.setFlags(item.flags() ^ Qt.ItemIsEditable)
      item.setFlags(item.flags() ^ Qt.ItemIsSelectable )
      self.binstable.setItem(bin, 3, item)
    self.binstable_isready = True


  def SetAllOpaqueCheckboxes(self):
    if self.binstableitemchanges:
      return
    bin_opacitieslst = self.bin_opacities
    nbins = len(bin_opacitieslst)
    sum = 0
    for binopacity in bin_opacitieslst:
      sum += binopacity[0]  # float(binopacity.split(",")[0])
    if sum >= nbins:
      self.OpaqueAllCheckbox.setCheckState(Qt.Checked)
    if sum == 0:
      self.OpaqueAllCheckbox.setCheckState(Qt.Unchecked)
    if sum >0.0 and sum < nbins:
      self.OpaqueAllCheckbox.setCheckState(Qt.PartiallyChecked)


  def onBinsTableitemPressed(self, item):
    self.binTableCheckState = item.checkState()
    self.bintableAlpha = float(item.text())


  def onBinsTableItemChanged(self, item):
    row = item.row()
    col = item.column()
    try:
      if not self.bin_opacities:
        return
      bin_opacitieslst = self.bin_opacities
      alpha = max(0.0, min(1.0, float(item.text()) ) ) # between 0 and 1 only
      try:
        (oldalpha, row) = bin_opacitieslst[row]
        row = int(row)
        if oldalpha == float(item.text()):
          if item.checkState()==Qt.Unchecked:
            alpha = 0.0
          else:
            alpha = 1.0
      except Exception as e:
        pass
      if col==3 and self.binstable_isready: # changing opacity
        bin_opacitieslst[row] = (alpha, row)
        self.bin_opacities = bin_opacitieslst
        self.SetAllOpaqueCheckboxes()
        philstr = ""
        for opa,bin in self.bin_opacities:
          philstr += 'binning.bin_opacity = %s %s\n' %(opa, bin)
        self.send_message(philstr)
      if col==1 and self.binstable_isready: # changing scene_bin_thresholds
        aboveitem = self.binstable.item(row-1, 1)
        belowitem = self.binstable.item(row+1, 1)
        rightitem = self.binstable.item(row, 2)
        if aboveitem is None:
          aboveval = -9e99
        else:
          aboveval = float(aboveitem.text())
        if belowitem is None:
          belowval = 9e99
        else:
          belowval = float(belowitem.text())
          if math.isnan(belowval):
            belowval = float(rightitem.text())
        newval = float(item.text())
        self.binstable.item(row,col).setText(str(newval))
        self.lowerbinvals[row] = newval
        upperbinvalsnonan = [e for e in self.upperbinvals if not math.isnan(e)]
        allbinvals = self.lowerbinvals + [ upperbinvalsnonan[-1] ]
        self.send_message("binning.scene_bin_thresholds = %s" %" ".join([ str(e) for e in allbinvals]))
    except Exception as e:
      print( str(e)  +  traceback.format_exc(limit=10) )


  def onOpaqueAll(self):
    self.binstableitemchanges = True
    bin_opacitieslst = self.bin_opacities
    nbins = len(bin_opacitieslst)
    bin_opacitieslst = []
    self.binstable_isready = False
    if self.OpaqueAllCheckbox.isChecked():
      for i in range(nbins):
        bin_opacitieslst.append((1.0, i))  #  ("1.0, %d" %i)
    else:
      for i in range(nbins):
        bin_opacitieslst.append((0.0, i))  #   ("0.0, %d" %i)
    self.bin_opacities = bin_opacitieslst
    philstr = ""
    for opa,bin in self.bin_opacities:
      philstr += 'binning.bin_opacity = %s %s\n' %(opa, bin)
    self.send_message(philstr)
    self.binstableitemchanges = False
    self.binstable_isready = True


  def onNbinsChanged(self, val):
    if self.unfeedback:
      return
    self.nbins = val
    self.send_message("binning.nbins = %d" %self.nbins)


  def onRadiiScaleEditFinished(self):
    if self.unfeedback:
      return
    self.send_message("hkls.scale = %f" %self.radii_scale_spinBox.value() )


  def onPowerScaleEditFinished(self):
    if self.unfeedback:
      return
    self.send_message("hkls.nth_power_scale_radii = %f" %self.power_scale_spinBox.value() )


  def onManualPowerScale(self, val=None):
    if self.unfeedback:
      return
    if self.ManualPowerScalecheckbox.isChecked():
      self.send_message('hkls.nth_power_scale_radii = %f' %self.power_scale_spinBox.value())
    else:
      self.send_message('hkls.nth_power_scale_radii = %s' %float("nan"))


  def onShowAllVectors(self):
    if self.unfeedback:
      return
    if self.ShowAllVectorsBtn.checkState()==Qt.Checked:
      self.send_message("viewer.show_all_vectors = 1")
    if self.ShowAllVectorsBtn.checkState()==Qt.Unchecked:
      self.send_message("viewer.show_all_vectors = -1")
    self.unfeedback = False


  def onVectorTableItemChanged(self, item):
    if self.unfeedback:
      return
    row = item.row()
    col = item.column()
    try:
      rc = len(self.all_vectors)
      label = None
      opnr = -1
      if self.vectortable2.item(row, 0) is not None:
        label = self.vectortable2.item(row, 0).text()
      if row < rc:
        if label is None:
          return
        if col==0:
          philstr = ""
          if self.rotvec is not None: # reset any imposed angle to 0 whenever checking or unchecking a vector
              philstr += "viewer.angle_around_vector = '[%d, 0]'\n" %self.rotvec
              self.rotavecangle_slider.setValue(0)
          self.rotvec = None
          sum = 0
          ivec= []
          for rvrow in range(self.vectortable2.rowCount()):
            if self.vectortable2.item(rvrow, 0) is not None:
              opnr = self.vectortable2.item(rvrow, 0).data(Qt.UserRole)
              if self.vectortable2.item(rvrow, 0).checkState()==Qt.Checked:
                self.rotvec = rvrow
                sum +=1
                ivec = [opnr, True]
              else:
                ivec = [opnr, False]
              philstr += "viewer.show_vector = " + str(ivec) + "\n"
          if sum > 1 or sum == 0: # can only use one vector to rotate around. so if more are selected then deselect them altogether
            philstr += "viewer.animate_rotation_around_vector = '[%d, %f]'\n" %(0, -1.0)
            philstr += 'viewer.fixorientation = *None\n'
            self.AnimaRotCheckBox.setCheckState(Qt.Unchecked)
            self.rotvec = None
          if self.rotvec is not None:
            self.RotateAroundframe.setEnabled(True)
            # notify cctbx which is the curently selected vector
            philstr += "viewer.angle_around_vector = '[%d, 0.0]'\n" %self.rotvec
          else:
            self.RotateAroundframe.setDisabled(True)
          if sum >= rc:
            self.ShowAllVectorsBtn.setCheckState(Qt.Checked)
          if sum == 0:
            self.ShowAllVectorsBtn.setCheckState(Qt.Unchecked)
          if sum >0.0 and sum < rc:
            self.ShowAllVectorsBtn.setCheckState(Qt.PartiallyChecked)
          self.send_message(philstr)
      if row==rc and label !="" and label != "new vector": # a user defined vector
        if col==1:
          hklop = self.vectortable2.item(row, 1).text()
          self.send_message("""
viewer.user_vector {
  hkl_op = '%s'
  label = %s
}""" %(hklop, label))
        if col==2:
          hklvec = self.vectortable2.item(row, 2).text()
          self.send_message("""
viewer.user_vector {
  hkl = '%s'
  label = %s
}""" %(hklvec, label))
        if col==3:
          abcvec = self.vectortable2.item(row, 3).text()
          self.send_message("""
viewer.user_vector {
  abc = '%s'
  label = %s
}""" %(abcvec, label))
    except Exception as e:
      print( str(e)  +  traceback.format_exc(limit=10) )


  def createExpansionBox(self):
    self.SpaceGroupComboBox.activated.connect(self.onSpacegroupSelchange)
    self.expandP1checkbox.clicked.connect(self.ExpandToP1)
    self.expandAnomalouscheckbox.clicked.connect(self.ExpandAnomalous)
    self.ExpandReflsGroupBox.clicked.connect(self.ExpandRefls)
    self.commitSubgroupExpansionBtn.clicked.connect(self.onCommitSubgroupExpansion)
    self.commitSubgroupExpansionBtn.setEnabled(False)
    self.sysabsentcheckbox.clicked.connect(self.showSysAbsent)
    self.missingcheckbox.clicked.connect(self.showMissing)
    self.onlymissingcheckbox.clicked.connect(self.showOnlyMissing)


  def CreateSliceTabs(self):
    vprec = 2
    self.hkldistval = 0.0
    self.hkldist_spinBox.setValue(self.hkldistval)
    self.hkldist_spinBox.setDecimals(1)
    self.hkldist_spinBox.setSingleStep(1)
    self.hkldist_spinBox.setRange(-1000.0, 1000.0)
    self.hkldist_spinBox.editingFinished.connect(self.onHKLdistEditFinished)
    self.hkldist_spinBox.onStepBy = self.onHKLdistEditFinished

    self.clipwidth_spinBox.setValue(0.35 )
    self.clipwidth_spinBox.setDecimals(3)
    self.clipwidth_spinBox.setSingleStep(0.05)
    self.clipwidth_spinBox.setRange(0.0, 100.0)
    self.clipwidth_spinBox.editingFinished.connect(self.onClipwidthEditFinished)
    self.clipwidth_spinBox.onStepBy = self.onClipwidthEditFinished

    self.yHKLrotBtn.clicked.connect(self.onYangleHKLrotate)
    self.xHKLrotBtn.clicked.connect(self.onXangleHKLrotate)
    self.zHKLrotBtn.clicked.connect(self.onZangleHKLrotate)
    self.yHKLbackrotBtn.clicked.connect(self.onYangleHKLrotateback)
    self.xHKLbackrotBtn.clicked.connect(self.onXangleHKLrotateback)
    self.zHKLbackrotBtn.clicked.connect(self.onZangleHKLrotateback)
    self.clipplane_normal_vector_length.editingFinished.connect(self.onClipwidthNormalVecLengthEditFinished)
    self.clipplane_normal_vector_combo.activated.connect(self.onClipPlaneNormalVecSelchange)

    self.parallel_current_orientation_btn.clicked.connect(self.onParallel_current_orientation_btn_click)
    self.normal_realspace_vec_btn.clicked.connect(self.onNormal_realspace_vec_btn_click)
    self.normal_vec_btn.clicked.connect(self.onNormal_vec_btn_click)


  def onClipwidthNormalVecLengthEditFinished(self):
    if self.unfeedback:
      return
    try:
      val = eval(self.clipplane_normal_vector_length.text())
      philstr = "clip_plane.normal_vector_length_scale = %s"  %val
      self.send_message(philstr)
    except Exception as e:
      print( str(e) )


  def onClipPlaneNormalVecSelchange(self):
    if self.unfeedback:
      return
    self.clipplane_normal_vector_length.setText("{:.6g}".format(self.clipplane_normal_vector_combo.currentData()))
    philstr = """viewer.fixorientation = *vector
clip_plane.clip_width = %f
clip_plane.normal_vector = "%s"
clip_plane.normal_vector_length_scale = -1
""" %(self.clipwidth_spinBox.value(), self.clipplane_normal_vector_combo.currentText())
    self.send_message(philstr)


  def onParallel_current_orientation_btn_click(self):
    if self.unfeedback:
      return
    self.clipplane_normal_vector_combo.setEnabled(False)
    self.RotateGroupBox.setEnabled(True)
    philstr = """viewer.fixorientation = *None
clip_plane.clip_width = %f
clip_plane.normal_vector = ""
""" %self.clipwidth_spinBox.value()
    self.send_message(philstr)


  def onNormal_vec_btn_click(self):
    if self.unfeedback:
      return
    self.clipplane_normal_vector_combo.setEnabled(True)
    self.RotateGroupBox.setEnabled(False)
    philstr = """viewer.fixorientation = *vector
viewer.is_parallel = False
clip_plane.clip_width = %f
clip_plane.normal_vector = "%s"
clip_plane.is_assoc_real_space_vector = False
clip_plane.normal_vector_length_scale = -1
""" %( self.clipwidth_spinBox.value(), self.clipplane_normal_vector_combo.currentText())
    self.send_message(philstr)


  def onNormal_realspace_vec_btn_click(self):
    if self.unfeedback:
      return
    self.clipplane_normal_vector_combo.setEnabled(True)
    self.RotateGroupBox.setEnabled(False)
    philstr = """viewer.fixorientation = *vector
viewer.is_parallel = False
clip_plane.clip_width = %f
clip_plane.normal_vector = "%s"
clip_plane.is_assoc_real_space_vector = True
clip_plane.normal_vector_length_scale = -1
""" %( self.clipwidth_spinBox.value(), self.clipplane_normal_vector_combo.currentText())
    self.send_message(philstr)


  def onXangleHKLrotate(self):
    self.send_message("viewer.angle_around_XHKL_vector = %f" %self.angleStepHKLrotSpinBox.value() )


  def onYangleHKLrotate(self):
    self.send_message("viewer.angle_around_YHKL_vector = %f" %self.angleStepHKLrotSpinBox.value() )


  def onZangleHKLrotate(self):
    self.send_message("viewer.angle_around_ZHKL_vector = %f" %self.angleStepHKLrotSpinBox.value() )


  def onXangleHKLrotateback(self):
    self.send_message("viewer.angle_around_XHKL_vector = %f" %(-1*self.angleStepHKLrotSpinBox.value()) )


  def onYangleHKLrotateback(self):
    self.send_message("viewer.angle_around_YHKL_vector = %f" %(-1*self.angleStepHKLrotSpinBox.value()) )


  def onZangleHKLrotateback(self):
    self.send_message("viewer.angle_around_ZHKL_vector = %f" %(-1*self.angleStepHKLrotSpinBox.value()) )


  def onAlignedVector(self):
    if self.unfeedback:
      return
    val = "*None"
    if self.AlignVectorGroupBox.isChecked():
      val = "*vector"
    philstr = """viewer {
        is_parallel = %s
        fixorientation = "%s"
      } """ %(str(self.AlignParallelBtn.isChecked()), val )
    self.send_message(philstr)


  def onClipPlaneChkBox(self):
    if self.unfeedback:
      return
    hkldist, clipwidth = 0.0, None
    if self.ClipPlaneChkGroupBox.isChecked():
      if self.normal_realspace_vec_btn.isChecked():
        self.clipplane_normal_vector_combo.setEnabled(True)
        self.RotateGroupBox.setEnabled(False)
        philstr = """hkls {
  slice_mode = False
}
viewer.is_parallel = False
viewer.fixorientation = *vector
clip_plane.clip_width = %f
clip_plane.normal_vector = "%s"
clip_plane.is_assoc_real_space_vector = True
clip_plane.normal_vector_length_scale = -1
""" %( self.clipwidth_spinBox.value(), self.clipplane_normal_vector_combo.currentText())
      elif self.normal_vec_btn.isChecked():
        self.clipplane_normal_vector_combo.setEnabled(True)
        self.RotateGroupBox.setEnabled(False)
        philstr = """hkls {
  slice_mode = False
}
viewer.is_parallel = False
viewer.fixorientation = *vector
clip_plane.clip_width = %f
clip_plane.normal_vector = "%s"
clip_plane.is_assoc_real_space_vector = False
clip_plane.normal_vector_length_scale = -1
""" %( self.clipwidth_spinBox.value(), self.clipplane_normal_vector_combo.currentText())
      else:
        self.clipplane_normal_vector_combo.setEnabled(False)
        self.RotateGroupBox.setEnabled(True)
        philstr = """hkls {
  slice_mode = False
}
viewer.is_parallel = True
viewer.fixorientation = *None
clip_plane.clip_width = %f
clip_plane.normal_vector = ""
          """ %self.clipwidth_spinBox.value()
    else:
      philstr = """hkls {
  slice_mode = False
}
viewer.fixorientation = *None
clip_plane {
  normal_vector = ""
  clip_width = None
}
       """
    self.send_message(philstr)


  def onAutoClipWidthChkBox(self):
    if self.unfeedback:
      return
    if self.AutoClipWidthCheckBox.isChecked():
      philstr = "clip_plane.auto_clip_width = True"
    else:
      philstr = "clip_plane.auto_clip_width = False"
    self.send_message(philstr)


  def onRotaVecAngleChanged(self, val):
    if self.unfeedback or self.rotvec is None:
      return
    self.send_message("viewer.angle_around_vector = '[%d, %f]'" %(self.rotvec, val*0.5))


  def onFinalRotaVecAngle(self):
    if self.unfeedback or self.rotvec is None:
      return
    val = self.rotavecangle_slider.value()*0.5
    self.send_message("viewer.angle_around_vector = '[%d, %f]'" %(self.rotvec, val))


  def onAnimateRotation(self):
    if not self.unfeedback:
      if self.AnimaRotCheckBox.isChecked() == True:
        self.AnimateSpeedSlider.setEnabled(True)
        self.rotavecangle_slider.setDisabled(True)
        speed = self.AnimateSpeedSlider.value()
        for rvrow in range(self.vectortable2.rowCount()):
          if self.vectortable2.item(rvrow, 0) is not None:
            if self.vectortable2.item(rvrow, 0).checkState()==Qt.Checked:
              self.rotvec = rvrow
              break
        self.send_message("viewer.animate_rotation_around_vector = '[%d, %f]'" %(self.rotvec, speed))
      else:
        self.rotavecangle_slider.setEnabled(True)
        self.AnimateSpeedSlider.setDisabled(True)
        self.send_message("viewer.animate_rotation_around_vector = '[%d, %f]'" %(self.rotvec, -1.0))


  def onClipwidthEditFinished(self):
    if not self.unfeedback:
      self.send_message("clip_plane.clip_width = %f" %self.clipwidth_spinBox.value())


  def onHKLdistEditFinished(self):
    if not self.unfeedback:
      self.hkldistval = self.hkldist_spinBox.value()
      self.send_message("clip_plane.hkldist = %f" %self.hkldistval)


  def onHvecChanged(self, val):
    if not self.unfeedback:
      self.send_message("clip_plane.h = %f" %self.hvec_spinBox.value())


  def onKvecChanged(self, val):
    if not self.unfeedback:
      self.send_message("clip_plane.k = %f" %self.kvec_spinBox.value())


  def onLvecChanged(self, val):
    if not self.unfeedback:
      self.send_message("clip_plane.l = %f" %self.lvec_spinBox.value())


  def onMillerTableCellPressed(self, row, col):
    #print( "in millertable CellPressed " + self.millertable.currentItem().text() )
    if self.millertable.mousebutton == Qt.RightButton:
      self.MillerTableContextMenuHandler(QCursor.pos(), row)
    if self.millertable.mousebutton == QEvent.MouseButtonDblClick:
      # quickly display data with a double click
      for scenelabel,labeltype,arrayid,hassigmas,sceneid in self.scenearraylabeltypes:
        if row == arrayid:
          self.DisplayData(sceneid, row)
          break


  def onMillerTableitemSelectionChanged(self):
    self.millertable.selectedrows = list(set([ e.row() for e in self.millertable.selectedItems() ]))


  def MillerTableContextMenuHandler(self, pos, row):
    self.millertablemenu.clear()
    # Tag menu items with data being int or a (string, int) tuple.
    # These are being checked for in onMillerTableMenuAction() and appropriate
    # action taken
    for i,(scenelabel,labeltype,arrayid,hassigmas,sceneid) in enumerate(self.scenearraylabeltypes): # loop over scenes
      scenelabelstr = scenelabel
      if self.millerarraylabels[row] == scenelabelstr or self.millerarraylabels[row] + " + " in scenelabelstr:
        if hassigmas: # sigmas are present for this array
          myqa = QAction("Display data of %s" %scenelabelstr, self.window, triggered=self.testaction)
          myqa.setData(("display_data",[sceneid, row]))
          self.millertablemenu.addAction(myqa)
          myqa = QAction("Display sigmas of %s" %scenelabelstr, self.window, triggered=self.testaction)
          myqa.setData(("display_data",[sceneid + 1000, row])) # want to show the sigmas rather than the data if we add 1000
          self.millertablemenu.addAction(myqa)
        else: # no sigmas present for this array
          myqa = QAction("Display %s" %scenelabelstr, self.window, triggered=self.testaction)
          myqa.setData(("display_data",[sceneid, row]))
          self.millertablemenu.addAction(myqa)
    myqa = QAction("Make a new dataset from this dataset and another dataset...",
                   self.window, triggered=self.testaction)
    myqa.setData(("make_newdata", row ))
    self.millertablemenu.addAction(myqa)
    if len(self.millertable.selectedrows) ==1:
      myqa = QAction("Display tooltips for %s" %self.millerarraylabels[row], self.window, triggered=self.testaction)
      myqa.setCheckable(True)
      myqa.setChecked(self.include_tooltip_lst[row] )
      myqa.setData(("tooltip_data", row))
      self.millertablemenu.addAction(myqa)

    if len(self.millertable.selectedrows) > 1:
      arraystr = ""
      labels = []
      sum = 0
      for i,row in enumerate(self.millertable.selectedrows):
        labels.append( self.millerarraylabels[row] )
        sum += int(self.include_tooltip_lst[row])
      myqa = QAction("Display tooltips for %s" %  " and ".join(labels),
                     self.window, triggered=self.testaction)
      myqa.setCheckable(True)
      if len(self.millertable.selectedrows) == sum:
        myqa.setChecked(True )
      if sum == 0:
        myqa.setChecked(False )
      if len(self.millertable.selectedrows) > sum and sum > 0:
        myqa = QAction(QIcon( os.path.join(os.path.dirname(os.path.abspath(__file__)), "partiallychecked.png")),
                       "Display tooltips for %s" %  " and ".join(labels),
                       self.window, triggered=self.testaction)
        myqa.setCheckable(True)

      myqa.setData(("tooltip_data", self.millertable.selectedrows))
      self.millertablemenu.addAction(myqa)

    if len(self.millertable.selectedrows) > 0:
      arraystr = ""
      labels = []
      for i,r in enumerate(self.millertable.selectedrows):
        labels.extend( self.millerarraylabels[r].split(",") ) # to cope with I,SigI or other multiple labels
      myqa = QAction("Show a table of the %s dataset ..." %  " and ".join(labels),
                     self.window, triggered=self.testaction)
      lbls =[] # group any crystal_id=1, wavelength_id, scale_group_code with labels in lists
      for i,r in enumerate(self.millertable.selectedrows):
        lbls.extend( [ self.millerarraylabels[r].split(",") ] ) # to cope with I,SigI or other multiple labels
      myqa.setData( ("tabulate_data", lbls ))
      self.millertablemenu.addAction(myqa)
    #import code, traceback; code.interact(local=locals(), banner="".join( traceback.format_stack(limit=10) ) )
    self.millertablemenu.exec_(QCursor.pos())


  def onMillerTableMenuAction(self, action):
    data = action.data()
    # depending on what menu item the user clicked data is either an int or a (string, int) tuple
    if data is not None:
      strval, val = data
      if strval=="display_data":
        [idx, row] = val
        self.DisplayData(idx,row)
      if strval=="make_newdata":
        self.operate_arrayidx1 = val
        self.operate_arraytype1 = self.scenearraylabeltypes[val][1]
        self.operate_arrayidx2 = -1 # i.e. no second miller array selected yet in MillerComboBox
        self.operate_arraytype2 = ""
        self.operationlabeltxt.setText("Define a new cctbx.miller.array object, \"newarray\", "
          + "by entering a python expression for \"newarray\" or by assigning \"newarray._data\" "
          + "(and optionally \"newarray._sigmas\") to a function of the cctbx.miller.array object, "
          + "\"array1\", representing the " + self.millerarraylabels[val] + " dataset. Optionally "
          + "also include the cctbx.miller.array object, \"array2\" representing a dataset "
          + "selected from the dropdown list below."
          )
        self.makenewdataform.show()
      if strval=="tabulate_data":
        self.send_message('tabulate_miller_array_ids = "%s"' %str(val))
      if strval=="tooltip_data":
        if isinstance(val, list): # if we highlighted more rows then toggle tooltips on or off by
          sum = 0   # taking the opposite of the rounded integer average of the tooltip visibility
          for row in self.millertable.selectedrows:
            sum += int(self.include_tooltip_lst[row])
          bval = bool(round(float(sum)/len(self.millertable.selectedrows)))
          for row in self.millertable.selectedrows:
            self.include_tooltip_lst[row] = not bval
            self.send_message('tooltip_data = "%s"' %str([row, self.include_tooltip_lst[row]]))
        else: # only rightclicked one row so toggle its tooltip visibility
          self.include_tooltip_lst[val] = not self.include_tooltip_lst[val]
          self.send_message('tooltip_data = "%s"' %str([val, self.include_tooltip_lst[val]]))


  def DisplayData(self, idx, row):
    # want to show the sigmas rather than the data if we have added 1000 to idx
    self.currentmillarray_idx = row
    arrayinfo = self.array_infotpls[self.currentmillarray_idx]
    if (idx - 1000) >= 0:
      idx = idx - 1000
      philstr = """
      hkls.sigma_color_radius = True
      viewer.scene_id = %d
      """ %idx
    else:
      philstr = """
      hkls.sigma_color_radius = False
      viewer.scene_id = %d
      """ %idx
    self.send_message(philstr)
    if self.fileisvalid:
      self.functionTabWidget.setEnabled(True)
      self.expandAnomalouscheckbox.setEnabled(True)
      self.expandP1checkbox.setEnabled(True)
      # don't allow anomalous expansion for data that's already anomalous
      isanomalous, spacegroup = self.ano_spg_tpls[self.currentmillarray_idx]
      label = arrayinfo[0][0]
      if isanomalous:
        self.expandAnomalouscheckbox.setDisabled(True)
      if spacegroup=='P 1 (No. 1)':
        self.expandP1checkbox.setDisabled(True)
    else:
      self.functionTabWidget.setDisabled(True)
    self.SpaceGroupComboBox.clear()
    self.SpaceGroupComboBox.addItems( list(self.spacegroups.values() ))


  def onMakeNewData(self):
    lbltype2 = ["",""]
    if self.operate_arrayidx2 >= 0: # a dataset was selected in the millercombobox. Get label and type
      lbltype2 = [self.millerarraylabels[self.operate_arrayidx2],
                  self.operate_arraytype2]
    mtpl = (self.operationtxtbox.toPlainText(),
              self.newlabeltxtbox.text() ,
              [self.millerarraylabels[self.operate_arrayidx1],
               self.operate_arraytype1],
               lbltype2
            )
    self.send_message('miller_array_operation = "%s"' %str(mtpl) )
    self.makenewdataform.accept()


  def onMillerComboSelchange(self, i):
    self.operate_arrayidx2, self.operate_arraytype2 = self.MillerComboBox.itemData(i)
    # -1 if first item. Otherwise itemdata is index of the list of miller arrays


  def testaction(self):
    pass


  def onCommitSubgroupExpansion(self):
    ret = QMessageBox.warning(self.window, "Expand datasets to selected subgroup",
                              "This will irreversibly expand all datasets to the selected subgroup\nAre you sure?",
                              buttons=QMessageBox.Yes|QMessageBox.No, defaultButton=QMessageBox.No)
    if ret == QMessageBox.Yes:
      self.send_message('commit_subgroup_datasets = True')
      self.commitSubgroupExpansionBtn.setEnabled(False)


  def onAddDataset(self):
    label, ok = QInputDialog().getText(self.window, "Enter a unique label for the new dataset",
                                         "Create new dataset of visible reflections with this label:")
    if ok and label:
       self.send_message('visible_dataset_label = "%s"' %label)


  def createFileInfoBox(self):
    labels = ["Column label", "Type", "λ(Å)", "# HKLs", "Span of HKLs",
       "Min Max data", "Min Max sigmas", "d_min, d_max (Å)", "Anomalous", "Symmetry unique"]
    self.millertable.setColumnCount(len(labels))
    self.millertable.setHorizontalHeader( MyhorizontalHeader(self.window) )
    self.millertable.setHorizontalHeaderLabels(labels)
    self.millertable.horizontalHeader().setDefaultAlignment(Qt.AlignLeft)
    # don't allow editing this table
    self.millertable.setEditTriggers(QTableWidget.NoEditTriggers)
    self.millertable.cellPressed.connect(self.onMillerTableCellPressed)
    self.millertable.cellDoubleClicked.connect(self.onMillerTableCellPressed)
    self.millertable.itemSelectionChanged.connect(self.onMillerTableitemSelectionChanged)


  def createRadiiScaleGroupBox(self):
    self.ManualPowerScalecheckbox.clicked.connect(self.onManualPowerScale)
    self.power_scale_spinBox.editingFinished.connect(self.onPowerScaleEditFinished)
    self.power_scale_spinBox.onStepBy = self.onPowerScaleEditFinished
    self.radii_scale_spinBox.editingFinished.connect(self.onRadiiScaleEditFinished)
    self.radii_scale_spinBox.onStepBy = self.onRadiiScaleEditFinished


  def createBinsBox(self):
    self.binstable_isready = False
    labels = ["# HKLs", "lower bin value", "upper bin value", "opacity"]
    self.binstable.setHorizontalHeaderLabels(labels)
    self.binstable.horizontalHeader().setDefaultAlignment(Qt.AlignLeft)
    self.Nbins_spinBox.valueChanged.connect(self.onNbinsChanged)
    self.OpaqueAllCheckbox.clicked.connect(self.onOpaqueAll)
    self.addDatasetBtn.clicked.connect(self.onAddDataset)
    self.binstable.itemChanged.connect(self.onBinsTableItemChanged  )
    self.binstable.itemPressed.connect(self.onBinsTableitemPressed  )
    self.BinDataComboBox.activated.connect(self.onBindataComboSelchange)


  def CreateVectorsBox(self):
    self.DrawRealUnitCellBox.clicked.connect(self.onDrawUnitCellBoxClick)
    self.DrawReciprocUnitCellBox.clicked.connect(self.onDrawReciprocUnitCellBoxClick)
    self.unitcellslider.sliderReleased.connect(self.onUnitcellScale)
    self.reciprocunitcellslider.sliderReleased.connect(self.onReciprocUnitcellScale)
    labels = ["draw", "rotation", "as hkl", "as abc"]
    self.all_vectors = []
    self.vectortable2.setHorizontalHeaderLabels(labels)
    self.vectortable2.horizontalHeader().setDefaultAlignment(Qt.AlignLeft)
    self.vectortable2.itemChanged.connect(self.onVectorTableItemChanged  )
    #self.vectortable2.itemPressed.connect(self.onVectorTableItemChanged  )
    self.RotateAroundframe.setDisabled(True)
    self.ShowAllVectorsBtn.clicked.connect(self.onShowAllVectors)
    self.AlignParallelBtn.clicked.connect(self.onAlignedVector)
    self.AlignNormalBtn.clicked.connect(self.onAlignedVector)
    self.AlignVectorGroupBox.clicked.connect(self.onAlignedVector)
    self.AnimaRotCheckBox.clicked.connect(self.onAnimateRotation)
    self.AnimateSpeedSlider.sliderReleased.connect(self.onAnimateRotation)
    self.AnimateSpeedSlider.setDisabled(True)
    self.rotavecangle_labeltxt.setText("Reflections rotated around Vector with Angle: 0º")
    self.rotavecangle_slider.sliderReleased.connect(self.onFinalRotaVecAngle)
    self.rotavecangle_slider.valueChanged.connect(self.onRotaVecAngleChanged)
    self.rotavecangle_slider.setTracking(False)
    self.ClipPlaneChkGroupBox.clicked.connect(self.onClipPlaneChkBox)
    self.AutoClipWidthCheckBox.clicked.connect(self.onAutoClipWidthChkBox)


  def onSaveImage(self):
    if self.cctbxpythonversion == 'cctbx.python.version: 3': # streaming image over websockets
      options = QFileDialog.Options()
      fileName, filtr = QFileDialog.getSaveFileName(self.window,
              "Save screenshot to file", "",
              "PNG Files (*.png);;All Files (*)", "", options)
      if fileName:
        self.send_message('save_image_name = "%s" '%fileName)
    else:
      self.send_message('save_image_name = "dummy.png" ')
      # eventual file name prompted to us by Browser_download_requested(


  def onDrawReciprocUnitCellBoxClick(self):
    if not self.unfeedback:
      if self.DrawReciprocUnitCellBox.isChecked():
        self.send_message("draw_reciprocal_unit_cell = True")
      else:
        self.send_message("draw_reciprocal_unit_cell = False")


  def onDrawUnitCellBoxClick(self):
    if not self.unfeedback:
      if self.DrawRealUnitCellBox.isChecked():
        self.send_message("draw_real_space_unit_cell = True")
      else:
        self.send_message("draw_real_space_unit_cell = False")


  def onUnitcellScale(self):
    if self.unfeedback:
      return
    val = self.unitcellslider.value()/self.unitcellslider.maximum()
    self.send_message("real_space_unit_cell_scale_fraction = %f" %val)


  def onReciprocUnitcellScale(self):
    if self.unfeedback:
      return
    val = self.reciprocunitcellslider.value()/self.reciprocunitcellslider.maximum()
    self.send_message("reciprocal_unit_cell_scale_fraction = %f" %val)


  def HighlightReflection(self, hkl):
    self.send_message("viewer.show_hkl = '%s'" %str(hkl))


  def DebugInteractively(self):
    import code, traceback; code.interact(local=locals(), banner="".join( traceback.format_stack(limit=10) ) )


  def onSpacegroupSelchange(self,i):
    self.send_message("spacegroup_choice = %d" %i)
    if i==0:
      self.commitSubgroupExpansionBtn.setEnabled(False)
    else:
      self.commitSubgroupExpansionBtn.setEnabled(True)


  def find_free_port(self):
    import socket
    s = socket.socket()
    s.bind(('', 0))      # Bind to a free port provided by the host.
    port = s.getsockname()[1]
    s.close()
    return port


  def LaunchCCTBXPython(self):
    self.sockport = self.find_free_port()
    self.zmq_context = zmq.Context()
    self.socket = self.zmq_context.socket(zmq.PAIR)
    self.socket.bind("tcp://127.0.0.1:%s" %self.sockport)
    try: msg = self.socket.recv(flags=zmq.NOBLOCK) #To empty the socket from previous messages
    except Exception as e: pass

    guiargs = [ 'useGuiSocket=' + str(self.sockport),
               'high_quality=True',
              ]
    assert self.cctbxpython is not None
    # subprocess will not create interactive programs ( using popen.communicate() will simply terminate
    # the subprocess after execution). Since we need cmdlineframes.run() to be interactive
    # we start it with shell=True and flags -i -c for cmdlineframes.run() to remain running.
    # Care must be taken when closing HKLviewer to ensure the shell and its child process are both closed.
    args = ' '.join( guiargs + sys.argv[1:])
    cmdargs =  self.cctbxpython + ' -i -c "from crys3d.hklviewer import cmdlineframes;' \
     + ' cmdlineframes.run()" ' + args
    self.cctbxproc = subprocess.Popen( cmdargs, shell=True,
                                      universal_newlines=True,
                                      stdin=subprocess.PIPE)
    # Wait for connection from the zmq socket in CCTBX by testing if we can send an empty string
    print("Establishing ZMQ socket to CCTBX process", end='')
    t=0.0; dt = 0.5; timeout = 60 # more than enough time for connecting
    err = zmq.EAGAIN
    while err == zmq.EAGAIN:
      try:
        err = 0
        self.socket.send(bytes("","utf-8"), zmq.NOBLOCK)
      except Exception as e:
        err = e.errno # if EAGAIN then message cannot be sent at the moment.
      time.sleep(dt)
      t += dt
      print(".", end='', flush=True)
      if  t > timeout:
        raise Exception("\nHKLviewer GUI failed making ZMQ socket connection to CCTBX process.")
        break
    print("\nDone.")


  def send_message(self, cmdstr, msgtype="philstr"):
    try:
      msg = str([msgtype, cmdstr])
      if sys.version_info.major==3:
        self.socket.send(bytes(msg,"utf-8"), zmq.NOBLOCK)
      else:
        self.socket.send(bytes(msg), zmq.NOBLOCK)
      if msgtype == "philstr":
        self.ipresetbtn = -1 # so we don't tick any of the preset radio buttons after remaking them
      return True
    except Exception as e:
      print( str(e) + "\nFailed sending message to the CCTBX\n" + traceback.format_exc(limit=10))
      return False


  def setDatatypedict(self, datatypedict):
    self.datatypedict = datatypedict
    # send persisted colour schemes and raddi mappings to jsview_3d.py
    return self.send_message(str(self.datatypedict), msgtype="datatypedict")


  def PersistQsettings(self, write_factory_default_settings = False):
    Qtversion = self.Qtversion
    if write_factory_default_settings:
      # For developers only:
      # When supplying the new_factory_defaults argument on the command line all the settings
      # usually stored in the users Qsettings database will instead be stored in the file
      # crys3d\HKLviewer\HKLviewerDefaults.ini which can then be committed to git repo if desired and
      # work as new factory default settings. Adjust colours and sizes for datasets as well
      # as other settings as desired to write a HKLviewerDefaults.ini with those new settings
      # when exiting HKLviewer. The file should then be committed to the cctbx_project repo.
      self.settings = QSettings(self.factorydefaultfname,  QSettings.IniFormat)
      self.AddInfoText("Writing factory defaults to %s\n" %self.factorydefaultfname)
      self.AddAlertsText("Writing factory defaults to %s\n" %self.factorydefaultfname)
      Qtversion = "Qt"
    if not write_factory_default_settings:  # don't store system specific value as a default
      self.settings.setValue("PythonPath", self.cctbxpython )
    self.settings.beginGroup("MillerTableColumnHeader")
    ###### Code below should be done elsewhere such as in conda installation scripts for CCTBX
    # This presumes Qt is present in the CCTBX build and will then provide a path for GUI dispatchers
    cctbxbindir = os.path.split(self.cctbxpython)[0]
    cctbxversionsettings = QSettings("CCTBX", self.cctbxversion ) # version number sent from cctbx process
    cctbxversionsettings.setValue("DispatcherPath", cctbxbindir )
    #####################
    for philname, dummy, value in self.colnames_select_lst:
      self.settings.setValue(philname, int(value) )
    if len(self.colnames_select_lst) == 0:
      # No hkl file was opened so just save whatever MillerTableColumnHeader was already on disc
      # ReadPersistedQsettings() stored this in self.colnames_select_dict initially
      for philname in list(self.colnames_select_dict.keys()):
        self.settings.setValue(philname, int(self.colnames_select_dict[philname]) )
    self.settings.endGroup() # MillerTableColumnHeader

    self.settings.beginGroup(Qtversion )
    if not write_factory_default_settings: # don't store system specific value as a default
      self.settings.setValue("QWebEngineViewFlags", self.QWebEngineViewFlags)
    self.settings.setValue("QSplitter_number", self.nsplitters )
    self.settings.setValue("QTabWidget_number", self.ntabs )
    self.settings.setValue("FontSize", self.fontsize )
    self.settings.setValue("BackgroundColour", str(self.backgroundcolour.getRgb()) )
    self.settings.setValue("WordWrapTextInfo", int(self.wraptextinfo ))
    self.settings.setValue("MouseSpeed", self.mousespeed )
    self.settings.setValue("TextBufferSize", self.textinfosize )
    self.settings.setValue("BrowserFontSize", self.browserfontsize )
    self.settings.setValue("VectorWidth", self.vectorwidth )
    self.settings.setValue("ttip_click_invoke", self.ttip_click_invoke)
    self.settings.setValue("geometry", self.window.saveGeometry())
    self.settings.setValue("windowstate", self.window.saveState())
    self.settings.setValue("splitter1Sizes", self.splitter.saveState())
    self.settings.setValue("splitter2Sizes", self.splitter_2.saveState())
    self.settings.beginGroup("DataTypesGroups")
    datatypesgroups = self.settings.childGroups()
    for datatype in list(self.datatypedict.keys()):
      self.settings.setValue(datatype + "/ColourChart", self.datatypedict[ datatype ][0] )
      self.settings.setValue(datatype + "/ColourPowerScale", self.datatypedict[ datatype ][1] )
      self.settings.setValue(datatype + "/PowerScale", self.datatypedict[ datatype ][2])
      self.settings.setValue(datatype + "/RadiiScale", self.datatypedict[ datatype ][3])
    self.settings.endGroup() # DataTypesGroups
    self.settings.endGroup() # PySide2_ + Qtversion
    if write_factory_default_settings: # reset path for when closing app will save settings again
      self.settings = QSettings("CCTBX", "HKLviewer" )


  def ReadPersistedQsettings(self):
    # Read the user's persisted settings from disc
    self.settings.beginGroup(self.Qtversion)
    use_factory_default_settings = False
    # First see if there are any. If not then use factory defaults stored in .ini file
    #import code, traceback; code.interact(local=locals(), banner="".join( traceback.format_stack(limit=10) ) )
    if len(self.settings.allKeys()) == 0:
       # no settings for this Qt version. Use defaults then
      use_factory_default_settings = True
      # Numbers of splitters and tabs in the GUI are a very crude indication of
      # GUI complexity. If numbers differs from what is stored in the settings on disk the
      # settings are likely from a newer or older GUI version and should be ignored to prevent
      # messing up GUI layout. Use the defaults instead
    if self.nsplitters !=  int(self.settings.value("QSplitter_number", 0)):
      use_factory_default_settings = True
    if self.ntabs != int(self.settings.value("QTabWidget_number", 0)):
      use_factory_default_settings = True
    self.settings.endGroup()

    Qtversion = self.Qtversion
    if use_factory_default_settings:
      print("Reading factory defaults from " + self.factorydefaultfname)
      self.settings = QSettings(self.factorydefaultfname, QSettings.IniFormat)
      Qtversion = "Qt"

    # Locate cctbx.python. If not in the Qsettings then try if in the executable path environment
    cctbxpython_from_settings = self.settings.value("PythonPath", "")
    cctbxpython_from_env = ""

    wherecmd = "which"
    if sys.platform == 'win32':
      wherecmd = "where"
    proc = subprocess.Popen([wherecmd, "cctbx.python"],
                            universal_newlines=True, # avoid them annoying byte strings
                            stdout=subprocess.PIPE,
                            stderr=subprocess.PIPE).communicate()
    if proc[0] != "":
      cctbxpython_from_env = proc[0].strip()

    self.cctbxpython = cctbxpython_from_env
    if not os.path.isfile(self.cctbxpython):
      self.cctbxpython = cctbxpython_from_settings
    if not os.path.isfile(self.cctbxpython):
      from .qt import QInputDialog
      self.cctbxpython, ok = QInputDialog.getText(None, "cctbx.python needs specifying",
              'The HKLviewer GUI needs to know where the cctbx.python is located.\n' +
              'Enter the full path for the executable cctbx.python dispatcher file.\n' +
              'Tip: Use the "which" or "where" command from a shell with an active CCTBX environment.')
    if not os.path.isfile(self.cctbxpython):
      raise Exception("The file, %s, does not exists!\n" %self.cctbxpython)
    print("HKLviewer using cctbx.python from: %s" %self.cctbxpython)

    self.settings.beginGroup("MillerTableColumnHeader")
    keys = self.settings.childKeys()
    for philname in keys:
      self.colnames_select_dict[philname] = int(self.settings.value(philname, 1))
    self.settings.endGroup() # MillerTableColumnHeader
    # In case of more than one PySide2 installation tag the settings by version number of PySide2
    # as different versions seem too use different scaling for font and window sizes
    # But in case of using factory defaults then just look for the "Qt" group
    self.settings.beginGroup(Qtversion)
    self.settings.beginGroup("DataTypesGroups")
    datatypes = self.settings.childGroups()
    if datatypes:
      for datatype in datatypes:
        self.datatypedict[ datatype ] = [ self.settings.value(datatype + "/ColourChart", "brg"),
                                      float(self.settings.value(datatype + "/ColourPowerScale", 1.0)),
                                      float(self.settings.value(datatype + "/PowerScale", 1.0)),
                                      float(self.settings.value(datatype + "/RadiiScale", 1.0)),
                                    ]
    self.settings.endGroup()
    self.QWebEngineViewFlags = self.settings.value("QWebEngineViewFlags", None)
    self.mousespeed = float(self.settings.value("MouseSpeed", 0.3))
    self.textinfosize = int(self.settings.value("TextBufferSize", 30))
    # Get a boolean from the stored value which on windows is an int but a string on linux.
    # Do this by casting it into a string and compare with "1"
    self.wraptextinfo = (str(self.settings.value("WordWrapTextInfo", "0")) == "1")
    self.fontsize = float(self.settings.value("FontSize", 10))
    bcol = eval(self.settings.value("BackgroundColour", "(127,127,127,255)"))
    self.backgroundcolour = QColor(*bcol)
    self.browserfontsize = float(self.settings.value("BrowserFontSize", 9))
    self.vectorwidth = float(self.settings.value("VectorWidth", 5))
    self.ttip_click_invoke = self.settings.value("ttip_click_invoke", None)
    self.geometry = self.settings.value("geometry", None)
    self.windowstate = self.settings.value("windowstate", None)
    self.splitter1sizes = self.settings.value("splitter1Sizes", None)
    self.splitter2sizes = self.settings.value("splitter2Sizes", None)
    self.settings.endGroup()
    if use_factory_default_settings:
      # Revert to storing settings in the default Qsettings location such as
      # Windows: HKEY_CURRENT_USER\Software\ , Linux: $HOME/.config/ or MacOS: $HOME/Library/Preferences/
      # Do this by constructing a Qsettings object with our program scope
      self.settings = QSettings("CCTBX", "HKLviewer" )
    if self.QWebEngineViewFlags is None: # avoid doing this test over and over again on the same PC
      flgs = os.environ.get("QTWEBENGINE_CHROMIUM_FLAGS", "")
      self.QWebEngineViewFlags = flgs + " --disable-web-security" #\
      #  + " --enable-webgl-software-rendering --disable-gpu-compositing" \
      #  + " --disable_chromium_framebuffer_multisample --use-gl=swiftshader" \
      #  + " --swiftshader --swiftshader-webgl --ignore-gpu-blacklist"

      os.environ["QTWEBENGINE_CHROMIUM_FLAGS"] = self.QWebEngineViewFlags
      # QTWEBENGINE_CHROMIUM_FLAGS environment is now set for TestWebGL()
      if not self.isembedded:
        print("Testing if WebGL works in QWebEngineView....")
        #import code, traceback; code.interact(local=locals(), banner="".join( traceback.format_stack(limit=10) ) )
        if not TestWebGL(): # try software rendering
          self.QWebEngineViewFlags = flgs + " --disable-web-security" \
            + " --enable-webgl-software-rendering --disable-gpu-compositing" \
            + " --disable_chromium_framebuffer_multisample --use-gl=swiftshader" \
            + " --swiftshader --swiftshader-webgl --ignore-gpu-blocklist"

          os.environ["QTWEBENGINE_CHROMIUM_FLAGS"] = self.QWebEngineViewFlags
          if not TestWebGL():
            print("FATAL ERROR: WebGL does not work in QWebEngineView on this platform!")
            return False
        print(" It does!")
    for arg in sys.argv[1:]:
      if "verbose" in arg:
         print("using flags for QWebEngineView: " + os.environ["QTWEBENGINE_CHROMIUM_FLAGS"] )
    return True


  def UsePersistedQsettings(self):
    # Now assign the users persisted settings to the GUI
    if self.backgroundcolour is not None:
      self.BgrndColourDlg.setCurrentColor(self.backgroundcolour)
      self.onBackgroundColourChanged(self.backgroundcolour)
    if self.mousespeed is not None:
      self.mousemoveslider.setValue(float(self.mousespeed)*self.mousespeedscale)
      self.mousesensitxtbox.setText("%2.1f" %(self.mousemoveslider.value()*10.0/self.mousemoveslider.maximum()) )
      self.send_message('NGL.mouse_sensitivity = %s' %self.mousespeed)
    if self.wraptextinfo is not None:
      self.textInfo.setLineWrapMode(QPlainTextEdit.WidgetWidth if self.wraptextinfo else QPlainTextEdit.NoWrap)
    if self.textinfosize is not None:
      self.onTextbufferSizeChanged(int(self.textinfosize))
      self.bufsizespinBox.setValue(int(self.textinfosize))
    if self.fontsize is not None:
      #self.onFontsizeChanged(int(self.fontsize))
      self.fontspinBox.setValue(int(self.fontsize))
      self.onFontsizeChanged()
    if self.browserfontsize is not None:
      self.onBrowserFontsizeChanged(int(self.browserfontsize))
      self.browserfontspinBox.setValue(int(self.browserfontsize))
    if self.vectorwidth is not None:
      self.onVectorWidthChanged(int(self.vectorwidth))
      self.vectorWidthspinBox.setValue(int(self.vectorwidth))
    if self.ttip_click_invoke is not None:
      self.onShowTooltips(self.ttip_click_invoke)
      self.ttipClickradio.setChecked(self.ttip_click_invoke == "click")
      self.ttipHoverradio.setChecked(self.ttip_click_invoke == "hover")
    if self.splitter1sizes is not None and self.splitter2sizes is not None and \
     self.windowstate is not None:
      self.window.restoreGeometry(self.geometry) # this restores layout of main window
      self.window.restoreState(self.windowstate) # as well as ControlsWidget
      if self.webpagedebugform and self.devmode:
        self.webpagedebugform.resize( self.window.size())
      self.splitter.restoreState(self.splitter1sizes)
      self.splitter_2.restoreState(self.splitter2sizes)
      # must make ControlsWidget visible explicitly for restoring it
      self.ControlsWidget.setVisible(True)
      self.InfoWidget.setVisible(True)
    self.setDatatypedict(self.datatypedict)
    if self.make_new_factory_default_settings:
      # Create a new Factory default settings .ini file to be stored alongside this source file.
      self.PersistQsettings(True)


  @staticmethod
  def RemoveQsettings(all=False):
    mstr = NGL_HKLViewer.Qtversion
    if all:
      mstr = ""
    NGL_HKLViewer.settings.remove(mstr)
    print("HKLviewer settings removed. Using factory defaults next time.")
    NGL_HKLViewer.reset_to_factorydefaults = True


# test for any necessary flags for WebGL to work on this platform
def TestWebGL():
  #print("QTWEBENGINE_CHROMIUM_FLAGS = %s" %os.environ["QTWEBENGINE_CHROMIUM_FLAGS"] )
  QtChromiumCheck_fpath = os.path.join(os.path.split(hklviewer_gui.__file__)[0], "qt_chromium_check.py")
  cmdargs = [ sys.executable, QtChromiumCheck_fpath ]
  webglproc = subprocess.Popen( cmdargs, stdin=subprocess.PIPE,
                                stdout=subprocess.PIPE, stderr=subprocess.PIPE)
  procout, procerr = webglproc.communicate()
  if "WebGL works" in procout.decode():
    return True
  print(procout.decode())
  return False


def run(isembedded=False, chimeraxsession=None):
  import time
  #time.sleep(15) # enough time for attaching debugger

  # TODO: rewrite this function at some point to use python's argparse module
  try:
    kwargs = dict(arg.split('=') for arg in sys.argv if '=' in arg)
    # if an argument is a filename then have it as a keyword argument and assume it's a reflection file
    for arg in sys.argv[1:]:
      if '=' not in arg:
      # if so add it as a keyword argument
        if os.path.isfile(arg):
          if not kwargs.get('hklin', False):
            kwargs['hklin'] = arg

    os.environ["QTWEBENGINE_CHROMIUM_FLAGS"] = os.environ.get("QTWEBENGINE_CHROMIUM_FLAGS", "")
    argstr = " ".join(sys.argv[1:])

    if "remove_settings" in argstr:
      NGL_HKLViewer.RemoveQsettings()
      sys.exit()
    if "devmode" in argstr or "debug" in argstr:
      os.environ["PYTHONASYNCIODEBUG"] = "1" # print debug output from asyncio used in webbrowser_messenger_py3
    if "devmode" in argstr or "debug" in argstr and not "UseOSBrowser" in argstr:
      # some useful flags as per https://doc.qt.io/qt-5/qtwebengine-debugging.html
      if "debug" in argstr:
        os.environ["QTWEBENGINE_CHROMIUM_FLAGS"] = "--remote-debugging-port=9741 --single-process --js-flags='--expose_gc'"
      if "devmode" in argstr: # Also start our WebEngineDebugForm
# Don't use --single-process as it will freeze the WebEngineDebugForm when reaching user defined JavaScript breakpoints
        os.environ["QTWEBENGINE_CHROMIUM_FLAGS"] = "--js-flags='--expose_gc'"
    closingtime = None
    if kwargs.get('closing_time', False): # close when time is up during regression tests
      closingtime = int(kwargs['closing_time']) * 2000 # miliseconds

    from .qt import QApplication
    # ensure QWebEngineView scales correctly on a screen with high DPI
    if not isembedded:
      QApplication.setAttribute(Qt.AA_EnableHighDpiScaling)
    app = QApplication(sys.argv)
    HKLguiobj = NGL_HKLViewer(app, isembedded)
    if not isembedded:
      timer.setInterval(20)
      timer.timeout.connect(HKLguiobj.ProcessMessages)
      timer.start()
    else:
      start_time = [time.time()]

      def ChXTimer(trigger, trigger_data):
        elapsed_time = time.time()-start_time[0]
        if elapsed_time > 0.02:
          start_time[0] = time.time()
          HKLguiobj.ProcessMessages()

      HKLguiobj.chimeraxprocmsghandler = chimeraxsession.triggers.add_handler('new frame', ChXTimer)
      HKLguiobj.chimeraxsession = chimeraxsession
    # Call HKLguiobj.UsePersistedQsettings() but through QTimer so it happens after
    # the QApplication eventloop has started as to ensure resizing according to persisted
    # font size is done properly
    QTimer.singleShot(1000, HKLguiobj.UsePersistedQsettings)
    # For regression tests close us after a specified time
    if closingtime:
      QTimer.singleShot(closingtime, HKLguiobj.closeEvent)

    if isembedded:
      return HKLguiobj

    ret = app.exec_()

  except Exception as e:
    print( str(e)  +  traceback.format_exc(limit=10) )


 *******************************************************************************


 *******************************************************************************
crys3d/hklviewer/__init__.py


 *******************************************************************************


 *******************************************************************************
crys3d/hklviewer/chimeraX_wheel_src/__init__.py
from __future__ import division
from chimerax.core.toolshed import BundleAPI


# Subclass from chimerax.core.toolshed.BundleAPI and
# override the method for registering commands,
# inheriting all other methods from the base class.
class _MyAPI(BundleAPI):

    api_version = 1     # start_tool called with BundleInfo and
                        # ToolInfo instance (vs. BundleInfo and
                        # tool name when api_version==0 [the default])

    # Override method
    @staticmethod
    def start_tool(session, bi, ti):
        # session is an instance of chimerax.core.session.Session
        # bi is an instance of chimerax.core.toolshed.BundleInfo
        # ti is an instance of chimerax.core.toolshed.ToolInfo

        # This method is called once for each time the tool is invoked.

        # We check the name of the tool, which should match one of the
        # ones listed in bundle_info.xml (without the leading and
        # trailing whitespace), and create and return an instance of the
        # appropriate class from the ``tool`` module.
        if ti.name == "cctbx.HKLviewer":
            from . import tool
            return tool.HKLviewerTool(session, ti.name)
        raise ValueError("trying to start unknown tool: %s" % ti.name)

    @staticmethod
    def get_class(class_name):
        # class_name will be a string
        if class_name == "HKLviewerTool":
            from . import tool
            return tool.HKLviewerTool
        raise ValueError("Unknown class name '%s'" % class_name)

# Create the ``bundle_api`` object that ChimeraX expects.
bundle_api = _MyAPI()


 *******************************************************************************


 *******************************************************************************
crys3d/hklviewer/chimeraX_wheel_src/tool.py
from __future__ import division

# === UCSF ChimeraX Copyright ===
# Copyright 2016 Regents of the University of California.
# All rights reserved.  This software provided pursuant to a
# license agreement containing restrictions on its disclosure,
# duplication and use.  For details see:
# http://www.rbvi.ucsf.edu/chimerax/docs/licensing.html
# This notice must be embedded in or attached to all copies,
# including partial copies, of the software or any revisions
# or derivations thereof.
# === UCSF ChimeraX Copyright ===

from chimerax.core.tools import ToolInstance
import math

class HKLviewerTool(ToolInstance):

    # Inheriting from ToolInstance makes us known to the ChimeraX tool mangager,
    # so we can be notified and take appropriate action when sessions are closed,
    # saved, or restored, and we will be listed among running tools and so on.
    #
    # If cleaning up is needed on finish, override the 'delete' method
    # but be sure to call 'delete' from the superclass at the end.
    SESSION_ENDURING = False    # Does this instance persist when session closes
    SESSION_SAVE = True         # We do save/restore in sessions
    help = "help:user/tools/tutorial.html"
                                # Let ChimeraX know about our help page


    def __init__(self, session, tool_name):
        # 'session'   - chimerax.core.session.Session instance
        # 'tool_name' - string

        # Initialize base class.
        super().__init__(session, tool_name)

        # Set name displayed on title bar (defaults to tool_name)
        # Must be after the superclass init, which would override it.
        self.display_name = "HKLviewer"
        # Create the main window for our tool.  The window object will have
        # a 'ui_area' where we place the widgets composing our interface.
        # The window isn't shown until we call its 'manage' method.
        #
        # Note that by default, tool windows are only hidden rather than
        # destroyed when the user clicks the window's close button.  To change
        # this behavior, specify 'close_destroys=True' in the MainToolWindow
        # constructor.
        from chimerax.ui import MainToolWindow
        self.tool_window = MainToolWindow(self)

        # We will be adding an item to the tool's context menu, so override
        # the default MainToolWindow fill_context_menu method
        self.tool_window.fill_context_menu = self.fill_context_menu

        # Our user interface is simple enough that we could probably inline
        # the code right here, but for any kind of even moderately complex
        # interface, it is probably better to put the code in a method so
        # that this __init__ method remains readable.
        self._build_ui()
        self.clipper_crystdict = None
        session.HKLviewer = self

    def _build_ui(self):
        # Put our widgets in the tool window

        # We will use an editable single-line text input field (QLineEdit)
        # with a descriptive text label to the left of it (QLabel).  To
        # arrange them horizontally side by side we use QHBoxLayout
        from Qt.QtWidgets import QHBoxLayout
        from . import HKLviewer

        hbox = QHBoxLayout()
        self.Guiobj = HKLviewer.run(isembedded=True, chimeraxsession=self.session)
        hbox.addWidget(self.Guiobj.window)
        self.tool_window.ui_area.setLayout(hbox)
        # Show the window on the user-preferred side of the ChimeraX
        # main window
        self.tool_window.manage('side')

    def isolde_clipper_data_to_dict(self):
        try:
            sh = self.session.isolde.selected_model.parent
            xmapset = sh.map_mgr.xmapsets[0]
            clipperlabel= list(xmapset.experimental_data.items())[0][0]
            labels = [lbl.strip() for lbl in clipperlabel.split(",")]
            self.clipper_crystdict = {}
            self.clipper_crystdict["spg_number"] = xmapset.spacegroup.spacegroup_number
            self.clipper_crystdict["unit_cell"] =  (xmapset.unit_cell.cell.a, xmapset.unit_cell.cell.b, xmapset.unit_cell.cell.c,
               xmapset.unit_cell.cell.alpha*180/math.pi, xmapset.unit_cell.cell.beta*180/math.pi, xmapset.unit_cell.cell.gamma*180/math.pi)
            self.clipper_crystdict["HKL"] = xmapset.experimental_data[clipperlabel].data.data[0].tolist()
            self.clipper_crystdict[clipperlabel] = xmapset.experimental_data[clipperlabel].data.data[1].transpose().tolist()
            self.clipper_crystdict["FCALC,PHFCALC"] = xmapset.live_xmap_mgr.f_calc.data[1].transpose().tolist()
            self.clipper_crystdict["2FOFC,PH2FOFC"] = xmapset.live_xmap_mgr.base_2fofc.data[1].transpose().tolist()
        except Exception as e:
            pass


    def return_pressed(self):
        # The use has pressed the Return key; log the current text as HTML
        from chimerax.core.commands import run
        # ToolInstance has a 'session' attribute...
        run(self.session, "log html %s" % self.line_edit.text())

    def fill_context_menu(self, menu, x, y):
        # Add any tool-specific items to the given context menu (a QMenu instance).
        # The menu will then be automatically filled out with generic tool-related actions
        # (e.g. Hide Tool, Help, Dockable Tool, etc.)
        #
        # The x,y args are the x() and y() values of QContextMenuEvent, in the rare case
        # where the items put in the menu depends on where in the tool interface the menu
        # was raised.
        from PyQt5.QtWidgets import QAction
        settings_action = QAction("HKLviewer settings", menu)
        settings_action.triggered.connect(lambda *args: self.Guiobj.SettingsDialog() )
        menu.addAction(settings_action)

    def delete(self):
      from Qt.QtCore import QEvent
      self.session.triggers.remove_handler(self.Guiobj.chimeraxprocmsghandler)
      self.Guiobj.closeEvent(QEvent.Close)
      super(HKLviewerTool, self).delete()

    def take_snapshot(self, session, flags):
        return {
            'version': 1,
            'current text': self.line_edit.text()
        }

    @classmethod
    def restore_snapshot(class_obj, session, data):
        # Instead of using a fixed string when calling the constructor below, we could
        # have saved the tool name during take_snapshot() (from self.tool_name, inherited
        # from ToolInstance) and used that saved tool name.  There are pros and cons to
        # both approaches.
        inst = class_obj(session, "cctbx.HKLviewer")
        inst.line_edit.setText(data['current text'])
        return inst


 *******************************************************************************


 *******************************************************************************
crys3d/hklviewer/cmdlineframes.py
from __future__ import absolute_import, division, print_function
from libtbx.utils import Sorry
import sys, os.path, traceback


def run(args=""):
  try:
    """
    utility function for passing keyword arguments more directly to hklview_frame.HKLViewFrame()
    """
    from crys3d.hklviewer import hklview_frame
    from crys3d.hklviewer.jsview_3d import HKLviewerError as HKLviewerError
    #import time; time.sleep(15) # enough for attaching debugger
    # dirty hack for parsing a file path with spaces of a browser if not using default
    if args == "":
      args = sys.argv[1:]
    sargs = " ".join(args)
    qchar = "'"
    if sargs.find("'") > -1:
      quote1 = sargs.find(qchar)
      if sargs[ quote1 + 1:].find(qchar) < 0:
        raise Sorry("Missing quote in arguments")
      quote2 = sargs[ quote1 + 1:].find(qchar) + quote1 + 1
      space1 = sargs[ :quote1].rfind(" ")
      arg = sargs[space1 +1: quote2 +1]
      sargs2 = sargs.replace(arg,"")
      args = sargs2.split(" ")
      arg = arg.replace("'","")
      arg = arg.replace('"',"")
      arg = arg.replace('\\', '/') # webbrowser module wants browser paths having unix forward slashes
      args.append(arg)

    kwargs = dict(arg.split('=') for arg in args if '=' in arg)
    sysargs = []
    #check if any argument is a filename
    for arg in args:
      if '=' not in arg:
      # if so add it as a keyword argument
        if os.path.isfile(arg):
          if not kwargs.get('hklin', False):
            kwargs['hklin'] = arg
          else: # a philfile
            kwargs['phil_file'] = arg
        else:
          sysargs.append(arg)

    myHKLview = hklview_frame.HKLViewFrame(*sysargs, **kwargs)
    return myHKLview # only necessary for aiding debugging or line profiling
  except HKLviewerError as e:
    print( str(e) + "\n" + traceback.format_exc(limit=10))
    raise # pass on to caller
  except Exception as e:
    print( str(e) + "\n" + traceback.format_exc(limit=10))
    return 0


if __name__ == '__main__':
  myHKLview = run()


 *******************************************************************************


 *******************************************************************************
crys3d/hklviewer/default_user_preset_buttons.py
from __future__ import absolute_import, division, print_function

# Template file for user preset buttons for the HKLviewer. To be placed
# in the users HOME directory.
# Additional buttons can be defined by copying current formatted PHIL
# output into new button elements in the list below. Obtain current
# formatted PHIL output from the settings dialog in the HKLviewer
# for the way in which reflections are currently shown


buttonsdeflist = [
# Simple button displaying sigmas of an intensity dataset. Uncomment lines below to take effect
#
# ("ShowSigmaI", "Show SigI", """
#                            viewer {
#                              data_array {
#                                label = "IOBS,SIGIOBS"
#                                datatype = "Intensity"
#                              }
#                            }
#                            hkls {
#                              sigma_color_radius = True
#                            }
#  """
#  ),
]


 *******************************************************************************


 *******************************************************************************
crys3d/hklviewer/display2.py

# TODO:
#  - cached scenes

from __future__ import absolute_import, division, print_function
from libtbx.utils import Sorry, to_str
from cctbx import miller
from cctbx import crystal
from cctbx.array_family import flex
import libtbx.phil
from scitbx import graphics_utils
from libtbx import object_oriented_patterns as oop # causes crash in easy_mp.multi_core_run
import math, traceback
import math, sys
from six.moves import zip

import matplotlib as mpl
import matplotlib.pyplot as plt
from matplotlib import cm

class MplColorHelper:
  def __init__(self, cmap_name, start_val, stop_val):
    self.cmap_name = cmap_name
    self.cmap = plt.get_cmap(cmap_name)
    self.norm = mpl.colors.Normalize(vmin=start_val, vmax=stop_val)
    self.scalarMap = cm.ScalarMappable(norm=self.norm, cmap=self.cmap)
  def get_rgb(self, val):
    rgba = self.scalarMap.to_rgba(val)
    return rgba[0], rgba[1], rgba[2], rgba[3]


nanval = float('nan')
inanval = -42424242 # TODO: find a more robust way of indicating missing flex.int data



def generate_systematic_absences(array,
                                  expand_to_p1=False,
                                  generate_bijvoet_mates=False):
  from cctbx import crystal
  sg = array.space_group()
  base_symm = crystal.symmetry(
    unit_cell=array.unit_cell(),
    space_group=sg.build_derived_reflection_intensity_group(False))
  base_array = array.customized_copy(crystal_symmetry=base_symm)
  complete_set = base_array.complete_set().customized_copy(
    crystal_symmetry=array.crystal_symmetry())
  absence_array = complete_set.sys_absent_flags()
  if (generate_bijvoet_mates):
    absence_array = absence_array.generate_bijvoet_mates()
  if (expand_to_p1):
    absence_array = absence_array.expand_to_p1().customized_copy(
      crystal_symmetry=array.crystal_symmetry())
      #niggli_cell().expand_to_p1()
  return absence_array


def nth_power_scale(dataarray, nth_power, is_sigmas=False):
  """
  set nth_power to a number for dampening or enhancing the
  difference between the smallest and the largest values.
  A negative number means that a large data value is rendered with a smaller radius than
  a small data value. For nth_power=0 all data values are rendered with the same radius
  For nth_power=1 data values are rendered with radii proportional to the data values.
  If nth_power=NaN then an automatic value is computed that maps the smallest
  values to 0.1 of the largest values
  """
  if type(dataarray) == flex.complex_double:
    dataarray = flex.abs( dataarray)
  maxdat = flex.max(dataarray)
  mindat = flex.min(dataarray)
  offset = mindat - 0.001 # avoid log(0)
  offsetmin = mindat - offset
  offsetmax = maxdat - offset
  offsetarr = dataarray.as_double() - offset # double in case dataarray are ints
  # only autoscale for sensible values of maxdat and mindat
  if math.isnan(nth_power) and maxdat > mindat : # amounts to automatic scale
    nth_power = math.log(10)/(math.log(offsetmax) - math.log(offsetmin))
    if is_sigmas:
      nth_power *= -1.0 # want small sigmas to have larger radii and large sigmas to have smaller radii
  datascaled = flex.pow(offsetarr, nth_power)
  return datascaled, nth_power


def nth_power_scale2(dataarray, nth_power, m=10.0, is_sigmas=False):
  """
  set nth_power to a number for dampening or enhancing the
  difference between the smallest and the largest values.
  A negative number means that a large data value is rendered with a smaller radius than
  a small data value. For nth_power=0 all data values are rendered with the same radius
  For nth_power=1 data values are rendered with radii proportional to the data values.
  If nth_power=NaN then an automatic value is computed that maps the smallest
  values to 0.1 of the largest values
  """
  if type(dataarray) == flex.complex_double:
    dataarray = flex.abs( dataarray)
  maxdat = flex.max(dataarray)
  mindat = flex.min(dataarray)
  offset = mindat - 0.001 # avoid log(0)
  offsetmin = mindat - offset
  offsetmax = maxdat - offset
  offsetarr = dataarray.as_double() - offset
  offsetarr = offsetarr/(maxdat - mindat)
  # only autoscale for sensible values of maxdat and mindat
  if math.isnan(nth_power) and maxdat > mindat : # amounts to automatic scale
    nth_power = math.log(10)/(math.log(offsetmax) - math.log(offsetmin))
    if is_sigmas:
      nth_power *= -1.0 # want small sigmas to have larger radii and large sigmas to have smaller radii
  datascaled = flex.pow(offsetarr, nth_power)
  datascaled = (datascaled + (1.0/(m-1.0))) * ((m-1.0)/m)
  return datascaled, nth_power


def ExtendMillerArray(miller_array, nsize, indices=None ):
  millarray = miller_array.deep_copy()
  if indices:
    assert (indices.size()==nsize)
    millarray._indices.extend( indices )
  if millarray.sigmas() is not None:
    millarray._sigmas.extend( flex.double(nsize, nanval) )
  millarray._data = ExtendAnyData(millarray._data, nsize)
  return millarray


def ExtendAnyData(data, nsize):
  if isinstance(data, flex.bool):
    # flex.bool cannot be extended with NaN so cast the data to ints and extend with inanval instead
    data = data.as_int().extend( flex.int(nsize, inanval) )
  if isinstance(data, flex.hendrickson_lattman):
    data.extend( flex.hendrickson_lattman(nsize, (nanval, nanval, nanval, nanval)) )
  if isinstance(data, flex.int) or isinstance(data, flex.long) \
        or isinstance(data, flex.size_t):
    data.extend( flex.int(nsize, inanval) )
  if isinstance(data, flex.float) or isinstance(data, flex.double):
    data.extend( flex.double(nsize, nanval) )
  if isinstance(data, flex.complex_double):
    data.extend( flex.complex_double(nsize, nanval) )
  if isinstance(data, flex.vec3_double):
    data.extend( flex.vec3_double(nsize, (1.,1.,1.)) )
  return data


def MergeData(inputarray, show_anomalous_pairs=False):
  merge = inputarray.deep_copy().merge_equivalents()
  multiplicities = merge.redundancies()
  array = merge.array()
  if not show_anomalous_pairs and array.anomalous_flag():
    asu, matches = multiplicities.match_bijvoet_mates()
    mult_plus, mult_minus = multiplicities.hemispheres_acentrics()
    anom_mult = flex.int(
      min(p, m) for (p, m) in zip(mult_plus.data(), mult_minus.data()))
    # Got acentric multiplicities. Get the centric multiplicities
    matches = array.match_bijvoet_mates()[1]
    sel_sp = matches.singles("+")
    centrics = multiplicities.select( sel_sp)
    # TODO: fix needed for obtaining the correct number of indices in the asu
    # when merging unmerged data
    multiplicities = miller.array(
      miller.set(asu.crystal_symmetry(),
                 flex.miller_index(list(mult_plus._indices) + list(centrics._indices) ) ,
                 anomalous_flag=False), flex.int(list(anom_mult) + list(centrics.data()) ))
    multiplicities = multiplicities.select(
      multiplicities.data() >= 0)

    array = array.average_bijvoet_mates()
  return array, multiplicities, merge


class scene(object):
  """
  Data for visualizing a Miller array graphically, either as a 3D view or
  a 2D zone of reciprocal space.  Currently used in phenix.data_viewer, but
  easily extensible to any other graphics platform (e.g. a PNG embedded in
  a web page).
  """
  def __init__(self, miller_array, settings, merge=None, renderscale=100, foms_array=None,
   fullprocessarray=True, mprint=sys.stdout.write):
    self.miller_array = miller_array
    self.renderscale = renderscale
    self.foms_workarray = foms_array
    self.SceneCreated = False
    self.mprint = mprint
    #if isinstance(miller_array.data(), flex.std_string):
    #  return
    if type(miller_array.data()) not in [flex.double, flex.int,
                                  flex.hendrickson_lattman, flex.float,
                                  flex.complex_double]:
      return
    self.settings = settings
    self.merge_equivalents = False
    if not self.miller_array.is_unique_set_under_symmetry():
      self.merge_equivalents = merge
    self.multiplicities = None
    self.fomlabel = ""
    self.foms = flex.double(self.miller_array.size(), float('nan'))
    self._is_using_foms = False
    self.fullprocessarray = fullprocessarray
    if self.miller_array.is_complex_array():
      # Colour map coefficient as a circular rainbow with saturation as a function of FOMs
      # process the foms miller array and store the foms data for later use when computing colours
      if foms_array:
        assert ( self.miller_array.size() == foms_array.size() )
        self.foms_workarray, dummy = self.process_input_array(foms_array)
        if not self.foms_workarray:
          return
        self.foms = self.foms_workarray.data()
        self.fomlabel = foms_array.info().label_string()
        self._is_using_foms = True
    self.work_array, self.multiplicities = self.process_input_array(self.miller_array)
    if not self.work_array:
      return
    array = self.work_array
    uc = array.unit_cell()
    self.unit_cell = uc
    self.slice_selection = None
    self.axis_index = None
    if (settings.slice_mode):
      self.axis_index = ["h","k","l"].index(self.settings.slice_axis)
      self.slice_selection = miller.simple_slice(
        indices=array.indices(),
        slice_axis=self.axis_index,
        slice_index=settings.slice_index)
      #if (self.slice_selection.count(True) == 0):
        #raise ValueError("No data selected!")
    index_span = array.index_span()
    self.colourlabel = self.miller_array.info().label_string()
    self.d_min = array.d_min()
    self.min_dist = 0.0
    self.nth_power_scale_radii = settings.nth_power_scale_radii
    self.hkl_range = index_span.abs_range()
    self.axes = [ uc.reciprocal_space_vector((self.hkl_range[0],0,0)),
                  uc.reciprocal_space_vector((0,self.hkl_range[1],0)),
                  uc.reciprocal_space_vector((0,0,self.hkl_range[2])) ]
    self.generate_view_data()
    if (self.slice_selection is not None):
      self.indices = self.work_array.indices().select(self.slice_selection).deep_copy()
      self.data = self.data.select(self.slice_selection)
      self.phases = self.phases.select(self.slice_selection)
      self.radians = self.radians.select(self.slice_selection)
      self.ampl = self.ampl.select(self.slice_selection)
      if self.sigmas:
        self.sigmas = self.sigmas.select(self.slice_selection)
      if foms_array:
        self.foms = self.foms.select(self.slice_selection)
    else :
      self.indices = array.indices()
    self.points = uc.reciprocal_space_vector(self.indices) * self.renderscale
    n_points = self.points.size()
    if not fullprocessarray:
      self.radii = flex.double()
      self.radii = ExtendAnyData(self.radii, n_points)
      self.colors = flex.vec3_double()
      self.colors = ExtendAnyData(self.colors, n_points)
    self.missing_flags = flex.bool(self.radii.size(), False)
    self.sys_absent_flags = flex.bool(self.radii.size(), False)
    if (settings.show_missing):
      self.generate_missing_reflections()
    if (settings.show_systematic_absences) and (not settings.show_only_missing):
      self.generate_systematic_absences()
    n_points = self.points.size()
    assert (self.colors.size() == n_points)
    assert (self.indices.size() == n_points)
    assert (self.radii.size() == n_points)
    assert (self.missing_flags.size() == n_points)
    assert (self.sys_absent_flags.size() == n_points)
    assert (self.data.size() == n_points)
    assert (self.phases.size() == n_points)
    assert (self.radians.size() == n_points)
    assert (self.ampl.size() == n_points)
    if self.sigmas:
      assert (self.sigmas.size() == n_points)
    if foms_array:
      assert (self.foms.size() == n_points)
    else:
      self.foms = flex.double(n_points, float('nan'))
    self.dres = uc.d(self.indices )
    self.SceneCreated = True


  def process_input_array(self, arr):
    array = arr.deep_copy()
    work_array = arr
    multiplicities = None
    try:
      if self.merge_equivalents :
        array, multiplicities, merge = MergeData(array, self.settings.show_anomalous_pairs)
      settings = self.settings
      data = array.data()
      #import code, traceback; code.interact(local=locals(), banner="".join( traceback.format_stack(limit=10) ) )
      self.missing_set = oop.null()
      #if (array.is_xray_intensity_array()):
      #  data.set_selected(data < 0, flex.double(data.size(), 0.))
      self.filtered_array = array.deep_copy()
      if (settings.expand_anomalous):
        if not array.is_unique_set_under_symmetry():
          raise Sorry("Error! Cannot generate bijvoet mates of unmerged reflections.")
        array = array.generate_bijvoet_mates()
        original_symmetry = array.crystal_symmetry()

        if (multiplicities is not None):
          multiplicities = multiplicities.generate_bijvoet_mates()
      if (self.settings.show_missing):
        self.missing_set = array.complete_set().lone_set(array)
        if self.settings.show_anomalous_pairs:
          self.missing_set = self.missing_set.select(
            self.missing_set.centric_flags().data(), negate=True)
      if (settings.expand_to_p1):
        if not array.is_unique_set_under_symmetry():
          raise Sorry("Error! Cannot expand unmerged reflections to P1.")
        original_symmetry = array.crystal_symmetry()
        array = array.expand_to_p1().customized_copy(
          crystal_symmetry=original_symmetry)
        #array = array.niggli_cell().expand_to_p1()
        #self.missing_set = self.missing_set.niggli_cell().expand_to_p1()
        self.missing_set = self.missing_set.expand_to_p1().customized_copy(
          crystal_symmetry=original_symmetry)
        if (multiplicities is not None):
          multiplicities = multiplicities.expand_to_p1().customized_copy(
              crystal_symmetry=original_symmetry)
      data = array.data()
      self.r_free_mode = False
      self.phases = flex.double(data.size(), float('nan'))
      self.radians = flex.double(data.size(), float('nan'))
      self.ampl = flex.double(data.size(), float('nan'))
      self.sigmas = None
      self.singletonsiness = flex.double(data.size(), 0.0 )
      if isinstance(data, flex.bool):
        self.r_free_mode = True
        data_as_float = flex.double(data.size(), 0.0)
        data_as_float.set_selected(data==True, flex.double(data.size(), 1.0))
        data = data_as_float
        self.data = data #.deep_copy()
      else :
        if isinstance(data, flex.double):
          self.data = data #.deep_copy()
        elif isinstance(data, flex.hendrickson_lattman):
          # for now display HL coefficients as a simple sum
          self.data = flex.double( [a+b+c+d for a,b,c,d in data] )
        elif isinstance(data, flex.complex_double):
          self.data = data #.deep_copy()
          self.ampl = flex.abs(data)
          self.phases = flex.arg(data) * 180.0/math.pi
          # purge nan values from array to avoid crash in fmod_positive()
          #b = flex.bool([bool(math.isnan(e)) for e in self.phases])
          b = graphics_utils.IsNansArray( self.phases )
          # replace the nan values with an arbitrary float value
          self.phases = self.phases.set_selected(b, 42.4242)
          # Cast negative degrees to equivalent positive degrees
          self.phases = flex.fmod_positive(self.phases, 360.0)
          self.radians = flex.arg(data)
          # replace the nan values with an arbitrary float value
          self.radians = self.radians.set_selected(b, 0.424242)
        elif hasattr(array.data(), "as_double"):
          self.data = data
        else:
          raise RuntimeError("Unexpected data type: %r" % data)
        if array.sigmas() is not None:
          self.sigmas = array.sigmas()
        else:
          self.sigmas = None
      if array.anomalous_flag() and array.is_unique_set_under_symmetry():
        # Label singletons with 1 or -1 if any. True singletons are only acentric
        self.singletonsiness.set_selected( array.select_acentric().match_bijvoet_mates()[1].singles("+"), 1.0 )
        self.singletonsiness.set_selected( array.select_acentric().match_bijvoet_mates()[1].singles("-"), -1.0 )
      work_array = array
    except Exception as e:
      self.mprint(to_str(e) + "".join(traceback.format_stack(limit=10)))
      raise e
      return None, None
    work_array.set_info(arr.info() )
    multiplicities = multiplicities
    return work_array, multiplicities


  def generate_view_data(self):
    from scitbx.array_family import flex
    settings = self.settings
    data_for_colors = data_for_radii = None
    if not self.fullprocessarray:
      return
    data = self.data #self.work_array.data()
    sigmas = self.sigmas
    if (isinstance(data, flex.double) and data.all_eq(0)):
      data = flex.double(data.size(), 1)
    if isinstance(data, flex.complex_double):
      data_for_colors = self.phases
      foms_for_colours = self.foms
       # assuming last part of the labels indicates the phase label as in ["FCALC","PHICALC"]
      self.colourlabel = "Phase of " + self.miller_array.info().label_string()
    elif (settings.sigma_color_radius) and sigmas is not None:
      data_for_colors = 1.0/sigmas.as_double()
      self.colourlabel = "Sigma of " + self.miller_array.info().label_string()
    else :
      data_for_colors = flex.abs(data.deep_copy())

    uc = self.work_array.unit_cell()
    self.min_dist = min(uc.reciprocal_space_vector((1,1,1))) * self.renderscale
    min_radius = 0.05 * self.min_dist
    max_radius = 0.5 * self.min_dist
    if (settings.sigma_color_radius) and sigmas is not None:
      data_for_radii, self.nth_power_scale_radii = nth_power_scale2(sigmas.as_double().deep_copy(),
                                       settings.nth_power_scale_radii, is_sigmas=True)
    else :
      data_for_radii, self.nth_power_scale_radii = nth_power_scale2(data.deep_copy(),
                                       settings.nth_power_scale_radii)
    if (settings.slice_mode):
      data = data.select(self.slice_selection)
    # Computing rgb colours of each reflection is slow so make a small array
    # of precomputed colours to use as a lookup table for each reflection
    if isinstance(data, flex.complex_double): # map coefficients are coloured by phase values
      COL = MplColorHelper(settings.color_scheme, 0, 360)
      rgbcolarray = [ COL.get_rgb(d)[0:3] for d in range(360) ]
      if self.isUsingFOMs():
        colors = graphics_utils.map_to_rgb_colourmap(
          data_for_colors=data_for_colors,
          colormap=rgbcolarray,
          selection=flex.bool(data_for_colors.size(), True),
          attenuation = foms_for_colours,
          map_directly=True,
          color_all=False
          )
      else:
        colors = graphics_utils.map_to_rgb_colourmap(
          data_for_colors=data_for_colors,
          colormap=rgbcolarray,
          selection=flex.bool(data_for_colors.size(), True),
          attenuation = None,
          map_directly=True,
          color_all=False
          )
    else:
      # Use a colour gradient from matplotlib
      COL = MplColorHelper(settings.color_scheme, 0, 199)
      colorgradientarray = flex.vec3_double([COL.get_rgb(d)[0:3] for d in range(200) ])
      # Do the table lookup in C++ for speed improvement
      colors = graphics_utils.map_to_rgb_colourmap(
        data_for_colors=data_for_colors,
        colormap=colorgradientarray,
        selection=flex.bool(data_for_colors.size(), True),
        powscale = settings.color_powscale,
        attenuation = None,
        color_all=False
        )

    if (settings.slice_mode):
      colors = colors.select(self.slice_selection)
      data_for_radii = data_for_radii.select(self.slice_selection)
    if len(data_for_radii):
      dat2 = flex.double( graphics_utils.NoNansArray( data_for_radii, 0.1 ) )
      # don't divide by 0 if dealing with selection of Rfree array where all values happen to be zero
      scale = max_radius/(flex.max(dat2) + 0.001)
      radii = data_for_radii * (self.settings.scale * scale)
      assert radii.size() == colors.size()
    else:
      radii = flex.double()
      max_radius = 0
    self.radii = radii
    self.max_radius = max_radius
    self.min_radius = min_radius
    self.colors = colors
    if isinstance(data, flex.complex_double):
      self.foms = foms_for_colours


  def isUsingFOMs(self):
    #return len([e for e in self.foms if math.isnan(e)]) != self.foms.size()
    return self._is_using_foms


  def ExtendData(self, nextent):
    self.data = ExtendAnyData(self.data, nextent )
    self.phases = ExtendAnyData(self.phases, nextent )
    self.ampl = ExtendAnyData(self.ampl, nextent )
    self.foms = ExtendAnyData(self.foms, nextent )
    self.radians = ExtendAnyData(self.radians, nextent )
    if self.sigmas is not None:
      self.sigmas = ExtendAnyData(self.sigmas, nextent)


  def generate_missing_reflections(self):
    from cctbx import miller
    from cctbx.array_family import flex
    settings = self.settings
    array = self.work_array
    uc = array.unit_cell()
    if (settings.show_only_missing):
      self.colors = flex.vec3_double()
      self.points = flex.vec3_double()
      self.radii = flex.double()
      self.missing_flags = flex.bool()
      self.indices = flex.miller_index()
      self.data = flex.double()
      self.phases = flex.double()
      self.ampl = flex.double()
      self.foms = flex.double()
      self.radians = flex.double()
      if self.sigmas is not None:
        self.sigmas = flex.double()
      self.sys_absent_flags = flex.bool()
    if (settings.slice_mode):
      slice_selection = miller.simple_slice(
        indices=self.missing_set.indices(),
        slice_axis=self.axis_index,
        slice_index=settings.slice_index)
      missing = self.missing_set.select(slice_selection).indices()
    else :
      missing = self.missing_set.indices()
    n_missing = missing.size()
    if (n_missing > 0):
      points_missing = uc.reciprocal_space_vector(missing) * 100.
      self.points.extend(points_missing)
      if (settings.color_scheme == "heatmap"):
        self.colors.extend(flex.vec3_double(n_missing, (0.,1.,0.)))
      elif (not settings.color_scheme in ["rainbow","redblue"]):
        self.colors.extend(flex.vec3_double(n_missing, (1.,0,0)))
      else :
        self.colors.extend(flex.vec3_double(n_missing, (1.,1.,1.)))
      self.radii.extend(flex.double(n_missing, self.settings.scale * self.max_radius/2.0 ))
      self.missing_flags.extend(flex.bool(n_missing, True))
      self.indices.extend(missing)
      self.ExtendData(n_missing)
      self.sys_absent_flags.extend(flex.bool(n_missing, False))


  def generate_systematic_absences(self):
    from cctbx import miller
    from cctbx import crystal
    from cctbx.array_family import flex
    settings = self.settings
    array = self.filtered_array # XXX use original array here!
    absence_array = generate_systematic_absences(
      array=self.filtered_array,
      expand_to_p1=settings.expand_to_p1,
      generate_bijvoet_mates=settings.expand_anomalous)
    if (settings.slice_mode):
      slice_selection = miller.simple_slice(
        indices=absence_array.indices(),
        slice_axis=self.axis_index,
        slice_index=settings.slice_index)
      absence_array = absence_array.select(slice_selection)
    absence_flags = absence_array.data()
    if (absence_flags.count(True) == 0):
      self.mprint("No systematic absences found!")
    else :
      new_indices = flex.miller_index()
      for i_seq in absence_flags.iselection():
        hkl = absence_array.indices()[i_seq]
        #if (hkl in self.indices):
        #  j_seq = self.indices.index(hkl)
        #  self.colors[j_seq] = (1.0, 0.5, 1.0)
        #  self.radii[j_seq] = self.max_radius
        #  self.missing_flags[j_seq] = False
        #  self.sys_absent_flags[j_seq] = True
        #else :
        if hkl in self.indices:
          self.mprint("Systematically absent reflection %s is unexpectedly present in %s" %(hkl, array.info().label_string()) )
        else:
          new_indices.append(hkl)
      if (new_indices.size() > 0):
        uc = self.work_array.unit_cell()
        points = uc.reciprocal_space_vector(new_indices) * 100
        self.points.extend(points)
        n_sys_absent = new_indices.size()
        self.radii.extend(flex.double(new_indices.size(), self.max_radius/2.0))
        self.indices.extend(new_indices)
        self.missing_flags.extend(flex.bool(new_indices.size(), False))
        self.sys_absent_flags.extend(flex.bool(new_indices.size(), True))
        self.ExtendData(n_sys_absent)
        if (settings.color_scheme == "redblue"):
          self.colors.extend(flex.vec3_double(new_indices.size(), (1.,1.0,0.)))
        else :
          self.colors.extend(flex.vec3_double(new_indices.size(), (1.,0.5,1.)))


# list of all colour maps from https://matplotlib.org/examples/color/colormaps_reference.html
colormaps = " ".join(plt.colormaps())
# set the default selected colour map to "brg" for phil attribute "color_scheme" below
colormaps = colormaps.replace("brg ", "*brg ")

philstr = """
  nth_power_scale_radii = 0.0
    .type = float
    .help = "A number for dampening or enhancing the difference between the smallest and the largest values. "
            "A negative number means that a large data value is rendered with a smaller radius than "
            "a small data value will be. For nth_power_scale_radii=0 all data values are rendered with "
            "the same radius. For nth_power_scale_radii=1 data values are rendered with radii proportional "
            "to the data values. If nth_power_scale_radii=NaN an automatic value is computed that maps the "
            "smallest values to 0.1 of the largest values."
  scale = 1
    .type = float
    .help = "Increase/decrease radii with this factor."
  sigma_color_radius = False
    .type = bool
    .help = "If set to True then colour mapping is based on sigma values if dataset contains sigmas."
  expand_to_p1 = False
    .type = bool
    .help = "Expand data to P1."
  expand_anomalous = False
    .type = bool
    .help = "Expand data to Friedel pairs."
  show_missing = False
    .type = bool
    .help = "Show those reflections within the highest resolution sphere that are missing from the dataset."
  show_only_missing = False
    .type = bool
  show_systematic_absences = False
    .type = bool
  slice_mode = False
    .type = bool
    .help = "Deprecated: Show only a slice of reflections. Superseeded by applying clip planes."
  slice_axis = *h k l
    .type = choice
    .help = "Deprecated: Show only a slice of reflections. Superseeded by applying clip planes."
  slice_index = 0
    .type = int
    .help = "Deprecated: Show only a slice of reflections. Superseeded by applying clip planes."
  color_scheme = %s
    .type = choice(multi=False)
    .help = "The selected colour scheme for colouring reflections. These are all defined by MatPlotLib."
  color_powscale = 1.0
    .type = float
    .help = "color_powscale skews the colour mapping towards the smaller data values for color_powscale > 1"
            "but skews it towards the larger data values for 0 < powscale < 1. Typically for intensity data a"
            "value around 0.25 is appropriate for emphasizing differences between stronger and weaker data."
            "For amplitude data a value of around 0.5 is better. When displaying"
            "map coefficients where complex values are converted into amplitudes and phases color_powscale "
            "remains equal to 1."
  show_anomalous_pairs = False
    .type = bool
    .help = "Internal use only. Applies when merging data."
""" %colormaps

master_phil = libtbx.phil.parse( philstr )
params = master_phil.fetch().extract()

def reset_settings():
  """
  Reset all display settings to their default values as specified in the phil definition string
  """
  global master_phil
  global philstr
  global params
  params = master_phil.fetch(source = libtbx.phil.parse( philstr) ).extract()


def settings():
  """
  Get a global phil parameters object containing the display settings
  """
  global params
  return params


 *******************************************************************************


 *******************************************************************************
crys3d/hklviewer/helpers.py
from __future__ import absolute_import, division, print_function
# helper module for our own classes and widgets

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.figure import Figure

from .qt import QtWidgets
from .qt import Qt, QEvent, QAbstractTableModel, QModelIndex
from .qt import QCursor, QKeySequence, QLineEdit, QTextDocument
from .qt import ( QAbstractItemView, QCheckBox, QTableWidget, QAction, QDoubleSpinBox,
      QMenu, QTableView, QDialog, QSpinBox, QLabel, QComboBox, QGridLayout, QGroupBox,
      QScrollArea, QVBoxLayout, QHeaderView, QTableWidgetItem, QSizePolicy, QPlainTextEdit,
      QPushButton
     )
import math, csv, sys
from io import StringIO


class FindDialog(QDialog):
  def __init__(self, parent=None):
    super(FindDialog, self).__init__(parent)
    self.setWindowTitle("Find a string")
    self.setWindowFlags(Qt.Tool)
    mainLayout = QGridLayout()
    self.label = QLabel()
    self.label.setText("Enter search string")
    self.label.setWordWrap(True)
    self.findtextbox = QLineEdit()
    self.texteditclient = None
    sp = QSizePolicy(QSizePolicy.Preferred, QSizePolicy.Preferred)
    self.findtextbox.setSizePolicy(sp)
    self.label.setSizePolicy(sp)
    self.cancelbtn = QPushButton()
    self.cancelbtn.setText("Cancel")
    self.cancelbtn.clicked.connect(self.onCancel)
    self.findbtn = QPushButton()
    self.findbtn.setText("Find next")
    self.findbtn.clicked.connect(self.onFind)
    mainLayout.addWidget(self.label,  0, 0, 1, 3)
    mainLayout.addWidget(self.findtextbox,  1, 0, 1, 3)
    mainLayout.addWidget(self.findbtn,  2, 0, 1, 1)
    mainLayout.addWidget(self.cancelbtn,  2, 2, 1, 1)
    self.setLayout(mainLayout)
    self.setSizePolicy(sp)
    #self.setFixedSize( self.sizeHint() )
  def onFind(self):
    if self.texteditclient:
      cursor = self.texteditclient.textCursor()
      if not self.texteditclient.find(self.findtextbox.text(), QTextDocument.FindCaseSensitively):
        cursor.setPosition(0)
        self.texteditclient.setTextCursor(cursor) # wrap around if reached end of text
      self.texteditclient.activateWindow()
  def onCancel(self):
    self.hide()



class MyQPlainTextEdit(QPlainTextEdit):
  def __init__(self, parent=None):
    super(MyQPlainTextEdit,self).__init__(parent)
  def keyPressEvent(self, event):
    cursor = self.textCursor()
    if event.key() == Qt.Key_F and event.modifiers() == Qt.ControlModifier:
      cursor.setPosition(0)
      self.setTextCursor(cursor)
      # In order to use the same FindDialog for all MyQPlainTextEdit instances
      # self.finddlg is assigned to a FindDialog instance by NGL_HKLViewer.
      self.finddlg.texteditclient = self
      self.finddlg.show()
      self.finddlg.activateWindow()
    elif event.key() == Qt.Key_F3 and self.finddlg.findtextbox.text() != "":
      if not self.find(self.finddlg.findtextbox.text(), QTextDocument.FindCaseSensitively):
        cursor.setPosition(0)
        self.setTextCursor(cursor) # wrap around if reached end of text
    else:
      QPlainTextEdit.keyPressEvent(self, event)


class MyQDoubleSpinBox(QDoubleSpinBox):
  def __init__(self, parent=None):
    super(MyQDoubleSpinBox,self).__init__(parent)
  def stepBy(self, steps):
    QDoubleSpinBox.stepBy(self, steps)
    if hasattr(self, "onStepBy"):
      self.onStepBy()
  def mouseReleaseEvent(self, event):
    # used by NGL_HKLViewer.fontspinBox since changing fonts and resizing windows is slow and
    # valueChanged() will then mistakenly be fired twice when clicking once on the spin control
    QDoubleSpinBox.mouseReleaseEvent(self, event)
    if hasattr(self, "onMouseRelease"):
      self.onMouseRelease()


class MyhorizontalHeader(QHeaderView):
# Assigned to HeaderDataTableWidget (NGL_HKLViewer.millertable) but in
# NGL_HKLViewer.createFileInfoBox() as to avoid a very long chain of parents when
# accessing select_millertable_column_dlg()
# Display the labels of the columns in the millertable
# Right-clicking will invoke NGL_HKLViewer.select_millertable_column_dlg
  def __init__(self, parent=None):
    super(MyhorizontalHeader,self).__init__(Qt.Horizontal, parent)
    self.mousebutton = None
    self.parent = parent
    self.setSectionsClickable(True)
    self.setSectionsMovable(True)
    self.setToolTip("Right-click to specify which columns to show")
  def mousePressEvent(self, event):
    if event.type() == QEvent.MouseButtonPress:
      if event.button() == Qt.RightButton:
        self.parent.parent.onSelect_millertable_column_dlg()
    QHeaderView.mousePressEvent(self, event)


class HeaderDataTableWidget(QTableWidget):
  def __init__(self, *args, **kwargs):
    QTableWidget.__init__(self, *args, **kwargs)
    self.mousebutton = None
    self.selectedrows = []
  def mousePressEvent(self, event):
    if event.type() == QEvent.MouseButtonPress:
      self.mousebutton = None
      if event.button() == Qt.RightButton:
        self.mousebutton = Qt.RightButton
    QTableWidget.mousePressEvent(self, event)
  def mouseDoubleClickEvent(self, event):
    if event.type() == QEvent.MouseButtonDblClick:
      if event.button() == Qt.LeftButton:
        self.mousebutton = QEvent.MouseButtonDblClick
    QTableWidget.mouseDoubleClickEvent(self, event)
  def keyPressEvent(self, event):
    super().keyPressEvent(event)
    if event.key() == Qt.Key.Key_C and (event.modifiers() & Qt.KeyboardModifier.ControlModifier):
      copied_cells = sorted(self.selectedIndexes())
      copy_text = ''
      max_column = copied_cells[-1].column()
      for c in copied_cells:
        copy_text += self.item(c.row(), c.column()).text()
        if c.column() == max_column:
          copy_text += '\n'
        else:
          copy_text += '\t'
      QtWidgets.QApplication.instance().clipboard().setText(copy_text)


class MillerTableColumnHeaderDialog(QDialog):
  # Assigned to NGL_HKLViewer.select_millertable_column_dlg allowing the user to
  # specify with checkboxes which column of the millertable should be visible.
  def __init__(self, parent=None):
    super(MillerTableColumnHeaderDialog, self).__init__(parent.window)
    self.setWindowFlags(Qt.Tool)
    self.setSizeGripEnabled(True)
    self.setWindowTitle("Dataset properties to display")
    self.parent = parent
    self.selectcolumnstable = QTableWidget()
    self.layout = QGridLayout()
    self.layout.addWidget(self.selectcolumnstable,  0, 0)
    self.setLayout(self.layout)
    self.selectcolumnstable.itemChanged.connect(self.onSelectColumnsTableItemChanged  )
    self.selectcolumnstable.itemPressed.connect(self.onSelectColumnsTableItemChanged  )
    self.unfeedback = False
  def make_new_selection_table(self):
    self.unfeedback = True
    nrows = len(self.parent.colnames_select_lst)
    self.selectcolumnstable.clearContents()
    self.selectcolumnstable.setColumnCount(1)
    self.selectcolumnstable.setRowCount(nrows)
    for row,(philname, (short_caption, helpstr), is_selected) in enumerate(self.parent.colnames_select_lst):
      item = QTableWidgetItem(short_caption)
      item.setData(Qt.UserRole, philname) # associated phil parameter name is stored with the setData function
      item.setFlags((Qt.ItemIsUserCheckable | Qt.ItemIsEnabled) )
      item.setToolTip(helpstr)
      if is_selected:
        item.setCheckState(Qt.Checked)
      else:
        item.setCheckState(Qt.Unchecked)
      self.selectcolumnstable.setItem(row, 0, item)
    self.unfeedback = False
    self.resize()
  def onSelectColumnsTableItemChanged(self, item):
    if self.unfeedback:
      return
    philname = item.data(Qt.UserRole) # get the phil parameter name stored as data
    if item.checkState()==Qt.Unchecked:
      is_selected = False
    else:
      is_selected = True
    current_philstr = "selected_info.%s = %s" %(philname, is_selected)
    self.parent.send_message(current_philstr)
  def resize(self):
    self.selectcolumnstable.resizeColumnsToContents()
    self.setFixedWidth(
      self.selectcolumnstable.verticalHeader().width() +
      self.selectcolumnstable.horizontalHeader().length() +
      self.selectcolumnstable.frameWidth()*2 +
      self.selectcolumnstable.verticalScrollBar().width()*2
      )



class MillerArrayTableForm(QDialog):
  # dialog for showing miller array data, sigmas and hkl values
  def __init__(self, parent=None):
    super(MillerArrayTableForm, self).__init__(parent.window)
    self.setWindowFlag(Qt.WindowContextHelpButtonHint,False);
    self.setWindowTitle("Tabulated Reflection Data")
    self.precision_spinBox = QSpinBox()
    self.precision_spinBox.setSingleStep(1)
    self.precision_spinBox.setRange(1, 20)
    self.precision_spinBox.setValue(3)
    self.precision_spinBox.valueChanged.connect(parent.onPrecisionChanged)
    precision_labeltxt = QLabel()
    precision_labeltxt.setText("Precision:")
    self.SortComboBox = QComboBox()
    self.SortComboBox.activated.connect(parent.onSortComboBoxSelchange)
    sort_labeltxt = QLabel()
    sort_labeltxt.setText("Sort according to:")
    self.sortChkbox = QCheckBox()
    self.sortChkbox.setCheckState(Qt.Unchecked)
    self.sortChkbox.setText("Ascending order")
    self.sortChkbox.clicked.connect(parent.onSortChkbox)
    self.myGroupBox = QGroupBox()
    self.layout = QGridLayout()
    self.layout.addWidget(precision_labeltxt,       0, 0, 1, 1)
    self.layout.addWidget(self.precision_spinBox,   0, 1, 1, 1)
    self.layout.addWidget(sort_labeltxt,            0, 2, 1, 1)
    self.layout.addWidget(self.SortComboBox,        0, 3, 1, 1)
    self.layout.addWidget(self.sortChkbox,          0, 4, 1, 1)
    self.layout.addWidget(parent.millerarraytable,  1, 0, 1, 5)
    self.layout.setColumnStretch (0 ,0)
    self.layout.setColumnStretch (1 ,0)
    self.layout.setColumnStretch (2 ,0)
    self.layout.setColumnStretch (3 ,0)
    self.layout.setColumnStretch (4 ,1)
    self.myGroupBox.setLayout(self.layout)
    self.mainLayout = QGridLayout()
    self.mainLayout.addWidget(self.myGroupBox,     0, 0)
    self.setLayout(self.mainLayout)
  def eventFilter(self, source, event):
    if (event.type() == QEvent.KeyPress and
      event.matches(QKeySequence.Copy)):
      self.parent().parent.millerarraytable.copySelection()
      return True
    return super(MillerArrayTableForm, self).eventFilter(source, event)


class MillerArrayTableView(QTableView):
  def __init__(self, *args, **kwargs):
    QTableView.__init__(self, *args, **kwargs)
    myqa = QAction("Copy selected cells...", self)
    myqa.setData( ("Copying selection" ))
    self.tablemenu = QMenu(self)
    self.tablemenu.addAction(myqa)
    self.tablemenu.triggered.connect(self.onTableMenuAction)
    self.setContextMenuPolicy(Qt.CustomContextMenu)
    self.customContextMenuRequested.connect(self.onRightClick)
    self.doubleClicked.connect(self.onDoubleClick)
  def onDoubleClick(self, index):
    hkl = (int(index.siblingAtColumn(0).data()),
           int(index.siblingAtColumn(1).data()),
           int(index.siblingAtColumn(2).data()))
    self.parent().parent().parent().parent.HighlightReflection(hkl)
  def onRightClick(self, QPos=None):
    self.parent().parent().parent().parent.HighlightReflection("deselect") # deselects any highlighted hkl
    parent=self.sender()
    self.tablemenu.move(QCursor.pos())
    self.tablemenu.show()
  def onTableMenuAction(self, action):
    data = action.data()
    if data == "Copying selection":
      self.copySelection()
  def copySelection(self):
    # from https://stackoverflow.com/questions/40225270/copy-paste-multiple-items-from-qtableview-in-pyqt4
    selection = self.selectedIndexes()
    if selection:
      rows = sorted(index.row() for index in selection)
      columns = sorted(index.column() for index in selection)
      rowcount = rows[-1] - rows[0] + 1
      colcount = columns[-1] - columns[0] + 1
      table = [[''] * colcount for _ in range(rowcount)]
      for index in selection:
        row = index.row() - rows[0]
        column = index.column() - columns[0]
        table[row][column] = index.data()
      stream = StringIO()
      csv.writer(stream, delimiter='\t').writerows(table)
      self.parent().parent().parent().parent.app.clipboard().setText(stream.getvalue())


class MillerArrayTableModel(QAbstractTableModel):
  def __init__(self, data, headerdata, parent=None):
    super(MillerArrayTableModel, self).__init__(parent.window)
    # input data are a list of column arrays organised as:
    # [[list of H], [list of K], [list of L], [list of millerdata1], [list of millersigmas1], [list of millerdata2]... ]
    # Use zip to transpose it from a list of columns data to matching rows of data values for the table
    self._data = list(zip(*data))
    self.columnheaderdata = headerdata
    self.precision = 4
  def rowCount(self, parent=None):
    return len(self._data)
  def columnCount(self, parent=None):
    return len(self._data[0]) if self.rowCount() else 0
  def data(self, index, role=Qt.DisplayRole):
    if role == Qt.DisplayRole:
      row = index.row()
      if 0 <= row < self.rowCount():
        column = index.column()
        if 0 <= column < self.columnCount():
          val = self._data[row][column]
          if not (type(val) is float or type(val) is int):
            return str(val)
          if math.isnan(val):
            return None
          if abs(val) < float("1e-%d" %self.precision):
            fstr = "%" + "%d" %self.precision
            fstr += ".%de" %self.precision
            return float(fstr %val)
          p = 10 ** self.precision
          if val > 0:
            return float(math.floor((val * p) + 0.5))/p
          return float(math.ceil((val * p) - 0.5))/p
  def clear(self):
    rows = self.rowCount()
    self.beginRemoveRows(QModelIndex(), 0, rows-1 )
    self.endRemoveRows()
    cols = self.columnCount()
    self.beginRemoveColumns(QModelIndex(), 0, cols-1 )
    self.endRemoveColumns()
  def headerData(self, index, orientation, role):
    if orientation == Qt.Horizontal and role == Qt.DisplayRole:
      return self.columnheaderdata[index]
    if orientation == Qt.Vertical and role == Qt.DisplayRole:
      return index + 1 # just return the row number
  def sort(self, col, order):
    """Sort table by given column number.
    """
    self.layoutAboutToBeChanged.emit()
    # when sorting the list list define any possible NaN values as -sys.maxsize so these will come last in the sorted list
    if order == Qt.AscendingOrder:
      #print(self.columnheaderdata[col] + " sort AscendingOrder")
      self._data = sorted(self._data, key= lambda data: -sys.maxsize if math.isnan(data[col]) else data[col])
    if order == Qt.DescendingOrder:
      #print(self.columnheaderdata[col] + " sort DescendingOrder")
      self._data = sorted(self._data, key= lambda data: -sys.maxsize if math.isnan(data[col]) else data[col], reverse=True)
    self.layoutChanged.emit()


# Dialog box with MatPlotLib colour gradient charts from
# http://matplotlib.org/examples/color/colormaps_reference.html


# list all colour maps except their reverse which end with "_r"
cmaps = [ c for c in plt.colormaps() if not c.endswith("_r")]
gradient = np.linspace(0, 1, 256)
gradient = np.vstack((gradient, gradient))

dpi=50


class MplCanvas(FigureCanvas):
  def __init__(self, parent=None, width=5, height=4, dpi=dpi):
    self.parent=parent
    self.fig = Figure(figsize=(10, 20), dpi=dpi, facecolor=(1, 1, 1), edgecolor=(0.5, 0, 0))
    self.axes = self.fig.subplots(nrows=len(cmaps), ncols=1)
    # alignment of each subplot.
    self.fig.subplots_adjust(top=0.995,
                             bottom=0.01,
                             left=0.22, # leave room for the label naming this colour map
                             right=0.98 # leave a small gap before edge of canvas
                             )
    # total size of canvas
    self.fig.set_size_inches(7,40) # total size of canvas
    super(MplCanvas, self).__init__(self.fig)
    self.cid1 = self.fig.canvas.mpl_connect('button_press_event', self.on_press)

  def on_press(self, event):
    if event.inaxes is not None:
      self.parent.selcolmap = cmaps[event.inaxes.get_subplotspec().rowspan.start]
      self.parent.updatelabel()
      self.parent.EnactColourMapSelection()


# TODO work out scaling of canvas to match QApplication.setAttribute(Qt.AA_EnableHighDpiScaling)
# and
class MPLColourSchemes(QtWidgets.QDialog):
  def __init__(self, parent=None):
    super(MPLColourSchemes, self).__init__(parent.window)
    self.setWindowFlags(Qt.Tool)
    self.parent = parent
    self.selcolmap = ""
    self.datatypestr = ""
    self.powscale = 1
    #self.setWindowFlags(Qt.Tool)
    # Create the maptlotlib FigureCanvas object,
    # which defines a single set of axes as self.axes.
    self.labeltxt = QtWidgets.QLabel()
    self.labeltxt.setText("Click on a gradient map for colouring data values")
    self.mycanvas = MplCanvas(self, dpi=dpi)
    self.draw_axes_and_text()
    scroll = QtWidgets.QScrollArea()
    scroll.setWidget(self.mycanvas)
    scroll.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOn)
    scroll.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
    self.reversecheckbox = QtWidgets.QCheckBox()
    self.reversecheckbox.setText("Reverse colour mapping")
    self.reversecheckbox.clicked.connect(self.onReverseMap)
    self.powscale_label = QtWidgets.QLabel()
    self.powscale_label.setText("Power factor for map scaling:")
    self.powscaleslider = QtWidgets.QSlider(Qt.Horizontal)
    self.powscaleslider.setMinimum(-20)
    self.powscaleslider.setMaximum(20)
    self.powscaleslider.setTickPosition(QtWidgets.QSlider.TicksAbove)
    self.powscaleslider.setTickInterval(1)
    self.powscaleslider.sliderReleased.connect(self.onReleasePowscaleslider)
    self.powscaleslider.valueChanged.connect(self.onValueChangedPowscaleslider)
    self.powscaletxtbox = QtWidgets.QLineEdit('')
    self.powscaletxtbox.setReadOnly(True)
    self.OKbtn = QtWidgets.QPushButton("OK")
    self.OKbtn.clicked.connect(self.onOK)
    gridlayout = QtWidgets.QGridLayout()
    gridlayout.addWidget(self.labeltxt,          0, 0, 1, 2)
    gridlayout.addWidget(self.reversecheckbox,   1, 0, 1, 1)
    gridlayout.addWidget(self.powscale_label,    2, 0, 1, 1)
    gridlayout.addWidget(self.powscaleslider,    2, 1, 1, 1)
    gridlayout.addWidget(self.powscaletxtbox,    2, 2, 1, 1)
    gridlayout.addWidget(scroll,                 3, 0, 1, 3)
    gridlayout.addWidget(self.OKbtn,             4, 1, 1, 1)
    self.setLayout(gridlayout)

  def draw_axes_and_text(self):
    for ax, name in zip(self.mycanvas.axes, cmaps):
      ax.imshow(gradient, aspect='auto', cmap=plt.get_cmap(name))
      ax.set_axis_off()
      pos = list(ax.get_position().bounds)
      x_text = pos[0] - 0.21
      y_text = pos[1] + pos[3]/2.
      self.mycanvas.fig.text(x_text, y_text, name, va='center', ha='left',
                             fontsize= self.parent.app.font().pointSize()*1.5 )

  def resizeEvent(self, event):
    # MplCanvas doesn't resize with the rest of QtWidgets whenever
    # triggered by a font size changes from the main GUI. So resize here instead
    if event.type() == QEvent.Type.Resize:
      ltxt = len(self.mycanvas.fig.texts)
      for i in range(ltxt): # delete from the end as the lists is changed
        self.mycanvas.fig.texts[ltxt-(i+1)].remove()
      self.draw_axes_and_text()
      qs = self.sizeHint()
      self.mycanvas.resize(qs.width()*0.93, qs.height()*4)
    QtWidgets.QDialog.resizeEvent(self, event)

  def EnactColourMapSelection(self):
    if hasattr(self.parent,"onColourChartSelect"):
      self.parent.onColourChartSelect(self.selcolmap, self.powscale)

  def showEvent(self, event):
    self.updatelabel()
    self.powscaletxtbox.setText("%2.2f" %self.powscale )

  def onOK(self):
    self.hide()

  def updatelabel(self):
    self.labeltxt.setText('Selected colour gradient map: %s for %s data' %(self.selcolmap, self.datatypestr) )

  def onReverseMap(self):
    if self.reversecheckbox.isChecked():
      if not self.selcolmap.endswith( "_r"):
        self.selcolmap = self.selcolmap + "_r"
    else:
      if self.selcolmap.endswith( "_r"):
        self.selcolmap = self.selcolmap[:-2]
    self.updatelabel()
    self.EnactColourMapSelection()

  def onReleasePowscaleslider(self):
    self.EnactColourMapSelection()

  def onValueChangedPowscaleslider(self):
    val= self.powscaleslider.value()
    # want to raise the colour scaling to a power bigger than 0
    # so compute powscale from an exponential of the slider value
    self.powscale = math.pow(1.1, val) # 1.1 varies sufficiently slowly for the slider range [-10,10]
    self.powscaletxtbox.setText("%2.2f" %self.powscale )

  def setPowerScaleSliderVal(self, power):
    self.powscale = power
    val = math.log(power)/math.log(1.1)
    self.powscaleslider.setValue(int(val))
    self.updatelabel()

  def setDataType(self, datatypestr):
    self.datatypestr = datatypestr
    self.updatelabel()
    if datatypestr == "Map coeffs" or datatypestr == "Phases":
      self.powscaleslider.setDisabled(True)
      self.setPowerScaleSliderVal(1.0)
    else:
      self.powscaleslider.setEnabled(True)


 *******************************************************************************


 *******************************************************************************
crys3d/hklviewer/hklview_frame.py

from __future__ import absolute_import, division, print_function

from iotbx.reflection_file_reader import any_reflection_file
from cctbx.xray import observation_types
from iotbx.gui_tools.reflections import ArrayInfo
from crys3d.hklviewer import display2 as display
from crys3d.hklviewer import jsview_3d
from crys3d.hklviewer.jsview_3d import HKLviewerError as HKLviewerError
from cctbx import miller
from cctbx import crystal
from libtbx.math_utils import roundoff
from cctbx.array_family import flex
from libtbx.utils import Sorry, to_str
from scitbx import matrix
from cctbx import sgtbx
from libtbx import group_args, version
import libtbx
import libtbx.load_env
import traceback
import sys, zmq, threading,  time, cmath, zlib, os.path, math, re
from pathlib import Path
import importlib.util



NOREFLDATA = "No reflection data has been selected"

class HKLViewFrame() :
  def __init__ (self, *args, **kwds) :
    self.valid_arrays = []
    self.spacegroup_choices = []
    self.procarrays = []
    self.origarrays = {}
    self.ano_spg_tpls =[]
    self.merge_answer = [None]
    self.dmin = -1
    self.verbose = 1
    if 'verbose' in kwds:
      try:
        self.verbose = eval(kwds['verbose'])
      except Exception as e:
        self.verbose = kwds['verbose']
    self.guiSocketPort=None
    self.output_file = None
    if 'output_filename' in kwds:
      fname = kwds.get('output_filename', None )
      self.output_file = open(fname, "w", encoding="utf-8")
    kwds['mprint'] = self.mprint
    self.outputmsgtypes = []
    self.userpresetbuttonsfname = os.path.join( Path.home(), ".hkl_viewer_buttons.py")
    self.infostr = ""
    self.allbuttonslist = []
    self.hklfile_history = []
    self.arrayinfos = []
    self.tncsvec = None
    self.aniso1 = None
    self.aniso2 = None
    self.aniso3 = None
    self.uservectors = []
    self.new_miller_array_operations_lst = []
    cfilename = libtbx.env.under_root(os.path.join("modules","cctbx_project","COPYRIGHT.txt"))
    if not os.path.exists( cfilename ):
      cfilename = libtbx.env.under_root(os.path.join("cctbx", "COPYRIGHT.txt")) # conda installations
    self.copyrightpaths = [
     ("CCTBX copyright", cfilename),
     ("NGL copyright", os.path.join(os.path.dirname(os.path.abspath(__file__)), "License_for_NGL.txt")),
     ("html2canvas copyright", os.path.join(os.path.dirname(os.path.abspath(__file__)), "LICENSE_for_html2canvas.txt"))
    ]
    self.zmqsleeptime = 0.1
    self.update_handler_sem = threading.BoundedSemaphore()
    self.run_external_sem = threading.BoundedSemaphore()
    self.initiated_gui_sem = threading.Semaphore()
    self.start_time = time.time()
    kwds['send_info_to_gui'] = self.SendInfoToGUI # function also used by HKLjsview_3d
    buttonsdeflist = []
    if 'useGuiSocket' in kwds:
      self.guiSocketPort = eval(kwds['useGuiSocket'])
      self.context = zmq.Context()
      self.guisocket = self.context.socket(zmq.PAIR)
      self.guisocket.connect("tcp://127.0.0.1:%s" %self.guiSocketPort )
      self.STOP = False
      self.initiated_gui_sem.acquire(timeout=20) # released once HKLviewer sends a message of type "initiated_gui"
      now = time.strftime("%a, %d %b %Y %H:%M:%S", time.gmtime())
      self.mprint("%s, CCTBX version: %s" %(now, version.get_version()), verbose=1, with_elapsed_secs=False)
      self.mprint("CCTBX process with pid: %s starting socket thread" %os.getpid(), verbose=1)
      # name this thread to ensure any asyncio functions are called only from main thread
      self.msgqueuethrd = threading.Thread(target = self.zmq_listen, name="HKLviewerZmqThread" )
      self.msgqueuethrd.daemon = True
      #kwds['send_info_to_gui'] = self.SendInfoToGUI # function also used by HKLjsview_3d
      pyversion = "cctbx.python.version: " + str(sys.version_info[0])
      # tell gui what python version we are
      self.SendInfoToGUI(pyversion )
      self.SendInfoToGUI({"copyrights": self.copyrightpaths,
                          "cctbxversion": version.get_version()} )
      from .preset_buttons import buttonsdeflist
      try:
        from phasertng.scripts import xtricorder # then we can run xtricorder from phasertng
        self.SendInfoToGUI({"AddXtricorderButton": True}) # show the button next to the xtriage button
      except Exception as e: # no phasertng present, just a cctbx installation
        pass # only xtriage button is shown
    else:
      now = time.strftime("%a, %d %b %Y %H:%M:%S", time.gmtime())
      self.mprint("%s, CCTBX version: %s" %(now, version.get_version()), verbose=1, with_elapsed_secs=False)
    self.mprint("kwds= " +str(kwds), verbose=1)
    self.mprint("args= " + str(args), verbose=1)
    kwds['websockport'] = self.find_free_port()
    kwds['parent'] = self
    self.viewer = jsview_3d.HKLview_3d( **kwds )
    self.allbuttonslist = buttonsdeflist
    if os.path.exists(self.userpresetbuttonsfname):
      self.mprint("Using user defined preset-buttons from " + self.userpresetbuttonsfname, verbose=1)
    else:
      factorydefault_userbutton_fname = os.path.join(os.path.split(jsview_3d.__file__)[0], "default_user_preset_buttons.py")
      import shutil
      shutil.copyfile(factorydefault_userbutton_fname, self.userpresetbuttonsfname)
      self.mprint("New UserPresetButton file copied to " + self.userpresetbuttonsfname)
      self.mprint("Taylor button definitions to your own needs.")

    spec = importlib.util.spec_from_file_location("UserPresetButtons", self.userpresetbuttonsfname)
    UserPresetButtons_module = importlib.util.module_from_spec(spec)
    sys.modules["UserPresetButtons"] = UserPresetButtons_module
    try:
      spec.loader.exec_module(UserPresetButtons_module)
      self.allbuttonslist = buttonsdeflist + UserPresetButtons_module.buttonsdeflist
    except Exception as e:
      self.mprint( str(e) + traceback.format_exc(limit=10))
    self.ResetPhilandViewer()
    self.firsttime = True
    self.idx_data = None
    self.clipper_crystdict = None
    self.NewFileLoaded = False
    self.loaded_file_name = ""
    self.validated_preset_buttons = False
    self.fileinfo = None
    if 'fileinfo' in kwds:
      self.fileinfo = kwds.get('fileinfo', 1 )
    self.hklin = ""
    if 'useGuiSocket' in kwds:
      self.msgqueuethrd.start()
    self.validate_preset_buttons()
    #time.sleep(12) # for attaching debugger
    if 'show_master_phil' in args:
      self.mprint("Default PHIL parameters:\n" + "-"*80 + "\n" + master_phil.as_str(attributes_level=2) + "-"*80)
    self.thrd2 = threading.Thread(target = self.thread_process_arguments, kwargs=kwds )
    self.thrd2.daemon = True
    self.thrd2.start()
    self.closingtime = int(kwds.get('closing_time', -1 ))
    # if invoked from command line not using Qt close us by waiting for thread processing cmdline kwargs to finish
    if 'closing_time' in kwds and not 'useGuiSocket' in kwds:
      self.thrd2.join(timeout = self.closingtime + 40)
      if self.thrd2.is_alive():
        self.mprint("Error: Timeout reached for thread_process_arguments()", verbose=2)
        self.SendInfoToGUI( { "closing_time": True } )


  def thread_process_arguments(self, **kwds):
    try:
      if 'hklin' in kwds or 'HKLIN' in kwds:
        self.hklin = kwds.get('hklin', kwds.get('HKLIN', "") )
        self.LoadReflectionsFile(self.hklin)
        self.validate_preset_buttons()
      if 'phil_file' in kwds: # enact settings in a phil file for quickly displaying a specific configuration
        fname = kwds.get('phil_file', "" )
        if not self.initiated_gui_sem.acquire(timeout=300): # wait until GUI is ready before executing philstring commands
          self.mprint("Failed acquiring initiated_gui_sem semaphore within 300 seconds", verbose=1)
        self.initiated_gui_sem.release()
        self.mprint("Processing PHIL file: %s" %fname)
        with open(fname, "r") as f:
          philstr = f.read()
          self.update_from_philstr(philstr, msgtype="preset_philstr", postrender=True)
          self.mprint("thread_process_arguments() waiting for run_external_sem.acquire", verbose="threadingmsg")
          if not self.run_external_sem.acquire(timeout=jsview_3d.lock_timeout):
            self.mprint("Timed out getting run_external_sem semaphore within %s seconds" %jsview_3d.lock_timeout, verbose=1)
          self.run_external_sem.release()
          self.mprint("thread_process_arguments() releasing run_external_sem", verbose="threadingmsg")
        if 'image_file' in kwds: # save displayed reflections to an image file
          time.sleep(1)
          fname = kwds.get('image_file', "testimage.png" )
          self.update_from_philstr('save_image_name = "%s"' %fname, msgtype="preset_philstr", postrender=True)
      # if we are invoked using Qtgui close us gracefully if requested
      if 'closing_time' in kwds:
        time.sleep(10)
        self.mprint("Closing time reached", verbose=1)
        self.SendInfoToGUI( { "closing_time": True } )
      self.mprint("Done thread_process_arguments()", verbose=2)
    except HKLviewerError as e:
      self.mprint("\nClosing due to:\n" + str(e) + "\n" + traceback.format_exc(limit=10), verbose=0)
      self.SendInfoToGUI( { "closing_time": True } )
      raise
    except Exception as e:
      self.mprint( str(e) + traceback.format_exc(limit=10), verbose=0)


  def __exit__(self, exc_type=None, exc_value=0, traceback=None):
    self.viewer.__exit__(exc_type, exc_value, traceback)
    self.mprint("Destroying HKLViewFrame", verbose=0) # this string is expected by HKLviewer.py so don't change
    self.STOP = True
    if self.output_file:
      self.output_file.close()
      self.output_file = None
    del self


  def mprint(self, msg, verbose=0, end="\n", with_elapsed_secs=True):
    elapsed = time.time() - self.start_time
    if elapsed > 3600: # reset to 0 after an hour
      self.start_time = time.time()
    tmsg = "%s%s" %(msg, end)
    if with_elapsed_secs:
      tmsg = "[%4.2f] %s%s" %(elapsed, msg, end)
    intverbose =1
    if isinstance(self.verbose,str):
      m = re.findall(r"(\d)", self.verbose)
      if len(m) >0:
        intverbose = int(m[0])
    else:
      intverbose = self.verbose
    if self.guiSocketPort:
      if  verbose == 0:
        # say verbose="2threading" then print all messages with verbose=2 or verbose=threading
        self.SendInfoToGUI( { "info": msg + end } )
      if (intverbose and isinstance(verbose,int) and verbose >= 0 and verbose <= intverbose) \
       or (isinstance(self.verbose,str) and self.verbose.find(str(verbose))>=0 ):
        # say verbose="2threading" then print all messages with verbose=2 or verbose=threading
        self.SendInfoToGUI( { "alert": tmsg } )
        if self.output_file and self.output_file.closed==False:
          self.output_file.write(tmsg)
          self.output_file.flush()
    else:
      if (intverbose and isinstance(verbose,int) and verbose >= 0 and verbose <= intverbose) \
       or (isinstance(self.verbose,str) and self.verbose.find(str(verbose))>=0 ):
        # say verbose="2threading" then print all messages with verbose=2 or verbose=threading
        if self.output_file and self.output_file.closed==False:
          self.output_file.write(tmsg)
          self.output_file.flush()
        else:
          print( str(msg).encode(sys.stdout.encoding, errors='ignore').decode(sys.stdout.encoding) )


  def find_free_port(self):
    import socket
    s = socket.socket()
    s.bind(('', 0))      # Bind to a free port provided by the host.
    port = s.getsockname()[1]
    s.close()
    return port


  def zmq_listen(self):
    nan = float("nan") # workaround for "evaluating" any NaN values in the messages received
    lastmsgtype = ""
    while not self.STOP:
      try:
        msgstr = self.guisocket.recv().decode("utf-8")
        if msgstr == "":
          continue
        self.mprint("Received message string:\n" + msgstr, verbose=3)
        msgtype, mstr = eval(msgstr)
        if msgtype == "initiated_gui":
          self.mprint("GUI has been initialised.\n", verbose=1)
          self.initiated_gui_sem.release()
        if msgtype=="debug_info":
          self.mprint(mstr, verbose=2 )
        if msgtype=="debug_show_phil":
          self.mprint(self.show_current_phil() )
        if msgtype=="datatypedict":
          self.viewer.datatypedict = eval(mstr)
        if msgtype=="clipper_crystdict":
          self.clipper_crystdict = eval(mstr)
          self.convert_clipperdict_to_millerarrays(self.clipper_crystdict)
        if msgtype in ["philstr", "preset_philstr"]:
          self.mprint("Received PHIL string:\n" + mstr, verbose=1)
          new_phil = libtbx.phil.parse(mstr)
          self.guarded_process_PHIL_parameters(new_phil, msgtype, lastmsgtype)
        lastmsgtype = msgtype
        time.sleep(self.zmqsleeptime)
      except Exception as e:
        self.mprint( str(e) + traceback.format_exc(limit=10), verbose=1)
    self.mprint("Shutting down zmq_listen() thread", verbose=1)
    self.guiSocketPort=None


  def ResetPhilandViewer(self, extraphil=None):
    self.ResetPhil(extraphil)
    self.viewer.symops = []
    self.viewer.sg = None
    self.procarrays = []
    self.viewer.proc_arrays = []
    self.viewer.HKLscenedict = {}
    self.uservectors = []
    self.viewer.visual_symmxs = []
    self.viewer.visual_symHKLs = []
    self.viewer.sceneisdirty = True
    self.viewer.isnewfile = True
    self.validated_preset_buttons = False
    self.viewer.hkl_scenes_infos = []
    if self.viewer.miller_array:
      self.viewer.params.viewer.scene_id = None
      self.viewer.RemoveStageObjects()
    self.viewer.miller_array = None
    self.viewer.lastviewmtrx = None
    return self.viewer.params


  def ResetPhil(self, extraphil=None):
    self.currentphil = master_phil
    if extraphil:
      self.currentphil = self.currentphil.fetch(source = extraphil)
      # Don't retain clip plane values as these are specific to each crystal
      # so use clip plane parameters from the master phil
      default_clipphil = master_phil.fetch().extract().clip_plane
      currentparms = self.currentphil.extract()
      currentparms.clip_plane = default_clipphil
      self.currentphil = master_phil.format(python_object = currentparms)
    self.params = self.currentphil.fetch().extract()
    self.viewer.params = self.params
    self.params.binning.binner_idx = 0
    self.params.binning.nbins = 1
    self.params.binning.scene_bin_thresholds = []
    self.params.using_space_subgroup = False


  def GetNewCurrentPhilFromString(self, philstr, oldcurrentphil):
    user_phil = libtbx.phil.parse(philstr)
    newcurrentphil = oldcurrentphil.fetch(source = user_phil)
    diffphil = oldcurrentphil.fetch_diff(source = user_phil)
    return newcurrentphil, diffphil


  def GetNewCurrentPhilFromPython(self, pyphilobj, oldcurrentphil):
    newcurrentphil, unusedphilparms = oldcurrentphil.fetch(source = pyphilobj, track_unused_definitions=True)
    for parm in unusedphilparms:
      self.mprint( "Received unrecognised phil parameter: " + parm.path, verbose=1)
    diffphil = oldcurrentphil.fetch_diff(source = pyphilobj)
    # bin_opacity, show_vector and user_vector have the "multiple" attribute. In order to retain any existing
    # list elements we copy them from the oldcurrentphil parameters and assign them to the newphil parameters
    # Failure to do this would lead to list of bin_opacity elements not being properly updated when
    # changing one of the bin_opacity elements. Likewise for show_vector and user_vector.
    if jsview_3d.has_phil_path(pyphilobj, "bin_opacity"):
      bin_opacitylst = master_phil.fetch(source = pyphilobj ).extract().binning.bin_opacity
    else:
      bin_opacitylst = master_phil.fetch(source = oldcurrentphil ).extract().binning.bin_opacity
    newpyobj = newcurrentphil.extract()
    newpyobj.binning.bin_opacity = bin_opacitylst
    newcurrentphil = newcurrentphil.format(python_object= newpyobj )

    if jsview_3d.has_phil_path(pyphilobj, "show_vector"):
      show_vectorlst = master_phil.fetch(source = pyphilobj ).extract().viewer.show_vector
    else:
      show_vectorlst = master_phil.fetch(source = oldcurrentphil ).extract().viewer.show_vector
    newpyobj = newcurrentphil.extract()
    newpyobj.viewer.show_vector = show_vectorlst
    newcurrentphil = newcurrentphil.format(python_object= newpyobj )

    if jsview_3d.has_phil_path(pyphilobj, "user_vector"):
      user_vectorlst = master_phil.fetch(source = pyphilobj ).extract().viewer.user_vector \
       + oldcurrentphil.extract().viewer.user_vector
      newpyobj = newcurrentphil.extract()
      newpyobj.viewer.user_vector = user_vectorlst
      newcurrentphil = newcurrentphil.format(python_object= newpyobj )

    return newcurrentphil, diffphil


  def SetCurrentPhilAsPython(self, pyphil):
    newphil = master_phil.format(python_object= pyphil)
    currphil = master_phil.fetch(source = newphil)


  def show_current_phil(self, useful_for_preset_button=True):
    # When useful_for_preset_button=True the output has integer ids for vectors and scene_id
    # replaced with label strings for vectors and data arrays
    diffphil = master_phil.fetch_diff(source = self.currentphil)
    if useful_for_preset_button:
      # Tidy up diffphil by eliminating parameters that are not needed
      # for preset buttons or are being overwritten by user settings (selected_info, colour and radii scheme)
      # First make a copy of all phil parameters some of which may be altered below
      paramscopy = master_phil.format(self.params).copy().extract()

      omitparms = ["viewer.scene_id", "hkls.nth_power_scale_radii", "hkls.scale",
        "hkls.color_scheme", "hkls.color_powscale", "binning.binner_idx"]
        # selected_info and NGL scope are omitted below
      if jsview_3d.has_phil_path(diffphil, "scene_id"):
        # then merge corresponding label and datatype into the diffphil so these can be used for
        # preset button phil strings instead of scene_id which may only apply to the current data file
        label,datatype = self.viewer.get_label_type_from_scene_id(paramscopy.viewer.scene_id)
        paramscopy.viewer.data_array.label = label
        paramscopy.viewer.data_array.datatype = datatype
        paramsobj = master_phil.format(paramscopy)
        diffphil = master_phil.fetch_diff(source =paramsobj)

      if jsview_3d.has_phil_path(diffphil, "angle_around_vector"):
        # convert any integer id into corresponding label for this vector
        # which is needed for userfriendliness when using current phil for preset buttons
        lblvectors = self.viewer.get_vectors_labels_from_ids([paramscopy.viewer.angle_around_vector])
        strvec, angle = lblvectors[0]
        # if angle=0 this amounts to the default of not having rotated at all so omit angle_around_vector altogether
        if angle != 0.0:
          paramscopy.viewer.angle_around_vector = str(lblvectors[0])
        else:
          omitparms = omitparms + ["viewer.angle_around_vector"]
        diffphil = diffphil.format(paramscopy) # adopt new angle_around_vector value

      if jsview_3d.has_phil_path(diffphil, "animate_rotation_around_vector"):
        # convert any integer id into corresponding label for this vector
        # which is needed for userfriendliness when using current phil for preset buttons
        lblvectors = self.viewer.get_vectors_labels_from_ids([paramscopy.viewer.animate_rotation_around_vector])
        strvec, speed = lblvectors[0]
        # if speed <= 0 this amounts to the default of not animating at all so omit animate_rotation_around_vector altogether
        if speed > 0.0:
          paramscopy.viewer.animate_rotation_around_vector = str(lblvectors[0])
        else:
          omitparms = omitparms + ["clip_plane.animate_rotation_around_vector"]
        diffphil = diffphil.format(paramscopy) # adopt new animate_rotation_around_vector value

      if jsview_3d.has_phil_path(diffphil, "show_vector"):
        # convert any integer id into corresponding label for this vector
        # which is needed for userfriendliness when using current phil for preset buttons
        show_vectors_lbl = self.viewer.get_vectors_labels_from_ids(paramscopy.viewer.show_vector)
        showveclst = []
        # viewer.show_vector has multiple=True so use a list to add more vectors to the phil parameter
        for veclbl,isvisible in show_vectors_lbl:
          if isvisible==True: # default is for vectors not to show, so no need to include those
            showveclst.append(str([veclbl,isvisible]) )
        paramscopy.viewer.show_vector = showveclst
        diffphil = diffphil.format(paramscopy) # adopt new show_vector value

      if jsview_3d.has_phil_path(diffphil, "binner_idx"):
        # then merge corresponding binlabel into the diffphil so it can be used for
        # preset button phil strings instead of binner_idx which may only apply to the current data file
        binlabel = self.viewer.get_binlabel_from_binner_idx(paramscopy.binning.binner_idx)
        binlabelphil = libtbx.phil.parse("binning.binlabel = '%s'" %binlabel)
        workingphil = master_phil.fetch(sources=[binlabelphil, diffphil] )
        diffphil = master_phil.fetch_diff(source=workingphil )

      remove_bin_opacities = True
      if jsview_3d.has_phil_path(diffphil, "bin_opacity"):
        bin_opacitieslst = paramscopy.binning.bin_opacity
        for alpha,bin in bin_opacitieslst:
          if alpha < 1.0: # at least 1 bin is not fully opaque.
                          # That's not the default so don't omit opacities
            remove_bin_opacities = False
            break
      if remove_bin_opacities:
        omitparms = omitparms + ["binning.bin_opacity"]
      remainingobjs = []
      for obj in diffphil.objects:
        vobjs = []
        if hasattr(obj, "objects"):
          for vobj in obj.objects:
            if vobj.full_path() not in omitparms:
              vobjs.append(vobj)
          obj.objects = vobjs
          # The miller table column layout irrelevant for preset buttons so skip phil values governing it.
          # Applies as well to NGL phil scope
          if len(obj.objects) > 0 and obj.full_path() !=  "selected_info" and obj.full_path() !=  "NGL":
            remainingobjs.append(obj)
        else:
          remainingobjs.append(obj)
      diffphil.objects = remainingobjs
    return "\nCurrent non-default phil parameters:\n\n" + diffphil.as_str()


  def update_from_philstr(self, philstr, msgtype="philstr", postrender=False):
    # Convenience function for scripting HKLviewer that mostly superseedes other functions for
    # scripting such as ExpandAnomalous(True), SetScene(0) etc.
    new_phil = libtbx.phil.parse(philstr)
    self.guarded_process_PHIL_parameters(new_phil, msgtype=msgtype, postrender=postrender)


  def guarded_process_PHIL_parameters(self, new_phil=None, msgtype="philstr",
                              lastmsgtype="philstr", postrender=False):
    self.mprint("guarded_process_PHIL_parameters() waiting for update_handler_sem.acquire", verbose="threadingmsg")
    if not self.update_handler_sem.acquire(timeout=jsview_3d.lock_timeout):
      self.mprint("Timed out getting update_handler_sem semaphore within %s seconds" %jsview_3d.lock_timeout, verbose=1)
    self.mprint("guarded_process_PHIL_parameters() got update_handler_sem", verbose="threadingmsg")
    self.process_PHIL_parameters(new_phil=new_phil, msgtype=msgtype, lastmsgtype=lastmsgtype)
    if postrender:
      time.sleep(1)
      self.viewer.RedrawNGL()
      time.sleep(1)
      self.viewer.SimulateClick()
      time.sleep(1)
      self.viewer.GetReflectionsInFrustum()
    self.update_handler_sem.release()
    self.mprint("guarded_process_PHIL_parameters() releasing update_handler_sem", verbose="threadingmsg")


  def process_PHIL_parameters(self, new_phil=None, msgtype="philstr", lastmsgtype="philstr"):
    try:
      if not self.viewer.webgl_OK:
        raise HKLviewerError("Critical WebGL problem! ")
      oldsceneid = self.params.viewer.scene_id
      currentNGLscope = None
      currentSelectInfoscope = None
      if msgtype=="preset_philstr":
        currentNGLscope = self.currentphil.extract().NGL
        currentSelectInfoscope = self.currentphil.extract().selected_info
        self.ResetPhil()
        self.viewer.sceneisdirty = True
        self.viewer.executing_preset_btn = True
      # selecting a new scene_id resets phil parameters if the previous phil was from a preset button
      if lastmsgtype=="preset_philstr" and jsview_3d.has_phil_path(new_phil, "scene_id"):
        currentNGLscope = self.currentphil.extract().NGL
        currentSelectInfoscope = self.currentphil.extract().selected_info

      if not new_phil:
        new_phil = master_phil.format(python_object = self.params)
      self.currentphil, diff_phil = self.GetNewCurrentPhilFromPython(new_phil, self.currentphil)

      self.params = self.currentphil.extract()
      phl = self.params
      if msgtype=="preset_philstr":  # override default NGL and selected_info scopes with user settings
        self.params.NGL = currentNGLscope
        self.params.selected_info = currentSelectInfoscope
      self.viewer.params = phl
      # once a preset phil setting has been enabled allow changing a phil parameter
      # without having to change scene_id
      if (msgtype=="philstr") and (lastmsgtype=="preset_philstr") and (oldsceneid is not None) and \
         jsview_3d.has_phil_path(diff_phil, "scene_id") == False:
        self.params.viewer.scene_id = oldsceneid
        self.viewer.sceneisdirty = True

      if len(diff_phil.all_definitions()) < 1 and not self.viewer.mouse_moved:
        self.mprint( "No change in PHIL parameters\n", verbose=1)
        return

      self.mprint("diff phil:\n" + diff_phil.as_str(), verbose=1 )

      if jsview_3d.has_phil_path(diff_phil, "external_cmd"):
        self.run_external_cmd(diff_phil)
      #phl.external_cmd = "None" # ensure we can do this again

      if jsview_3d.has_phil_path(diff_phil, "miller_array_operation"):
        phl.viewer.scene_id = self.make_new_miller_array( msgtype=="preset_philstr" )
        self.set_scene(phl.viewer.scene_id)
        self.update_space_group_choices()
        phl.hkls.sigma_color_radius = False
      else:
        self.params.miller_array_operation = ""
      # preset phil usually comes with data_array.label, data_array.phasertng_tag or data_array.datatype.
      # Scene_id is then inferred from data_array and used throughout
      if jsview_3d.has_phil_path(diff_phil, "data_array"):
        if jsview_3d.has_phil_path(diff_phil, "phasertng_tag"):
          phl.viewer.data_array.label = self.get_label_from_phasertng_tag(phl.viewer.data_array.phasertng_tag)
        phl.viewer.scene_id = self.viewer.get_scene_id_from_label_or_type(phl.viewer.data_array.label,
                                                                          phl.viewer.data_array.datatype)
      if jsview_3d.has_phil_path(diff_phil, "binlabel"):
        phl.binning.binner_idx = self.viewer.get_binner_idx_from_label(phl.binning.binlabel)

      if jsview_3d.has_phil_path(diff_phil, "scene_id"):
        phl.viewer.data_array.label = None
        phl.viewer.data_array.datatype = None

      if jsview_3d.has_phil_path(diff_phil, "use_provided_miller_arrays"):
        if not self.load_miller_arrays():
          return
        self.viewer.lastscene_id = phl.viewer.scene_id
        phl.use_provided_miller_arrays = False # ensure we can do this again

      if jsview_3d.has_phil_path(diff_phil, "openfilename"):
        fname = phl.openfilename
        currentNGLscope = self.currentphil.extract().NGL
        currentSelectInfoscope = self.currentphil.extract().selected_info
        phl = self.ResetPhilandViewer()
        if not self.load_reflections_file(fname):
          return
        self.params.NGL = currentNGLscope # override default NGL and selected_info scopes with user settings
        self.params.selected_info = currentSelectInfoscope
        self.viewer.lastscene_id = phl.viewer.scene_id
        self.validated_preset_buttons = False

      if jsview_3d.has_phil_path(diff_phil, "scene_id",
                                            "show_missing",
                                            "show_only_missing",
                                            "show_systematic_absences",
                                            "data_array"):
        if self.viewer.set_scene() and not jsview_3d.has_phil_path(diff_phil, "binning"):
          self.viewer.binvals = []
          phl.binning.scene_bin_thresholds = []
          self.update_space_group_choices()
          self.set_scene_bin_thresholds(phl.binning.scene_bin_thresholds,
                                         binner_idx=phl.binning.binner_idx,
                                         nbins=phl.binning.nbins )

      if jsview_3d.has_phil_path(diff_phil, "binning"):
        if jsview_3d.has_phil_path(diff_phil, "nbins") and \
         not jsview_3d.has_phil_path(diff_phil, "scene_bin_thresholds"):
          phl.binning.scene_bin_thresholds = []
        self.set_scene_bin_thresholds(phl.binning.scene_bin_thresholds,
                                        binner_idx=phl.binning.binner_idx,
                                        nbins=phl.binning.nbins )

      if jsview_3d.has_phil_path(diff_phil, "spacegroup_choice"):
        self.set_spacegroup_choice(phl.spacegroup_choice)

      if jsview_3d.has_phil_path(diff_phil, "tabulate_miller_array_ids"):
        self.tabulate_arrays(phl.tabulate_miller_array_ids)

      if jsview_3d.has_phil_path(diff_phil, "using_space_subgroup") and phl.using_space_subgroup==False:
        self.set_default_spacegroup()

      if jsview_3d.has_phil_path(diff_phil, "user_vector"):
        self.add_user_vector(self.params.viewer.user_vector)
        self.validated_preset_buttons = False

      make_new_info_tuples=False
      if jsview_3d.has_phil_path(diff_phil, "miller_array_operation"):
        miller_array_operations_lst = eval(self.params.miller_array_operation)
        (operation, millarroplabel, [labl1, type1], [labl2, type2]) = miller_array_operations_lst
        if millarroplabel not in [arr.info().label_string() for arr in self.procarrays]:
          make_new_info_tuples=True

      if jsview_3d.has_phil_path(diff_phil, "selected_info", "openfilename") or make_new_info_tuples:
        colnames_select_lst, _ = self.update_arrayinfos()
        self.SendInfoToGUI({"array_infotpls": self.viewer.array_info_format_tpl,
                            "colnames_select_lst": colnames_select_lst })

      if jsview_3d.has_phil_path(diff_phil, "save_image_name"):
        self.SaveImageName(phl.save_image_name)
        phl.save_image_name = None

      if jsview_3d.has_phil_path(diff_phil, "action"):
        ret = self.set_action(phl.action)
        phl.action = "is_running" # ensure the same action in succession can be executed
        if not ret:
          return

      self.params = self.viewer.process_PHIL_parameters(diff_phil, phl)

      if jsview_3d.has_phil_path(diff_phil, "visible_dataset_label"):
        self.addCurrentVisibleMillerArray(phl.visible_dataset_label)
      phl.visible_dataset_label = None # ensure the same action in succession can be executed

      if jsview_3d.has_phil_path(diff_phil, "commit_subgroup_datasets"):
        self.commitSubgroupDatasets()
        self.params.commit_subgroup_datasets = False # allow us to save another subgroup
        self.params.using_space_subgroup = False
      phl.visible_dataset_label = None # ensure the same action in succession can be executed

      if jsview_3d.has_phil_path(diff_phil, "hkls"):
        self.HKLsettings = phl.hkls

      if jsview_3d.has_phil_path(diff_phil, "savefilename"):
        self.SaveReflectionsFile(phl.savefilename, phl.datasets_to_save)
      phl.savefilename = None # ensure the same action in succession can be executed

      if jsview_3d.has_phil_path(diff_phil, "openfilename", "commit_subgroup_datasets"):
        self.list_vectors()
        self.validated_preset_buttons = False
      # parameters might have been changed. So update self.currentphil accordingly

      self.SendCurrentPhilValues()
      self.NewFileLoaded = False
      self.viewer.mouse_moved = False
      self.validate_preset_buttons()
      if (self.viewer.miller_array is None) :
        self.mprint( NOREFLDATA, verbose=1)
      self.mprint( "Ready")
    except HKLviewerError as e:
      # raised in DrawNGLJavaScript() if WebGL error flag was set or failing to connect to webbrowser
      raise e
    except Exception as e:
      self.mprint(to_str(e) + "\n" + traceback.format_exc())


  def SendCurrentPhilValues(self):
    self.currentphil = master_phil.format(python_object = self.params)
    philstrvalsdict = {}
    lst = []
    for e in self.currentphil.all_definitions():
      # deal with multiple definitions of a phil parameter by appending them to a list and
      # then assigning that list to the dictionary value with the key e.path. This assumes
      # that e.object is a phil parameter and not a phil scope.
      # user_vector is a multiple scope and cannot be cast into a dictionary. Instead it is
      # sent as part of self.viewer.all_vectors whenever self.list_vectors() is called
      if e.object.multiple == True:
        lst.append(e.object.extract())
        philstrvalsdict[e.path] = lst
      else:
        philstrvalsdict[e.path] = e.object.extract()
        lst = []
    mydict = { "current_phil_strings": philstrvalsdict }
    self.SendInfoToGUI(mydict)
    if self.viewer.params.viewer.scene_id is not None:
      self.SendInfoToGUI({ "used_nth_power_scale_radii": self.viewer.HKLscene_dict_val().scene.nth_power_scale_radii })


  def detect_Rfree(self, array):
    from iotbx.reflection_file_utils import looks_like_r_free_flags_info
    info = array.info()
    if (array.is_integer_array()) and (looks_like_r_free_flags_info(info)) :
      from iotbx.reflection_file_utils import get_r_free_flags_scores
      score_array = get_r_free_flags_scores([array], None)
      test_flag_value = score_array.test_flag_values[0]
      if test_flag_value not in array.data():
        return array # for the few cases where a miller array cannot be considered as a valid Rfree array
      array = array.customized_copy(data=(array.data() == test_flag_value))
      array.set_info(info)
      array._data = array.data().as_int()
      self.mprint(array.info().label_string() +  " looks like R-free flags. Mapping to zeros and ones", verbose=1)
    return array


  def process_miller_array(self, array) :
    if (array is None) : return
    info = array.info()
    if isinstance(info, str) :
      labels = "TEST DATA"
    else :
      labels = info.label_string()
    if (array.unit_cell() is None) or (array.space_group() is None) :
      raise Sorry("No space group info is present in data")
    details = []
    self.infostr = ""
    array = self.detect_Rfree(array)
    sg = "%s" % array.space_group_info()
    uc = "a=%g b=%g c=%g angles=%g,%g,%g" % array.unit_cell().parameters()
    details_str = ""
    if (len(details) > 0) :
      details_str = "(%s)" % ", ".join(details)
    array_info = group_args(
      labels=labels,
      details_str=details_str,
      merge=self.params.merge_data,
      sg=sg,
      uc=uc)
    return array, array_info


  def process_all_miller_arrays(self, valid_arrays): #, col):
    #self.mprint("Processing reflection data")
    self.procarrays = []
    if self.params.merge_data == False:
      self.hkls.expand_to_p1 = False
      self.hkls.expand_anomalous = False
    for c,arr in enumerate(valid_arrays):
      procarray, procarray_info = self.process_miller_array(arr)
      self.procarrays.append(procarray)
    return procarray_info


  def update_space_group_choices(self, col=None) :
    if (self.viewer.miller_array is None and col is None) or \
      self.params.using_space_subgroup:
      if not self.params.commit_subgroup_datasets:
        return
    if col is None:
      current_miller_array_idx = self.viewer.HKLscene_dict_val().arrayinfo[1]
    else:
      current_miller_array_idx = col
    matching_valid_array = self.procarrays[ current_miller_array_idx ]
    from cctbx.sgtbx.subgroups import subgroups
    from cctbx import sgtbx
    sg_info = matching_valid_array.space_group_info()
    subgrs = subgroups(sg_info).groups_parent_setting()
    self.spacegroup_choices = []
    for i,subgroup in enumerate(subgrs):
      subgroup_info = sgtbx.space_group_info(group=subgroup)
      self.spacegroup_choices.append(subgroup_info)

    for i,e in enumerate(self.spacegroup_choices):
      c = None
      if str(sg_info) == str(e):
        self.current_spacegroup = self.spacegroup_choices[i]
        c = i
        break
    if c is None:
      c = 0
      self.spacegroup_choices.insert(c, sg_info)
      self.current_spacegroup = sg_info
    #self.params.spacegroup_choice = c
    origspgidx = [e.symbol_and_number() for e in self.spacegroup_choices].index(sg_info.symbol_and_number())
    origspg = self.spacegroup_choices[origspgidx]
    self.spacegroup_choices.remove(origspg)
    self.spacegroup_choices = [origspg] + self.spacegroup_choices
    spglst = [e.symbol_and_number() for e in self.spacegroup_choices]
    mydict = { "spacegroups": spglst }
    self.SendInfoToGUI(mydict)


  def set_spacegroup_choice(self, n) :
    if (self.viewer.miller_array is None) :
      raise Sorry("No data loaded!")
    self.current_spacegroup = self.spacegroup_choices[n]
    from cctbx import crystal
    symm = crystal.symmetry(
      space_group_info= self.current_spacegroup,
      unit_cell=self.viewer.miller_array.unit_cell())
    othervalidarrays = []
    for validarray in self.procarrays:
      # TODO: check if array is unmerged i.e. not symmetry unique
      arr = validarray.expand_to_p1().customized_copy(crystal_symmetry=symm)
      arr = arr.merge_equivalents().array().set_info(validarray.info())
      arr = self.detect_Rfree(arr)
      othervalidarrays.append( arr )
    self.viewer.proc_arrays = othervalidarrays
    self.params.using_space_subgroup = True
    self.viewer.set_miller_array()
    for i,e in enumerate(self.spacegroup_choices):
      self.mprint("%d, %s" %(i,e.symbol_and_number()) , verbose=0)


  def SetSpaceGroupChoice(self, n):
    self.params.spacegroup_choice = n
    self.guarded_process_PHIL_parameters()


  def SetDefaultSpaceGroup(self):
    self.params.using_space_subgroup = False
    self.guarded_process_PHIL_parameters()


  def set_default_spacegroup(self):
    #self.viewer.proc_arrays = self.procarrays
    self.viewer.set_miller_array()
    #self.viewer.identify_suitable_fomsarrays()


  def MakeNewMillerArrayFrom(self, operation, label, arrid1, arrid2=None):
    # get list of existing new miller arrays and operations if present
    miller_array_operations_lst = [ ( operation, label, arrid1, arrid2 ) ]
    self.params.miller_array_operations = str( miller_array_operations_lst )
    self.guarded_process_PHIL_parameters()


  def make_new_miller_array(self, is_preset_philstr=False):
    miller_array_operations_lst = eval(self.params.miller_array_operation)
    (operation, label, [labl1, type1], [labl2, type2]) = miller_array_operations_lst

    arrid1 = self.viewer.get_scene_id_from_label_or_type(labl1, type1)
    arrid2 = -1
    if labl2 != "":
      arrid2 = self.viewer.get_scene_id_from_label_or_type(labl2, type2)
    for arr in self.procarrays:
      if label in arr.info().label_string():
        if is_preset_philstr: # miller_array created by a preset  button. Just return the scene_id
          return self.viewer.get_scene_id_from_label_or_type( arr.info().label_string() )
        raise Sorry("Provide a label for the new miller array that isn't already used.")

    from copy import deepcopy
    millarr1 = deepcopy(self.procarrays[arrid1])
    newarray = None
    try:
      if arrid2 != -1:
        millarr2 = deepcopy(self.procarrays[arrid2])
        self.mprint("Creating %s data with array1 as %s and array2 as %s through the operation:\n\n%s" \
                     %(label, millarr1.info().label_string(), millarr2.info().label_string(), operation))
        newarray = self.viewer.OperateOn2MillerArrays(millarr1, millarr2, operation)
      else:
        self.mprint("Creating %s data with array1 as %s through the operation:\n\n%s" \
                     %(label, millarr1.info().label_string(), operation))
        newarray = self.viewer.OperateOn1MillerArray(millarr1, operation)
      if newarray.data().size()==0:
        raise Sorry("No reflections in newly created array.")
    except Exception as e:
      self.mprint( str(e) + traceback.format_exc(limit=10), verbose=0)

    if newarray is None or newarray.data().size()==0:
      # allow user to quickly amend his broken python code without having to enter a new column label
      self.params.miller_array_operation = "" # do this by resetting phil parameter to the master default value
      self.currentphil = master_phil.format(python_object = self.params)
      # and process_PHIL_parameters() won't bail out with a "No change in PHIL parameters" message
    else:
      self.AddDataset2ExistingOnes(newarray, label, millarr1.info())
    return len(self.viewer.hkl_scenes_infos)-1 # return scene_id of this new miller_array


  def addCurrentVisibleMillerArray(self, label):
    for arr in self.procarrays:
      if label in arr.info().label_string():
        raise Sorry("Provide a label for the new miller array that isn't already used.")
    newarray = self.viewer.get_visible_current_miller_array()
    from copy import deepcopy
    self.AddDataset2ExistingOnes(newarray, label, deepcopy(self.viewer.miller_array.info()))


  def update_arrayinfos(self):
    self.viewer.array_info_format_tpl = []
    colnames_select_lst = []
    arrayinfo = []
    for array in self.procarrays:
      if type(array.data()) == flex.std_string: # in case of status array from a cif file
        uniquestrings = list(set(array.data()))
        info = array.info()
        array = array.customized_copy(data=flex.int([uniquestrings.index(d) for d in array.data()]))
        array.set_info(info)
      if array.space_group() is None:
        array._unit_cell = uc
        array._space_group_info = spg.info()
        self.mprint("""No unit cell or space group info present in the %d. miller array.
Borrowing them from the first miller array""" %i)
      wrap_labels = 25
      arrayinfo = ArrayInfo(array,wrap_labels)
      info_fmt, dummy, dummy2 = arrayinfo.get_selected_info_columns_from_phil(self.params )
      self.viewer.array_info_format_tpl.append( info_fmt )
      if len(colnames_select_lst) == 0:
        for philname,selected in list(self.params.selected_info.__dict__.items()):
          if not philname.startswith("__"):
            colnames_select_lst.append((philname, arrayinfo.caption_dict[philname], selected))
    return colnames_select_lst, arrayinfo


  def commitSubgroupDatasets(self):
    if self.params.commit_subgroup_datasets==False:
      return
    self.finish_dataloading(self.viewer.proc_arrays[:])
    self.viewer.HKLscenedict = {} # delete all cached scenes
    self.SendInfoToGUI({"file_name": self.loaded_file_name + " expanded"})
    # send file_name value separately from array_infotpls value since the former
    # clears NGL_HKLViewer.millertable of the contents of the array_infotpls
    self.SendInfoToGUI({ "array_infotpls": self.viewer.array_info_format_tpl })


  def AddDataset2ExistingOnes(self, newarray, label=None, info=None):
    self.mprint("New dataset has %d reflections." %newarray.size())
    if info is not None:
      newarray.set_info(info )
    if label is not None:
      newarray._info.labels = [ label ]
    if isinstance( newarray.sigmas(), flex.double):
      newarray._info.labels = [ label, "Sig" +label ]
    procarray, procarray_info = self.process_miller_array(newarray)
    self.procarrays.append(procarray)
    self.viewer.proc_arrays = self.procarrays[:]
    self.viewer.has_new_miller_array = True
    wrap_labels = 25
    arrayinfo = ArrayInfo(procarray,wrap_labels)
    info_fmt, headerstr, infostr = arrayinfo.get_selected_info_columns_from_phil(self.params )
    self.viewer.array_info_format_tpl.append( info_fmt )
    # isanomalous and spacegroup might not have been selected for displaying so send them separatately to GUI
    self.ano_spg_tpls.append((arrayinfo.isanomalous, arrayinfo.spginf) )
    # Storing this new miller_array in the origarrays dictionary allows making a table of the data later.
    # First create a superset of HKLs existing miller arrays and the new procarray.
    hkls = self.origarrays["HKLs"]
    m = miller.match_indices(procarray.indices(), hkls )
    # get subset of indices in hkls matching procarray.indices()
    indices_of_matched_hkls = m.pairs().column(1)
    # pad hkls with the indices only present in procarray.indices()
    hkls.extend(  procarray.indices().select( m.singles(0)) )
    # hkls is now a superset of indices.
    # Make temporary data array the size of hkls. This will be filled with datavalues
    # from procarray matching the order of indices in hkls
    datarr = flex.double(len(hkls), float("nan"))
    if isinstance( procarray.data(), flex.complex_double):
      datarr = flex.complex_double(len(hkls), float("nan"))
    # assign data values corresponding to matching indices to datarr
    m = miller.match_indices(procarray.indices(), hkls )
    # get single indices in hkls matching procarray.indices()
    indices_of_matched_hkls = m.pairs().column(1)
    for i,e in enumerate(indices_of_matched_hkls):
      datarr[e] = procarray.data()[i]
    # datarr is now a copy of data values in procarray but ordered to match the indices in hkls
    # join datarr to dictionary so it can be tabulated together with other data sets
    self.origarrays[newarray._info.labels[0]] = list(datarr)
    # If we have Sigmas then also store values and label for these in origarrays
    if isinstance( newarray.sigmas(), flex.double):
      sigarr = flex.double(len(hkls), float("nan"))
      for i,e in enumerate(indices_of_matched_hkls):
        sigarr[e] = procarray.sigmas()[i]
      self.origarrays[newarray._info.labels[1]] = list(sigarr)
    self.arrayinfos.append(arrayinfo)
    self.viewer.get_labels_of_data_for_binning(self.arrayinfos)
    mydict = { "array_infotpls": self.viewer.array_info_format_tpl,
              "ano_spg_tpls": self.ano_spg_tpls,
              "NewHKLscenes" : True,
              "NewMillerArray" : True
              }
    self.SendInfoToGUI(mydict)
    self.validated_preset_buttons = False
    self.viewer.include_tooltip_lst = [True] * len(self.viewer.proc_arrays)
    self.SendInfoToGUI({ "include_tooltip_lst": self.viewer.include_tooltip_lst })


  def run_external_cmd(self, diff_phil):
    # Run some python script like xtricorder with the exec function. Script can manipulate HKLViewFrame
    # by accessing functions and attributes on 'self' that is exported as a local variable in the
    # exec() function.
    # Get logfile name and tabname assigned by the script and send these to the HKLviewer GUI. Also
    # expecting retval and errormsg to be assigned within the script
    firstpart = os.path.splitext(os.path.basename(self.loaded_file_name))[0]# i.e. '4e8u' of '4e8u.mtz'
    firstpart =  firstpart.replace(".", "_") # dots in firstpart are renamed to underscores by phasertng
    if self.params.external_cmd == "runXtricorder":
      from crys3d.hklviewer.xtricorder_runner import external_cmd as external_cmd
    if self.params.external_cmd == "runXtriage":
      from crys3d.hklviewer.xtriage_runner import external_cmd as external_cmd
    try:
      def thrdfunc():
        self.mprint("run_external_cmd.thrdfunc() waiting for run_external_sem.acquire", verbose="threadingmsg")
        if not self.run_external_sem.acquire(timeout=jsview_3d.lock_timeout):
            self.mprint("Timed out getting run_external_sem semaphore within %s seconds" %jsview_3d.lock_timeout, verbose=1)
        parcpy = diff_phil.extract()
        parcpy.external_cmd = "None"
        diff2 = master_phil.fetch_diff(source =diff_phil.format(parcpy))
        ret = external_cmd(self, master_phil, firstpart)
        self.SendInfoToGUI( {"show_log_file_from_external_cmd": [ret.tabname, ret.logfname ]  } )
        self.validated_preset_buttons = False
        self.validate_preset_buttons()
        # reapply the phil paramaters that may have been reset by external_cmd doing an openfilename call
        self.guarded_process_PHIL_parameters(new_phil=diff2)
        self.run_external_sem.release()
        self.mprint("run_external_cmd.thrdfunc() releasing run_external_sem", verbose="threadingmsg")

      # Since process_PHIL_parameters() might be called by update_from_philstr() in external_cmd()
      # we run thrdfunc separately to avoid semaphore deadlock if entering process_PHIL_parameters() twice
      threading.Thread(target = thrdfunc, daemon=True).start()
    except Exception as e:
      self.SendInfoToGUI( {"show_log_file_from_external_cmd": -42 } )
      raise Sorry(str(e))


  def prepare_dataloading(self):
    self.viewer.isnewfile = True
    self.params.viewer.scene_id = None
    self.viewer.match_valarrays = []
    self.viewer.proc_arrays = []
    self.spacegroup_choices = []
    self.origarrays = {}
    display.reset_settings()
    self.hkls = display.settings()
    self.viewer.mapcoef_fom_dict = {}
    self.viewer.sceneid_from_arrayid = []
    self.hklfile_history = []
    self.tncsvec = None
    self.aniso1 = None
    self.aniso2 = None
    self.aniso3 = None
    self.loaded_file_name = ""


  def finish_dataloading(self, arrays):
    valid_arrays = []
    self.viewer.array_info_format_tpl = []
    spg = arrays[0].space_group()
    uc = arrays[0].unit_cell()
    self.ano_spg_tpls =[]
    self.mprint("%d Miller arrays in this dataset:" %len(arrays))
    spgset = set([])
    self.arrayinfos = []
    previous_ucell = None
    # origarrays dictionary is used for making a table of the data later.
    if len(self.origarrays.items()) == 0:
      self.origarrays["HKLs"] = arrays[0].indices()[:]
      for arr in arrays:
        if (arr.is_complex_array() or arr.is_hendrickson_lattman_array())==False:
          if arr.sigmas() == None:
            self.origarrays[arr.info().label_string()] = arr.data()
          else:
            self.origarrays[arr.info().labels[0]] = arr.data()
            self.origarrays[arr.info().labels[1]] = arr.sigmas()

    for i,array in enumerate(arrays):
      if type(array.data()) == flex.std_string: # in case of status array from a cif file
        uniquestrings = list(set(array.data()))
        info = array.info()
        array = array.customized_copy(data=flex.int([uniquestrings.index(d) for d in array.data()]))
        array.set_info(info)
      if i>0:
        if arrays[i-1].unit_cell() is not None:
          previous_ucell = arrays[i-1].unit_cell()
        if arrays[i-1].space_group() is not None:
          previous_spg = arrays[i-1].space_group()

      # A cif file might lack unit cell or space group for all the crystals in the file
      if array.unit_cell() is None:
        if previous_ucell is None:
          raise Sorry("No unit cell found in the first miller array.")
        array._unit_cell = previous_ucell
        self.mprint("""No unit cell present in the %d. miller array. Borrowing from previous miller array""" %i)
      if array.space_group() is None:
        symm_new = crystal.symmetry( unit_cell = previous_ucell,
                                    space_group_info = previous_spg.info()
                                    )
        info = array.info()
        array = array.customized_copy(crystal_symmetry = symm_new)
        array.set_info(info)
        self.mprint("""No space group present in the %d. miller array. Borrowing from previous miller array""" %i)
      if array.space_group() is None:
        raise Sorry("No space group definition found in the first miller array.")

      wrap_labels = 25
      arrayinfo = ArrayInfo(array,wrap_labels)
      info_fmt, headerstr, infostr = arrayinfo.get_selected_info_columns_from_phil(self.params )
      if i==0: # print formatted table of array info here
        self.mprint(headerstr)
      self.mprint(infostr)
      self.viewer.array_info_format_tpl.append( info_fmt )
      # isanomalous and spacegroup might not have been selected for displaying so send them separatately to GUI
      self.ano_spg_tpls.append((arrayinfo.isanomalous, arrayinfo.spginf) )
      spgset.add(arrayinfo.ucellinf)
      if i==0:
        # convert philstring of selected_info into a list so GUI can make a selection settings dialog
        # for what columns to show in the millertable
        colnames_select_lst = []
        for philname,selected in list(self.params.selected_info.__dict__.items()):
          if not philname.startswith("__"):
            colnames_select_lst.append((philname, arrayinfo.caption_dict[philname], selected))
        self.SendInfoToGUI({ "colnames_select_lst": colnames_select_lst })
      valid_arrays.append(array)
      self.arrayinfos.append(arrayinfo)
    self.valid_arrays = valid_arrays
    self.SendInfoToGUI({"spacegroup_info": arrayinfo.spginf, "unitcell_info": list(spgset) })

    if self.fileinfo:
      return
    if (len(valid_arrays) == 0):
      msg = "No arrays of the supported types present."
      self.mprint(msg)
      self.NewFileLoaded=False
    elif (len(valid_arrays) >= 1):
      array_info = self.process_all_miller_arrays(valid_arrays)
      self.viewer.proc_arrays = self.procarrays[:]
      self.viewer.identify_suitable_fomsarrays()
      self.viewer.set_miller_array(None, merge=array_info.merge,
         details=array_info.details_str)

      self.viewer.get_labels_of_data_for_binning(self.arrayinfos)
      self.update_space_group_choices(0) # get the default spacegroup choice
      mydict = { "info": self.infostr,
                  "ano_spg_tpls": self.ano_spg_tpls,
                  "html_url": self.viewer.url,
                  "tncsvec": self.tncsvec,
                  "merge_data": self.params.merge_data,
                  "spacegroups": [e.symbol_and_number() for e in self.spacegroup_choices],
                  "NewFileLoaded": self.NewFileLoaded,
                  "file_name": self.loaded_file_name
                }
      self.SendInfoToGUI(mydict)
    self.viewer.include_tooltip_lst = [True] * len(self.viewer.proc_arrays)
    self.SendInfoToGUI({ "include_tooltip_lst": self.viewer.include_tooltip_lst })


  def load_reflections_file(self, file_name):
    file_name = to_str(file_name)
    ret = False
    self.NewFileLoaded=True
    if (file_name != ""):
      if not os.path.isfile(file_name):
        raise Sorry(file_name + " doesn't exists")
      try :
        self.mprint("\nReading file %s..." %file_name)
        self.prepare_dataloading()
        hkl_file = any_reflection_file(file_name)
        arrays = hkl_file.as_miller_arrays(merge_equivalents=False, reconstruct_amplitudes=False)
        if hkl_file._file_type is None:
          raise Sorry(file_name + " seems not to be a reflection data file")
        self.origarrays = {}
        if hkl_file._file_type == 'cif':
          # use new cif label parser for reflections
          cifreader = hkl_file.file_content()
          cifarrays = cifreader.as_miller_arrays(merge_equivalents=False)
          arrays = [] # overwrite with simplified label strings
          for arr in cifarrays: # avoid these un-displayable arrays
            if arr.info().labels[-1] not in ['_refln.crystal_id',
                      'HKLs','_refln.wavelength_id', '_refln.scale_group_code']:
              arrays.append(arr)
          # sanitise labels by removing redundant strings.
          # remove the data name of this cif file from all labels
          dataname = list(hkl_file._file_content.builder._model.keys())
          unwantedstrings = dataname[:]
          # remove "_refln." from all labels
          unwantedstrings.append("_refln.")
          unwantedstrings.append("_refln_")
          for arr in arrays:
            if len(arr.info().labels):
              newlabels = []
              for label in arr.info().labels:
                found = False
                for s in unwantedstrings:
                  if s in label:
                    newlabel = label.replace(s, "")
                    found = True
                    if len(newlabel) > 0:
                      newlabels.append(newlabel)
                    break
                if not found:
                  newlabels.append(label)
                arr.info().labels = newlabels
          ciforigarrays = cifreader.as_original_arrays()[dataname[0]]
          for key in ciforigarrays:
            if key not in ['_refln.crystal_id', # avoid these un-displayable arrays
                      '_refln.wavelength_id', '_refln.scale_group_code']:
              self.origarrays[key] = ciforigarrays[key]
          # replace ? with nan in self.origarrays to allow sorting tables of data in HKLviewer
          for labl in self.origarrays.keys():
            origarray = self.origarrays[labl]
            for i,e in enumerate(self.origarrays[labl]):
              if e=="?":
                origarray[i] = "nan"
            try:
              self.origarrays[labl] = flex.double(origarray)
            except Exception as e:
              self.origarrays[labl] = origarray
        if hkl_file._file_type == 'ccp4_mtz':
          self.hklfile_history = list(hkl_file._file_content.history())
          for e in self.hklfile_history:
            if "TNCS" in e and "VECTOR" in e:
              svec = e.split()[-3:]
              t1 = float(svec[0])
              t2 = float(svec[1])
              t3 = float(svec[2])
              if (t1*t1 + t2*t2 + t3*t3) > 0.0:
                self.tncsvec = (t1, t2, t3)
                self.mprint("tNCS vector found in header of mtz file: %s" %str(self.tncsvec) )
            if "PHASER A" in e and len(e.split()) == 11:
              self.aniso1 = [ eval(f) for f in e.split()[2:5] ]
              self.aniso2 = [ eval(f) for f in e.split()[5:8] ]
              self.aniso3 = [ eval(f) for f in e.split()[8:11] ]
              self.mprint("Anisotropic principal axes found in header of mtz file: %s, %s, %s" \
                %(str(self.aniso1),str(self.aniso2),str(self.aniso3) ))
          from iotbx import mtz
          mtzobj = mtz.object(file_name)
          nanval = float("nan")
          # deep copy to avoid out of range errors elsewhere if user merges reflections and
          # we need to extend list of reflections
          self.origarrays["HKLs"] = mtzobj.extract_miller_indices()[:]
          for mtzlbl in mtzobj.column_labels():
            col = mtzobj.get_column( mtzlbl )
            newarr = col.extract_values_and_selection_valid().values.deep_copy()
            for i,b in enumerate(col.extract_values_and_selection_valid().selection_valid):
              if not b:
                newarr[i] = nanval
            self.origarrays[mtzlbl] = list(newarr)

        self.loaded_file_name = file_name
        self.finish_dataloading(arrays)
        self.SendInfoToGUI({"NewFileLoaded": self.NewFileLoaded})
      except Exception as e :
        self.NewFileLoaded=False
        self.mprint("".join(traceback.format_tb(e.__traceback__ )) + e.__repr__())
        arrays = []
      ret = True
    return ret


  def LoadReflectionsFile(self, openfilename):
    if not os.path.isfile(openfilename) and openfilename != "":
      raise Sorry('The file \"' + openfilename + "\" doesn't exists\n")
    self.params.openfilename = openfilename
    self.guarded_process_PHIL_parameters()


  def load_miller_arrays(self):
    ret = False
    try:
      if self.firsttime:
        self.ResetPhilandViewer(self.currentphil)
        self.prepare_dataloading()
        self.firsttime = False
      self.finish_dataloading(self.provided_miller_arrays)
      self.viewer.sceneisdirty = True
      self.viewer.has_new_miller_array = True
      ret = True
    except Exception as e :
      self.NewFileLoaded=False
      self.mprint("".join(traceback.format_tb(e.__traceback__ )) + e.__repr__())
      arrays = []
    return ret


  def LoadMillerArrays(self, marrays):
    self.provided_miller_arrays = marrays
    self.guarded_process_PHIL_parameters()
    self.params.use_provided_miller_arrays = True


  def SaveReflectionsFile(self, savefilename, datasets_to_save):
    if datasets_to_save is None or len(datasets_to_save) <1:
      self.mprint("Choose one or more datasets to save to a new datafile")
      return
    datasets_to_save.sort()
    if self.loaded_file_name == savefilename:
      self.mprint("Not overwriting currently loaded file. Choose a different name!")
      return
    self.mprint("Saving file...")
    fileextension = os.path.splitext(savefilename)[1]
    if fileextension == ".mtz":
      idx1 = datasets_to_save[0]
      # create mtzdata file from the first selected dataset
      mtz1 = self.viewer.proc_arrays[idx1].as_mtz_dataset(column_root_label= self.viewer.proc_arrays[idx1].info().labels[0])
      for i,arr in enumerate(self.viewer.proc_arrays):
        if i not in datasets_to_save[1:]: # add the other selected datasets to the mtzfile
          continue
        mtz1.add_miller_array(arr, column_root_label=arr.info().labels[0] )
      try: # python2 or 3
        mtz1.mtz_object().write(savefilename)
      except Exception as e:
        mtz1.mtz_object().write(savefilename.encode("ascii"))
      self.mprint("Miller array(s) saved to: " + savefilename)
    elif fileextension == ".cif":
      import iotbx.cif
      mycif = None
      fname = savefilename
      fnames = []

      def save2cif(filename, mycif):
        with open(filename.encode("ascii"), "w") as f:
          f.write("data_%s\n#\n" %os.path.splitext(os.path.basename(filename))[0])
          print(mycif.cif_block, file= f)

      for i,arr in enumerate(self.viewer.proc_arrays):
        if i not in datasets_to_save: # add the selected datasets to the mtzfile
          continue
        arrtype = None
        colnames = ["_refln.%s" %e for e in arr.info().labels ]
        colname= None
        if self.has_indices_with_multiple_data(arr):
          # if array contains data with more than one data point for the same hkl index iotbx.cif
          # cannot add additional arrays to the cif block so save this array in a separate file
          singlecif = iotbx.cif.miller_arrays_as_cif_block(arr, array_type = arrtype,
                                                       column_name=colname, column_names = colnames )
          fname = os.path.splitext(savefilename)[0] + "_%d"%i + os.path.splitext(savefilename)[1]
          save2cif(fname, singlecif)
          fnames.append(fname)
          continue
        if not mycif:
          mycif = iotbx.cif.miller_arrays_as_cif_block(arr, array_type = arrtype,
                                                       column_name=colname, column_names = colnames )
        else:
          mycif.add_miller_array(arr, column_name= colname, array_type= arrtype,
                                 column_names = colnames)
      if mycif:
        save2cif(savefilename, mycif)
        fnames.append(savefilename)
      self.mprint("Miller array(s) saved to: " + ",\n".join(fnames))
      if len(fnames) > 1:
        self.mprint("Unmerged data put into separate files")
    else:
      self.mprint("Can only save file in MTZ or CIF format. Sorry!")


  def get_label_from_phasertng_tag(self, tngcolumn_tags):
    tngcols = []
    # Say tngcolumn_tags = "INAT,SIGINAT" and mtz history looks like:
    # PHASER LABIN INAT/I<<FW/J SIGINAT/SIGI<<FW/Q IPOS/I(+)<<I/K
    # PHASER LABIN SIGIPOS/SIGI(+)<<SIGI/M INEG/I(-)<<I/K SIGINEG/SIGI(-)<<SIGI/M
    # then m would look like [('INAT', 'SIGINAT')]. Concatenate the strings before returning
    label = ""
    for e in self.hklfile_history:
      for tngcolumn_tag in tngcolumn_tags.split(","):
        m =  re.findall(tngcolumn_tag + r'/(\S*)/', e, re.VERBOSE)
        if len(m) > 0:
          tngcols.append(m[0])
    if len(tngcols):
      label = ",".join(tngcols)
    return label


  def validate_preset_buttons(self):
    if not self.validated_preset_buttons:
      activebtns = []
      # look for strings like data_array.label="F,SIGFP" and see if that data column exists in the file
      uniquebtnids = set([])
      if self.viewer.miller_array is not None:
        ma = self.viewer.miller_array
      elif len(self.procarrays):
        ma = self.procarrays[0]
      else:
        ma = -1

      self.mprint("Preset buttons:", verbose=1)
      for ibtn,(btn_id, btnlabel, philstr) in enumerate(self.allbuttonslist):
        button_fate_decided = False
        if btn_id not in uniquebtnids:
          uniquebtnids.add(btn_id)
        else:
          raise Sorry("Button ID, %s, has already been used by another button." %btn_id)

        btnphil = libtbx.phil.parse(philstr)
        philstr_label = None
        philstr_type = None
        phasertng_tag = None
        philstr_showvectors = []
        philstr_user_vectors_labels = []
        millaroperationstr = None
        if jsview_3d.has_phil_path(btnphil, "data_array", "show_vector", "miller_array_operation"):
          btnphilobj, unusedparms = master_phil.fetch(btnphil, track_unused_definitions=True)
          for parm in unusedparms:
            self.mprint( "Preset button, %s, has unrecognised phil parameter:\n   %s" %(btn_id, parm.path), verbose=1)
          btnphilextract = btnphilobj.extract()
          if btnphilextract.viewer.data_array.label is not None:
            philstr_label = btnphilextract.viewer.data_array.label
          if btnphilextract.viewer.data_array.datatype is not None:
            philstr_type = btnphilextract.viewer.data_array.datatype
          if btnphilextract.viewer.data_array.phasertng_tag is not None:
            phasertng_tag = btnphilextract.viewer.data_array.phasertng_tag
            # find the miller array used by phasertng as specified in the mtz history header
            philstr_label = [ self.get_label_from_phasertng_tag(",".join(phasertng_tag)) ]
          if len(btnphilextract.viewer.show_vector) > 0:
            philstr_showvectors = btnphilextract.viewer.show_vector
          if len(btnphilextract.viewer.user_vector) > 0:
            if ma==-1:
              continue
            for uvec in btnphilextract.viewer.user_vector:
              if uvec.hkl_op != "": # then verify this operation is commensurate with the spacegroup
                rt = sgtbx.rt_mx(symbol=uvec.hkl_op, r_den=12, t_den=144)
                (cartvec, a, rotlabel, order) = self.viewer.GetVectorAndAngleFromRotationMx( rt.r(), ma)
                if rotlabel =="" or order==0:
                  self.mprint("\"%s\" is disabled because HKL operation, \"%s\", is not a rotation in space group %s" \
                   %(btnlabel, uvec.hkl_op, ma.space_group().info().symbol_and_number()), verbose=1)
                  button_fate_decided = True
                  break
              else:
                philstr_user_vectors_labels.append( uvec.label)
          if button_fate_decided:
            continue

          if btnphilextract.miller_array_operation != "":
# The miller array operation part in the philstr could look like:
# miller_array_operation = "('newarray._data = array1.data()/array1.sigmas()\\nnewarray._sigmas = None', 'IoverSigI', ['I<<FSQ,SIGI<<FSQ', 'Intensity'], ['', ''])"
# We want to capture 'I<<FSQ,SIGI<<FSQ' and 'Intensity' strings which will be in arr1label and arr1type
            millaroperationstr, millarrlabel, (arr1label, arr1type), (arr2label, arr2type) = \
                                                     eval( btnphilextract.miller_array_operation)
        nvectorsfound = len(philstr_showvectors)
        veclabels = []
        philveclabel = ""
        if philstr_showvectors:
          nvectorsfound = 0
          for iphilvec,philstrvec in enumerate(philstr_showvectors):
            philveclabel, philshowvec = eval(philstrvec)
            for opnr, veclabel, order, cartvec, hklop, hkl, abc, length in self.viewer.all_vectors:
              # allow label to be just a substring of veclabel
              philstr_userlbl = ""
              for lbl in philstr_user_vectors_labels:
                if lbl == veclabel: # button phil defines a user vector matching the show vector
                  philstr_userlbl = lbl
                  break
              if philshowvec and philveclabel in veclabel:
                nvectorsfound +=1
                if len(philveclabel) < len(veclabel):
                  if philstr_userlbl:
                    veclabels.append(philstr_userlbl)
                  else:
                    veclabels.append(veclabel)
            if (iphilvec+1) > nvectorsfound:
              self.mprint("\"%s\" is disabled until a vector, \"%s\", has been " \
                   "found in a dataset or by manually adding this vector." %(btnlabel, philveclabel), verbose=1)
        miller_array_operation_can_be_done = False
        if millaroperationstr:
          datalabel1 = None
          datalabel2 = ""
          for _, _, _, datalabel, datatype, _, _ in self.viewer.hkl_scenes_infos:
            if datalabel == arr1label:
              datalabel1 = datalabel
              break
          if not datalabel1:
            for _, _, _, datalabel, datatype, _, _ in self.viewer.hkl_scenes_infos:
              if datatype == arr1type:
                datalabel1 = datalabel
                break
          # if also using a second miller array for the operation then check a matching one is
          # present in the datafile
          if arr2label:
            datalabel2 = None
            for _, _, _, datalabel, datatype, _, _ in self.viewer.hkl_scenes_infos:
              if datalabel == arr2label:
                datalabel2 = datalabel
                break
            if not datalabel2:
              for _, _, _, datalabel, datatype, _, _ in self.viewer.hkl_scenes_infos:
                if datatype == arr2type:
                  datalabel2 = datalabel
                  break
          if datalabel1 is not None and datalabel2 is not None:
            miller_array_operation_can_be_done = True
          if miller_array_operation_can_be_done and nvectorsfound >= len(philstr_showvectors):
            self.mprint("\"%s\" declared using %s and %s is assigned to data %s of type %s." \
                          %(btnlabel, arr1label, arr1type, datalabel, datatype), verbose=1)
            if len(datalabel2)>0:
              activebtns.append((self.allbuttonslist[ibtn], datalabel1 + " and " + datalabel2,
                                 millaroperationstr, None))
            else:
              activebtns.append((self.allbuttonslist[ibtn], datalabel1, millaroperationstr, None))
          else:
            self.mprint("\"%s\" declared using %s and %s is not assigned to any dataset." \
                            %(btnlabel, arr1label, arr1type), verbose=1)
        if philstr_label is not None and millaroperationstr is None:
          labeltypefound = False
          for inflst, pidx, fidx, datalabel, datatype, hassigmas, sceneid in self.viewer.hkl_scenes_infos:
            if datalabel == philstr_label:
              labeltypefound = True
              break
          if not labeltypefound:
            for inflst, pidx, fidx, datalabel, datatype, hassigmas, sceneid in self.viewer.hkl_scenes_infos:
              if philstr_type is not None and philstr_type == datatype:
                labeltypefound = True
                break
          if labeltypefound and nvectorsfound >= len(philstr_showvectors):
            self.mprint("\"%s\" assigned to dataset %s of type %s." \
                          %(btnlabel + str(veclabels), datalabel, datatype), verbose=1)
            activebtns.append((self.allbuttonslist[ibtn], datalabel, "", (philveclabel, veclabels) ))
          else:
            self.mprint("\"%s\" expecting dataset of type \"%s\" has not been assigned to any dataset." \
                              %(btnlabel, philstr_type), verbose=1)
      self.SendInfoToGUI({"enable_disable_preset_buttons": str(activebtns)})
    self.validated_preset_buttons = True


  def convert_clipperdict_to_millerarrays(self, crystdict):
    """
    Called in zmq_listen() when Chimerax with Isolde sends clipper arrays to
    our zmqsocket from HKLviewer.ProcessMessages()
    """
    xs = crystal.symmetry(unit_cell=crystdict["unit_cell"], space_group_symbol= crystdict["spg_number"] )
    mi = flex.miller_index(crystdict["HKL"])
    lst = list(crystdict.keys())
    lst.remove('HKL')
    lst.remove('unit_cell')
    lst.remove('spg_number')
    clipperlabel = lst[0]
    Flabl, Siglabl = clipperlabel.split(", ")
    data = flex.double(crystdict[clipperlabel][0])
    sigmas = flex.double(crystdict[clipperlabel][1])
    marray = miller.array( miller.set(xs, mi, anomalous_flag=False),
                         data, sigmas).set_observation_type( observation_types.amplitude())
    marray.set_info(miller.array_info(source="Isolde", labels=[Flabl, Siglabl]))

    fcamplitudes = flex.double(crystdict["FCALC,PHFCALC"][0])
    fcphases = flex.double(crystdict["FCALC,PHFCALC"][1])
    mapcoeffarray = miller.array( miller.set(xs, mi, anomalous_flag=False), fcamplitudes)
    mapcoeffarray = mapcoeffarray.phase_transfer(fcphases, deg=False)
    mapcoeffarray.set_info(miller.array_info(source="Isolde", labels=["FCALC", "PHFCALC"]))

    wamplitudes = flex.double(crystdict["2FOFC,PH2FOFC"][0])
    wphases = flex.double(crystdict["2FOFC,PH2FOFC"][1])
    wmapcoeffarray = miller.array( miller.set(xs, mi, anomalous_flag=False), wamplitudes)
    wmapcoeffarray = wmapcoeffarray.phase_transfer(wphases, deg=False)
    wmapcoeffarray.set_info(miller.array_info(source="Isolde", labels=["2FOFC", "PH2FOFC"]))

    self.LoadMillerArrays([marray, mapcoeffarray, wmapcoeffarray])


  def has_indices_with_multiple_data(self, arr):
    return len(set(list(arr.indices()))) < arr.size()


  def tabulate_arrays(self, datalabels):
    if len(self.origarrays) == 0: # if not an mtz file then split columns
      self.origarrays["HKLs"] = self.viewer.proc_arrays[0].indices()[:]
      for arr in self.viewer.proc_arrays:
        if arr.is_complex_array():
          ampls, phases = self.viewer.Complex2AmplitudesPhases(arr.data())
          cmplxlst = [ "%.4f + %.4f * i"%(e.real, e.imag)
                        if not cmath.isnan(e) else display.nanval for e in arr.data() ]
          self.origarrays[arr.info().label_string()] = cmplxlst
          self.origarrays[arr.info().labels[0]] = list(ampls)
          self.origarrays[arr.info().labels[-1]] = list(phases)
        elif arr.is_hendrickson_lattman_array():
          A,B,C,D = arr.data().as_abcd()
          HLlst = [ "%.4f, %.4f, %.4f, %.4f"%(e[0], e[1], e[2], e[3]) for e in arr.data() ]
          self.origarrays[arr.info().label_string()] = HLlst
          self.origarrays[arr.info().labels[0]] = list(A)
          self.origarrays[arr.info().labels[1]] = list(B)
          self.origarrays[arr.info().labels[2]] = list(C)
          self.origarrays[arr.info().labels[3]] = list(D)
        elif arr.sigmas() is not None:
          labels = arr.info().labels
          # Labels could be something like ['I(+)', 'SIGI(+)', 'I(-)', 'SIGI(-)'].
          # So group datalabels and sigmalabels separately assuming that sigma column contain the three letters "sig"
          datalabel = ",".join([ e for e in labels if "sig" not in e.lower()])
          sigmalabel = ",".join([ e for e in labels if "sig" in e.lower()])
          self.origarrays[datalabel] = list(arr.data())
          self.origarrays[sigmalabel] = list(arr.sigmas())
        elif arr.is_integer_array():
          list_with_nans = [ e if not e==display.inanval else display.nanval for e in arr.data() ]
          if self.viewer.array_info_format_tpl[id][0] == 'FreeR_flag': # want True or False back
            list_with_nans = [ 1==e if not cmath.isnan(e) else display.nanval for e in list_with_nans ]
          self.origarrays[arr.info().label_string()] = list_with_nans
        else:
          self.origarrays[arr.info().label_string()] = list(arr.data())

    indices = self.origarrays["HKLs"]
    dres = self.procarrays[0].unit_cell().d( indices)
    dreslst = [("d_res", roundoff(list(dres)),3)]
    hkls = list(indices)
    hkllst = [ ("H", [e[0] for e in hkls] ), ("K", [e[1] for e in hkls] ), ("L", [e[2] for e in hkls] )]
    datalst = []
    labellists = eval(datalabels)
    for labels in labellists:
      crystlbl = ""; wavelbl = ""; scalelbl =""
      for i,label in enumerate(labels):
        if "crystal_id" in label:
          crystlbl = "," + label
        if "wavelength_id" in label:
          wavelbl = "," + label
        if "scale_group_code" in label:
          scalelbl = "," + label
      for label in labels:
        if "crystal_id" in label or "wavelength_id" in label or "scale_group_code" in label:
          continue
        fulllabel = label + crystlbl + wavelbl + scalelbl
        pydatlst = list(self.origarrays[fulllabel])
        # If a merged array has been created by the user pydatlst could be shorter than len(hkls).
        # pydatlst must have the same size as hkls when received by helpers.MillerArrayTableModel()
        # If it is not, then pad nan values at the end to make up for it.
        # Otherwise the tabulated reflection data won't display correctly
        if len(pydatlst) < len(hkls):
          pydatlst.extend( [float("nan")]*(len(hkls)-len(pydatlst) ))
        datalst.append( (label, pydatlst))
    self.idx_data = hkllst + dreslst + datalst
    self.mprint("Sending table data...", verbose=0)
    mydict = { "tabulate_miller_array": self.idx_data }
    self.params.tabulate_miller_array_ids = "[]" # to allow reopening a closed window again
    self.SendInfoToGUI(mydict)


  def TabulateMillerArray(self, ids):
    self.params.tabulate_miller_array_ids = str(ids)
    self.guarded_process_PHIL_parameters()


  def SetCameraType(self, camtype):
    self.params.NGL.camera_type = camtype
    self.guarded_process_PHIL_parameters()


  def ExpandToP1(self, val):
    self.params.hkls.expand_to_p1 = val
    self.guarded_process_PHIL_parameters()


  def ExpandAnomalous(self, val):
    self.params.hkls.expand_anomalous = val
    self.guarded_process_PHIL_parameters()


  def ShowOnlyMissing(self, val):
    self.params.hkls.show_only_missing = val
    self.guarded_process_PHIL_parameters()


  def ShowMissing(self, val):
    self.params.hkls.show_missing = val
    self.guarded_process_PHIL_parameters()


  def ShowDataOverSigma(self, val):
    self.params.hkls.show_data_over_sigma = val
    self.guarded_process_PHIL_parameters()


  def ShowSystematicAbsences(self, val):
    self.params.hkls.show_systematic_absences = val
    self.guarded_process_PHIL_parameters()


  def ShowSlice(self, val, axis="h", index=0):
    axisstr = axis.lower()
    self.params.hkls.slice_mode = val
    self.params.hkls.slice_axis = axisstr
    self.params.hkls.slice_index = index
    self.guarded_process_PHIL_parameters()


  def set_scene_bin_thresholds(self, thresholds = None, binner_idx = 0,  nbins = 6):
    nuniquevalues = -1
    if thresholds is None or thresholds == []:
      binvals, nuniquevalues = self.viewer.calc_bin_thresholds(binner_idx, nbins)
    else:
      # put nan value at the end as not to mess up binvals since nan values cannot be sorted
      binvals = [e for e in thresholds if not math.isnan(e)] + [float("nan")]
    if thresholds and binner_idx == 0: # binner_idx=0 is for binning against resolution
      binvals = list( 1.0/flex.double(binvals) )
    self.viewer.UpdateBinValues(binner_idx, binvals, nuniquevalues)


  def SetSceneNbins(self, nbins, binner_idx = 0):
    self.params.nbins = nbins
    self.params.binning.binner_idx = binner_idx
    self.params.binning.bin_opacity = [ [1.0, e] for e in range(nbins) ]
    self.guarded_process_PHIL_parameters()


  def GetNumberingOfBinners(self):
    return [ (i,e) for i,e in enumerate(self.viewer.bin_labels_type_idxs) ]


  def SetSceneBinThresholds(self, thresholds=None):
    if thresholds==None:
      self.params.scene_bin_thresholds = []
    else:
      self.params.scene_bin_thresholds = thresholds[:]
    self.params.nbins = len(binvals)
    self.guarded_process_PHIL_parameters()


  def SetOpacities(self, bin_opacities):
    #self.params.bin_opacities = str(bin_opacities)
    self.params.bin_opacities = bin_opacity
    self.guarded_process_PHIL_parameters()


  def SetToolTipOpacity(self, val):
    self.params.NGL.tooltip_alpha = val
    self.guarded_process_PHIL_parameters()


  def SetShowToolTips(self, val):
    self.params.NGL.show_tooltips = val
    self.guarded_process_PHIL_parameters()


  def set_scene(self, scene_id):
    if scene_id is None:
      return False
    self.viewer.set_miller_array(scene_id)
    if (self.viewer.miller_array is None):
      raise Sorry("No data loaded!")
    self.mprint( "Miller array %s runs from hkls: %s to %s" \
     %(self.viewer.miller_array.info().label_string(), self.viewer.miller_array.index_span().min(),
        self.viewer.miller_array.index_span().max() ) )
    self.mprint("Spacegroup: %s" %self.viewer.miller_array.space_group().info().symbol_and_number())
    return True


  def SetScene(self, scene_id):
    self.params.viewer.scene_id = scene_id
    self.guarded_process_PHIL_parameters()


  def SetMergeData(self, val):
    self.params.merge_data = val
    self.guarded_process_PHIL_parameters()


  def SetRadiiScale(self, scale=1.0, nth_power_scale = float("nan")):
    """
    Scale radii. Decrease the contrast between large and small radii with nth_root_scale < 1.0
    If nth_power_scale=0 then all radii will have the same size regardless of data values.
    If nth_power_scale=NaN an automatic power will be computed ensuring the smallest radius
    is 0.1 times the maximum radius
    """
    self.params.hkls.scale = scale
    self.params.hkls.nth_power_scale_radii = nth_power_scale
    self.guarded_process_PHIL_parameters()


  def SetColourRadiusToSigmas(self, val):
    self.params.hkls.sigma_color_radius = val
    self.guarded_process_PHIL_parameters()


  def SetColourScheme(self, color_scheme, color_powscale=1.0):
    self.params.hkls.color_scheme = color_scheme
    self.params.hkls.color_powscale = color_powscale
    self.guarded_process_PHIL_parameters()


  def SetAction(self, val):
    self.params.action = val
    self.guarded_process_PHIL_parameters()


  def set_action(self, val):
    if val == "reset_view":
      self.viewer.SetAutoView()
    if val == "is_terminating": # sent from NGL_HKLViewer.closeEvent()
      self.__exit__() # releases javascript resources
      return False
    return True


  def list_vectors(self):
    self.viewer.calc_rotation_axes(ma=self.procarrays[0] )
    self.viewer.all_vectors = self.viewer.rotation_operators[:]
    if self.viewer.miller_array is not None:
      uc = self.viewer.miller_array.unit_cell()
    elif len(self.procarrays):  # a fallback
      uc = self.procarrays[0].unit_cell()
    else:
      self.viewer.all_vectors = []
      return self.viewer.all_vectors

    tncsvec = []
    if self.tncsvec is not None:
      # tNCS vector from xtricorder is specified in realspace fractional coordinates. Convert it to cartesian
      cartvec = list( self.tncsvec * matrix.sqr(uc.orthogonalization_matrix()) )
      ln = len(self.viewer.all_vectors)
      veclength = self.viewer.renderscale/math.sqrt( cartvec[0]*cartvec[0] + cartvec[1]*cartvec[1] + cartvec[2]*cartvec[2] )
      tncsvec = [("tNCS_xtricorder", 0, cartvec, "", "", str(roundoff(self.tncsvec, 5)), veclength )]

    anisovectors = []
    if self.aniso1 is not None:
      # anisotropic principal axes vector are specified in cartesian coordinates.
      cartvec = [self.aniso1[0]*self.viewer.renderscale, self.aniso1[1]*self.viewer.renderscale, self.aniso1[2]*self.viewer.renderscale]
      # convert vector to fractional coordinates for the table in the GUI
      aniso1frac = list(cartvec * matrix.sqr(uc.fractionalization_matrix()))
      veclength = self.viewer.renderscale/math.sqrt( cartvec[0]*cartvec[0] + cartvec[1]*cartvec[1] + cartvec[2]*cartvec[2] )
      anisovectors = [("Anisotropy1", 0, cartvec, "", "", str(roundoff(aniso1frac, 5)), veclength )]

      cartvec = [self.aniso2[0]*self.viewer.renderscale, self.aniso2[1]*self.viewer.renderscale, self.aniso2[2]*self.viewer.renderscale]
      # convert vector to fractional coordinates for the table in the GUI
      aniso2frac = list(cartvec * matrix.sqr(uc.fractionalization_matrix()))
      veclength = self.viewer.renderscale/math.sqrt( cartvec[0]*cartvec[0] + cartvec[1]*cartvec[1] + cartvec[2]*cartvec[2] )
      anisovectors.append(("Anisotropy2", 0, cartvec, "", "", str(roundoff(aniso2frac, 5)), veclength ) )

      cartvec = [self.aniso3[0]*self.viewer.renderscale, self.aniso3[1]*self.viewer.renderscale, self.aniso3[2]*self.viewer.renderscale]
      # convert vector to fractional coordinates for the table in the GUI
      aniso3frac = list(cartvec * matrix.sqr(uc.fractionalization_matrix()))
      veclength = self.viewer.renderscale/math.sqrt( cartvec[0]*cartvec[0] + cartvec[1]*cartvec[1] + cartvec[2]*cartvec[2] )
      anisovectors.append( ("Anisotropy3", 0, cartvec, "", "", str(roundoff(aniso3frac, 5)), veclength ) )

    ln = len(self.viewer.all_vectors)
    Hcartvec = list( self.viewer.renderscale*( (1,0,0)*matrix.sqr(uc.fractionalization_matrix()).transpose()) )
    Kcartvec = list( self.viewer.renderscale*( (0,1,0)*matrix.sqr(uc.fractionalization_matrix()).transpose()) )
    Lcartvec = list( self.viewer.renderscale*( (0,0,1)*matrix.sqr(uc.fractionalization_matrix()).transpose()) )
    Hlength = math.sqrt( Hcartvec[0]*Hcartvec[0] + Hcartvec[1]*Hcartvec[1] + Hcartvec[2]*Hcartvec[2] )
    Klength = math.sqrt( Kcartvec[0]*Kcartvec[0] + Kcartvec[1]*Kcartvec[1] + Kcartvec[2]*Kcartvec[2] )
    Llength = math.sqrt( Lcartvec[0]*Lcartvec[0] + Lcartvec[1]*Lcartvec[1] + Lcartvec[2]*Lcartvec[2] )
    hklunit_vectors = [ ("H-axis (1,0,0)", 0, Hcartvec, "", "(1,0,0)", "", Hlength ),
                        ("K-axis (0,1,0)", 0, Kcartvec, "", "(0,1,0)", "", Klength ),
                        ("L-axis (0,0,1)", 0, Lcartvec, "", "(0,0,1)", "", Llength )]

    all_vecs = hklunit_vectors + tncsvec + anisovectors + self.viewer.rotation_operators[:] + self.uservectors
    self.viewer.all_vectors = []
    for opnr,(label, order, cartvec, hkl_op, hkl, abc, length) in enumerate(all_vecs):
      self.viewer.all_vectors.append( (opnr, label, order, cartvec, hkl_op, hkl, abc, length) )

    for (opnr, label, order, cartvec, hkl_op, hkl, abc, length) in self.viewer.all_vectors:
      # avoid onMessage-DrawVector in HKLJavaScripts.js misinterpreting the commas in strings like "-x,z+y,-y"
      name = label + hkl_op.replace(",", "_")
      self.viewer.RemovePrimitives(name)
    self.SendInfoToGUI( { "all_vectors": self.viewer.all_vectors } )
    return self.viewer.all_vectors


  def add_user_vector(self, philuser_vectors, rectify_improper_rotation=False):
    uc = self.viewer.miller_array.unit_cell()
    try:
      for phil_uvec in philuser_vectors:
        label = phil_uvec.label
        userveclabels = [ e[0] for e in self.uservectors ]
        if label in userveclabels:
          continue
        order = 0
        hklvec = ""
        abcvec = ""
        hklop = ""
        unwantedchars = " |(|)|[|]|{|}"
        # individual characters separated by | substituted with a "" using re.sub()
        if phil_uvec.hkl not in [None, "", "()"]:
          hklvec = eval(re.sub(unwantedchars, "", phil_uvec.hkl))
          # convert into cartesian space
          cartvec = list( self.viewer.renderscale*(hklvec * matrix.sqr(uc.fractionalization_matrix()).transpose()) )
          veclength = math.sqrt( cartvec[0]*cartvec[0] + cartvec[1]*cartvec[1] + cartvec[2]*cartvec[2] )
        elif phil_uvec.abc not in [None, "", "()"]:
          abcvec = eval(re.sub(unwantedchars, "", phil_uvec.abc))
          # convert into cartesian space
          cartvec = list(abcvec * matrix.sqr(uc.orthogonalization_matrix()))
          # length unit used by a realspace vector in reciprocal space is the inverse of its realspace length
          veclength = self.viewer.renderscale/math.sqrt( cartvec[0]*cartvec[0] + cartvec[1]*cartvec[1] + cartvec[2]*cartvec[2] )
        elif phil_uvec.hkl_op not in [None, ""]:
          hklop = re.sub(unwantedchars, "", phil_uvec.hkl_op)
          rt = sgtbx.rt_mx(symbol=hklop, r_den=12, t_den=144)
          self.viewer.symops.append( rt ) #
          (cartvec, a, rotlabel, order) = self.viewer.GetVectorAndAngleFromRotationMx( rt.r(),
                                                    rectify_improper_rotation=rectify_improper_rotation )
          veclength = math.sqrt( cartvec[0]*cartvec[0] + cartvec[1]*cartvec[1] + cartvec[2]*cartvec[2] )
          if rotlabel:
            label = "%s-fold_%s" %(str(int(roundoff(2*math.pi/a, 0))), label)
            if label in userveclabels:
              continue # this vector label is already there. Don't add it
            self.mprint("Rotation axis, %s, added" %rotlabel)
          if rotlabel =="" or order==0:
            self.mprint("Cannot compute a rotation axis from %s" %phil_uvec.hkl_op)
            return
        vecundefined = (phil_uvec.hkl in [None, "", "()"] \
         and phil_uvec.abc in [None, "", "()"] \
         and phil_uvec.hkl_op in [None, ""])
        if not vecundefined:
          if phil_uvec.label in [None, ""]:
            raise Sorry("Specify user_vector properly!")
          self.uservectors.append( (label, order, cartvec, hklop, str(hklvec), str(abcvec), veclength ))
      self.list_vectors()
    except Exception as e:
      raise Sorry( str(e))


  def AddUserVector(self, hkl_op="", abc="", hkl="", label=""):
    """
    Vector can be specified as a rotation operator, say "-h-k,k,-l" subject to spacegroup contraints,
    as a fractional vector in real space or as a fractional vector in reciprocal space. If
    specified as a rotation operator the derived vector is the implicit rotation axis.
    """
    self.params.viewer.user_label = label
    self.params.viewer.add_user_vector_hkl_op = str(hkl_op)
    self.params.viewer.add_user_vector_abc = str(abc)
    self.params.viewer.add_user_vector_hkl = str(hkl)
    self.guarded_process_PHIL_parameters()


  def ShowVector(self, val, b=True):
    self.params.viewer.show_vector = [str([val, b])]
    self.guarded_process_PHIL_parameters()


  def ShowUnitCell(self, val):
    self.params.show_real_space_unit_cell = val
    self.guarded_process_PHIL_parameters()


  def ShowReciprocalUnitCell(self, val):
    self.params.show_reciprocal_unit_cell = val
    self.guarded_process_PHIL_parameters()


  def SetClipPlane(self, use=True, hkldist=0.0, clipwidth=2.0):
    if use:
      self.params.clip_plane.hkldist = hkldist
      self.params.clip_plane.clip_width = clipwidth
      self.params.hkls.slice_mode = False
    else:
      self.params.clip_plane.clip_width = None
    self.guarded_process_PHIL_parameters()


  def AnimateRotateAroundVector(self, vecnr, speed):
    self.params.viewer.animate_rotation_around_vector = str([vecnr, speed])
    self.guarded_process_PHIL_parameters()


  def RotateAroundVector(self, vecnr, dgr):
    self.params.viewer.angle_around_vector = str([vecnr, dgr])
    self.guarded_process_PHIL_parameters()


  def ShowHKL(self, hkl):
    self.params.viewer.show_hkl = str(hkl)
    self.guarded_process_PHIL_parameters()


  def SetMouseSpeed(self, trackspeed):
    self.params.NGL.mouse_sensitivity = trackspeed
    self.guarded_process_PHIL_parameters()


  def GetMouseSpeed(self):
    self.viewer.GetMouseSpeed()
    return self.params.NGL.mouse_sensitivity


  def GetSpaceGroupChoices(self):
    """
    return array of strings with available subgroups of the space group
    """
    if (self.viewer.miller_array is None) :
      self.mprint( NOREFLDATA)
    if self.spacegroup_choices:
      return [e.symbol_and_number() for e in self.spacegroup_choices]
    return []


  def SaveImageName(self, fname):
    self.viewer.MakeImage(fname)


  def GetHtmlURL(self):
    return self.viewer.url


  def GetHtmlstring(self):
    return self.viewer.htmlstr


  def GetArrayInfotpls(self):
    """
    return array of tuples with information on each miller array
    """
    return self.viewer.array_info_format_tpl


  def GetSceneDataLabels(self):
    return [ e[3][0] for e in myHKLview.viewer.hkl_scenes_infos ]


  def GetHklScenesInfos(self):
    """
    return array of strings with information on each processed miller array
    which may have been expanded with anomalous reflections or truncated to non-anomalous reflections
    as to match the currently selected miller array
    """
    return self.viewer.hkl_scenes_infos


  def GetBinInfo(self):
    """
    return array of number of hkls and bin boundaries of the bins the current miller array data has been sorted into.
    Useful when deciding which bin of reflections to make transparent
    """
    return self.viewer.binstrs


  def SendInfoToGUI(self, infodict, binary=True):
    if self.guiSocketPort:
      m = str(infodict).encode("utf-8")
      if not binary:
        self.guisocket.send( m )
      else:
        if type(m) is not bytes:
          m = bytes(m)
        bindict = zlib.compress( m )
        self.guisocket.send( bindict )
    else:
      if infodict.get("closing_time", False):
        return




master_phil_str = """
  openfilename = None
    .type = path
    .help = "Name of file with one or more datasets"
  use_provided_miller_arrays = False
    .type = bool
    .help = "internal flag"
  savefilename = None
    .type = path
    .help = "Name of file where the user wants to save datasets. Optionally used after making new datasets from existing ones"
  datasets_to_save = None
    .type = ints
    .help = "Indices in the list of datasets on the Details tab to save. If list is empty or None all datasets will be saved"
  visible_dataset_label = None
    .type = path
    .help = "User supplied label for a new dataset of visible reflections, i.e. those which have opacity=1"
  save_image_name = None
    .type = path
    .help = "Name of image file (PNG format) where the current displayed reflections will be saved to at the users request"
  external_cmd = *None runXtricorder runXtriage
    .type = choice
    .help = "Run an external program that analyses reflection files and presents results to HKLviewer"
  merge_data = False
    .type = bool
    .help = "internal flag"
  miller_array_operation = ''
    .type = str
    .help = "Python syntax string defining a new cctbx.miller_array object from one or two exisitng miller arrays " \
            "in the loaded data file. The CCTBX API is used for this"
  spacegroup_choice = None
    .type = int
  commit_subgroup_datasets = False
    .type = bool
    .help = "Replaces current datasets (irreversibly) with the datasets expanded to a selected subgroup. Datasets can then be saved as a new reflection file"
  using_space_subgroup = False
    .type = bool
    .help = "internal flag"
  draw_real_space_unit_cell = False
    .type = bool
    .help = "show real space unit cell"
  draw_reciprocal_unit_cell = False
    .type = bool
    .help = "show reciprocal space unit cell"
  real_space_unit_cell_scale_fraction = 0.0
    .type = float(value_min=0.0, value_max=1.0)
    .help = "Parameter specifying the scale at which to display the unit cell compared to reciprocal space. 0 means " \
            "true to scale of the size of the reciprocal lattice. 1 means close to the radius of the displayed sphere of reflections."
  reciprocal_unit_cell_scale_fraction = 0.0
    .type = float(value_min=0.0, value_max=1.0)
    .help = "Parameter specifying the scale at which to display the reciprocal unit cell compared to reciprocal space. " \
            "0 means true to scale of the size of the reciprocal lattice. 1 means close to the radius of the displayed sphere of reflections."
  clip_plane
    .help = "Optionally imposed clip plane which is always parallel to the screen."
  {
    hkldist = 0.0
      .type = float
      .help = "Distance from origin of the center of the clip plane. " \
              "If the clip plane is normal to a reciprocal lattice vector or the associated real space " \
              "vector the unit of hkldist is the length of the reciprocal lattice vector. " \
              "If the clip plane is normal to a real space vector the unit of hkldist is the " \
              "inverse of its real space length."
    normal_vector = ""
      .type = str
    is_assoc_real_space_vector = False
      .type = bool
      .help = "Indicate if using associated real space vector to the selected reciprocal space vector"
    normal_vector_length_scale = -1
      .type = float
      .help = "If value is negative the unit length of hkldist is used as the scale."
    clip_width = None
      .type = float
      .help = "If value is not None then we are clipping. If auto_clip_width is True this value is ignored."
    auto_clip_width = True
      .type = bool
      .help = "If true compute appropriate clip plane width. Otherwise use clip_width value"
    fractional_vector = reciprocal *realspace
      .type = choice
  }

  %s

  binning {
    scene_bin_thresholds = []
      .type = floats
    binner_idx = 0
      .type = int
      .help = "Index in list of binners, say ['Resolution', 'Singletons', 'I,SIGI', 'Sigmas of I,SIGI',..] "
    binlabel = None
      .type = str
      .help = "Element in list of binners, say ['Resolution', 'Singletons', 'I,SIGI', 'Sigmas of I,SIGI',..] "
    bin_opacity = None
      .type = floats(size=2)
      .multiple = True
      .help = "A list of tuples (alpha, idx) with as many or more elements as the current number of binners. List is cast to a string"
    nbins = 1
      .type = int(value_min=1, value_max=40)
  }

  viewer {
    data_array {
      label = None
        .type = str
        .help = "If provided this assigns scene_id with a value corresponding to the numbering " \
                   "order the miller array with this label is found in the reflection data file."
      phasertng_tag = None
        .type = str
        .help = "If provided this assigns scene_id with a value corresponding to the numbering " \
                   "order the miller array with a label found in the parsed history of the MTZ header."
      datatype = None
        .type = str
        .help = "In case label is not found this assigns scene_id with a value corresponding to " \
                   "the first miller array of this data type found in the reflection data file."
    }
    scene_id = None
      .type = int
    ncolourlabels = 6
      .type = int
      .help = "internal"
    show_vector = ''
      .type = str
      .multiple = True
      .help = "Vectors to display. Each show_vector is a stringified python list consisting of the name " \
              "of the vector as the first element and a boolean value as the second element indicating " \
              "visibility of the vector, say show_vector = "['4-fold#2', True]""
    show_all_vectors = 0
      .type = int(value_min=-1, value_max=1)
    user_vector
      .multiple = True
      .help = "Vectors the user add in addition to existing vectors (rotations, tNCS, anisotropy principal axes). " \
              "A vector has to be entered either as a rotation, a real space or a reciprocal space vector. " \
              "The label is required but only one of hkl_op, abc or hkl must be specified"
    {
      label = ""
        .type = str
      hkl_op = ""
        .type = str
        .help = "Rotation operation specified with h,k and l"
      abc = ""
        .type = str
        .help = "Real space vector in real space fractional coordinates"
      hkl = ""
        .type = str
        .help = "Reciprocal space vector in reciprocal space fractional coordinates"
    }
    show_hkl = ""
      .type = str
      .help = "Highlight a reflection with a red meshed wire net surrounding it."
    is_parallel = False
      .type = bool
      .help = "Specifies if reciprocal space is rotated to have a selected and displayed vector being parallel " \
              "or perpendicular to the screen."
    fixorientation = vector *None
      .type = choice
      .help = "fixes orientation of reciprocal space to be aligned with a vector so only mouse zoom will work"
    angle_around_XHKL_vector = 0.0
      .type = float
    angle_around_YHKL_vector = 0.0
      .type = float
    angle_around_ZHKL_vector = 0.0
      .type = float
    angle_around_vector = \"[0,0]\"
      .type = str
      .help = "Rotation with a specified angle of all reflections around a specified vector, " \
              "say angle_around_vector = \"['2-fold#5', 13.0]\""
    animate_rotation_around_vector = \"[0,0]\"
      .type = str
      .help = "Continuous rotation of all reflections around a specified vector at a certain speed, " \
              "say animate_rotation_around_vector = \"['2-fold#5', 10.0]\""
  }
  hkls {
    %s
  }
  NGL {
    %s
  }
  action = *is_running is_terminating reset_view
    .type = choice
  tabulate_miller_array_ids = "[]"
    .type = str
    .help = "Data used internally between QT GUI and CCTBX"
  tooltip_data = "[]"
    .type = str
    .help = "Data used internally between QT GUI and CCTBX"
  use_wireframe = False
    .type = bool
    .help = "Draw objects using wireframe mesh"
  max_reflections_in_frustum = 0
    .type = int
    .help = "Maximum number of reflections to count in frustum. Larger than around 30 or 50 may cause " \
            "significant slow down of HKLviewer when displaying a large dataset"

""" %(ArrayInfo.arrayinfo_phil_str, display.philstr, jsview_3d.ngl_philstr)

master_phil = libtbx.phil.parse( master_phil_str )


 *******************************************************************************
