

 *******************************************************************************
rstbx/simage/tst.py
from __future__ import absolute_import, division, print_function
from six.moves import range
import sys, os
op = os.path

def exercise_image_simple():
  expected_sum_image_pixels_iter = iter(
      (200, 156) + (400, 308)*2
    + (450, 351) + (900, 693)*2
    + ( 91,  69) + (181, 139)*2
    + (160, 124) + (320, 248)*2
    + (246, 188) + (490, 377)*2)
  from cctbx import uctbx
  unit_cell = uctbx.unit_cell((11,12,13,85,95,105))
  from cctbx.array_family import flex
  miller_indices = flex.miller_index([(-1,2,1)])
  from scitbx.math import euler_angles
  crystal_rotation_matrix = euler_angles.xyz_matrix(80,20,30)
  import rstbx.simage
  from libtbx.test_utils import approx_equal, show_diff
  dpx, dpy = 4, 5
  for ewald_proximity,star in [(0.1, " "), (0.5, "*")]:
    image_lines = []
    for point_spread in range(1,5+1):
      for spot_intensity_factor in [0.5, 1, None]:
        if (spot_intensity_factor is None):
          spot_intensity_factors = None
        else:
          spot_intensity_factors = flex.double([spot_intensity_factor])
        for apply_proximity_factor in [False, True]:
          if (star == "*"):
            expected_sum_image_pixels = next(expected_sum_image_pixels_iter)
          for code in range(16):
            store_miller_index_i_seqs = bool(code & 0x1)
            store_spots = bool(code & 0x2)
            store_signals = bool(code & 0x4)
            set_pixels = bool(code & 0x8)
            image = rstbx.simage.image_simple(
              apply_proximity_factor=apply_proximity_factor,
              store_miller_index_i_seqs=store_miller_index_i_seqs,
              store_spots=store_spots,
              store_signals=store_signals,
              set_pixels=set_pixels).compute(
                unit_cell=unit_cell,
                miller_indices=miller_indices,
                spot_intensity_factors=spot_intensity_factors,
                crystal_rotation_matrix=crystal_rotation_matrix,
                ewald_radius=0.5,
                ewald_proximity=ewald_proximity,
                signal_max=100,
                detector_distance=5,
                detector_size=(10,12),
                detector_pixels=(dpx,dpy),
                point_spread=point_spread,
                gaussian_falloff_scale=4)
            if (store_signals and image.signals.size() == 1):
              partialities = rstbx.simage.image_simple(
                apply_proximity_filter=False,
                apply_proximity_factor=apply_proximity_factor,
                store_signals=True).compute(
                  unit_cell=unit_cell,
                  miller_indices=miller_indices,
                  spot_intensity_factors=None,
                  crystal_rotation_matrix=crystal_rotation_matrix,
                  ewald_radius=0.5,
                  ewald_proximity=ewald_proximity,
                  signal_max=1,
                  detector_distance=5,
                  detector_size=(10,12),
                  detector_pixels=(dpx,dpy),
                  point_spread=point_spread,
                  gaussian_falloff_scale=4).signals
              f = 100
              if (spot_intensity_factor is not None):
                f *= spot_intensity_factor
              assert approx_equal(partialities*f, image.signals)
            if (store_miller_index_i_seqs and star == "*"):
              assert image.miller_index_i_seqs.size() == 1
            else:
              assert image.miller_index_i_seqs.size() == 0
            if (store_spots and star == "*"):
              assert image.spots.size() == 1
            else:
              assert image.spots.size() == 0
            if (store_signals and star == "*"):
              assert image.signals.size() == 1
            else:
              assert image.signals.size() == 0
            if (not set_pixels):
              assert image.pixels.size() == 0
            else:
              assert image.pixels.size() == 20
              sum_image_pixels = flex.sum(image.pixels)
              if (star == "*"):
                assert sum_image_pixels == expected_sum_image_pixels
              else:
                assert sum_image_pixels == 0
      assert image.pixels.all() == (dpx,dpy)
      for i in range(dpx):
        line = []
        for j in range(dpy):
          if (image.pixels[(i,j)]): c = star
          else: c = " "
          line.append(c)
        image_lines.append("|"+"".join(line)+"|")
      image_lines.append("")
    assert not show_diff("\n".join(image_lines), """\
|     |
|     |
|  ** |
|  ** |

|     |
|  ***|
|  ***|
|  ***|

|     |
|  ** |
| *** |
|  ** |

|  *  |
| ****|
| ****|
| ****|

| *** |
|*****|
|*****|
|*****|
""".replace("*", star))

def exercise_combine_rgb_images():
  from rstbx.simage import combine_rgb_images as cri
  assert cri(["de", "*/"]) == "GJ"
  assert cri(["+-", "ac"]) == "FH"

def exercise_create():
  from rstbx.simage import create
  from libtbx.test_utils import block_show_diff
  from libtbx.str_utils import show_string
  from six.moves import cStringIO as StringIO
  #
  def check(args, expected_block):
    sio = StringIO()
    work_params = create.process_args(args=args, out=sio)
    assert not block_show_diff(sio.getvalue(), expected_block)
    pixels = create.compute_image(work_params)
    assert pixels.all() == tuple(work_params.detector.pixels)
  #
  check(args=[], expected_block="""\
detector {
  distance = 180
  size = 200 200
  pixels = 1000 1000
  use_corners = False
}
""")
  #
  relative_path = "phenix_regression/pdb/start.pdb"
  import libtbx.load_env
  full_path = libtbx.env.find_in_repositories(
    relative_path=relative_path, test=op.isfile)
  if (full_path is None):
    print("Skipping some tests due to missing file: %s" % relative_path)
  else:
    check(
      args=["pdb_file="+show_string(full_path)],
      expected_block="""\
change_of_basis_op_to_niggli_cell = "a,b,c"
unit_cell = 32.9 32.9 96.1 90 90 120
intensity_symmetry = "P 3 2 1"
lattice_symmetry = "P 6 2 2"
""")

def exercise_explore_completeness():
  import libtbx.load_env
  if (not libtbx.env.has_module("spotfinder")):
    print("Skipping some tests due to missing module: spotfinder")
    return
  from libtbx.test_utils import contains_substring
  from libtbx import easy_run
  def run(args):
    cmd = " ".join(["rstbx.simage.explore_completeness"] + args)
    print(cmd)
    buf = easy_run.fully_buffered(
      command=cmd, stdout_splitlines=False).raise_if_errors().stdout_buffer
    for key in [
          "Complete with ",
          "Observations per reflection:",
          "  Median: "]:
      assert contains_substring(buf, key)
    return buf
  run(["d_min=10"])
  args = ["d_min=10", "intensity_symmetry=P4", "use_symmetry=True"]
  from libtbx import easy_mp
  if (easy_mp.detect_problem() is None):
    args.append("multiprocessing=True")
  buf = run(args)
  assert contains_substring(buf, 'lattice_symmetry = "P 4 2 2"')

def exercise_solver():
  import libtbx.load_env
  if (not libtbx.env.has_module("spotfinder")):
    print("Skipping some tests due to missing module: spotfinder")
    return
  from libtbx.test_utils import block_show_diff, contains_substring
  from libtbx import easy_run
  def run(args):
    cmd = " ".join(["rstbx.simage.solver"] + args)
    print(cmd)
    buf = easy_run.fully_buffered(
      command=cmd, stdout_splitlines=False).raise_if_errors().stdout_buffer
    for key in [
          "Final:"]:
      assert contains_substring(buf, key)
    return buf
  buf = run(["d_min=5"])
  assert not block_show_diff(buf, """\
input_im0_i_perm: 0

Correlation of input and estimated I-obs:
  i_perm=0:  1.00000 (r1: 0.00000)
""")
  buf = run(["d_min=5", "lattice_symmetry=R32:R", "intensity_symmetry=R3:R"])
  assert not block_show_diff(buf, """\
input_im0_i_perm: 1

Correlation of input and estimated I-obs:
  i_perm=0:  0.06799 (r1: 0.37555)
  i_perm=1:  1.00000 (r1: 0.00000)
""")
  buf = run(["d_min=5", "lattice_symmetry=R32:R", "intensity_symmetry=P1"])
  assert not block_show_diff(buf, """\
input_im0_i_perm: 5

Correlation of input and estimated I-obs:
  i_perm=0:  0.07524 (r1: 0.38937)
  i_perm=1: -0.02385 (r1: 0.40114)
  i_perm=2: -0.04577 (r1: 0.41742)
  i_perm=3: -0.00099 (r1: 0.40390)
  i_perm=4:  0.00764 (r1: 0.39213)
  i_perm=5:  1.00000 (r1: 0.00000)
""")
  if (not libtbx.env.has_module("labelit")):
    print("Skipping some tests due to missing module: labelit")
  else:
    from libtbx import easy_mp
    mp_problem = easy_mp.detect_problem()
    if (mp_problem is not None):
      print("Skipping some tests:", mp_problem)
    else:
      buf = run([
        "d_min=5", "lattice_symmetry=P422", "intensity_symmetry=P4",
        "index_and_integrate=True", "multiprocessing=True"])
      assert contains_substring(buf, "Refined unit cell 9 (")
      assert contains_substring(
        buf, "Correlation of input and estimated I-obs:")
      assert contains_substring(buf, "  Best correlation:  0.999")

def run(args):
  assert len(args) == 0
  from libtbx.utils import show_times_at_exit
  show_times_at_exit()
  exercise_image_simple()
  exercise_combine_rgb_images()
  exercise_create()
  exercise_explore_completeness()
  exercise_solver()
  print("OK")

if (__name__ == "__main__"):
  run(args=sys.argv[1:])


 *******************************************************************************


 *******************************************************************************
rstbx/simage/wx_display.py
from __future__ import absolute_import, division, print_function
import wx
import sys
from six.moves import zip

class detector_surface(wx.Window):

  def __init__(O, parent, work_params):
    super(detector_surface, O).__init__(parent=parent, id=-1)
    O.work_params = work_params
    O.Bind(wx.EVT_SIZE, O.OnSize)
    O.Bind(wx.EVT_PAINT, O.OnPaint)
    O.Bind(wx.EVT_CHAR, O.OnChar)
    O.reset_state()

  def reset_state(O):
    O.prev_work_phil_ewp_none_str = None
    O.prev_work_phil_str = None
    O.pixels = None
    O.image = None
    O.pixels_2 = None
    O.image_2 = None
    O.spots = None
    O.predicted_spots = None
    O.active_wavelengths = 0

  def recompute(O):
    w, h = O.GetSizeTuple()
    p = min(w, h)
    if (p == 0):
      O.reset_state()
      return False
    O.work_params.detector.pixels = (p, p)
    O.GetParent().wx_detector_pixels.SetLabel("%d x %d" % (p, p))
    O.update_active_wavelengths()
    work_phil_str = O.work_params.phil_master.format(O.work_params).as_str()
    if (   O.prev_work_phil_str is None
        or O.prev_work_phil_str != work_phil_str):
      O.prev_work_phil_str = work_phil_str
      from rstbx.simage.create import compute_image
      wp = O.work_params
      O.pixels = compute_image(wp)
      saturation = int(wp.signal_max * wp.saturation_level + 0.5)
      O.image = O.pixels.as_rgb_scale_string(
        rgb_scales_low=(1,1,1),
        rgb_scales_high=(1,0,0),
        saturation=saturation)
      O.pixels_2 = compute_image(wp, use_wavelength_2=True)
      O.image_2 = O.pixels_2.as_rgb_scale_string(
        rgb_scales_low=(1,1,1),
        rgb_scales_high=(0,0,1),
        saturation=saturation)
    return True

  def run_spotfinder(O):
    _ = O.active_wavelengths
    if   (_ == 1): px = O.pixels
    elif (_ == 2): px = O.pixels_2
    else:
      if (O.pixels is None or O.pixels_2 is None):
        px = None
      else:
        px = O.pixels + O.pixels_2
        px /= 2
    if (px is None):
      return
    if (O.work_params.noise.max == 0):
      print()
      print("WARNING:")
      print("  noise.max = 0: spotfinder is likely to crash...")
      print()
      sys.stdout.flush()
    dpx,dpy = O.work_params.detector.pixels
    if (dpx < 100 or dpy < 100):
      return
    from rstbx.simage import run_spotfinder
    O.spots = run_spotfinder.process(
      work_params=O.work_params,
      pixels=px,
      show_spots=False)
    O.Refresh()

  def update_active_wavelengths(O):
    O.GetParent().wx_active_wavelengths.SetLabel({
        0: "1+2",
        1: "1",
        2: "2"
      }[O.active_wavelengths])

  def run_labelit_index(O, use_original_uc_cr=False):
    if (O.spots is None):
      O.run_spotfinder()
    if (O.spots is None):
      return
    if (O.spots.size() < 10):
      print("Insufficient number of spotfinder spots.")
      print()
      return
    else:
      if (use_original_uc_cr):
        print()
        print("Using original unit cell and crystal rotation" \
          " for spot prediction.")
        print()
        uc = O.work_params.unit_cell
        cr = O.work_params.crystal_rotation_matrix
      else:
        from rstbx.simage.run_labelit_index import process
        try:
          ai = process(work_params=O.work_params, spots=O.spots)
        except Exception as e:
          print("Indexing exception:", e)
          print()
          return
        print("Spots indexed: %d of %d" % (
          ai.hklobserved().size(),
          O.spots.size()))
        co = ai.getOrientation()
        uc = co.unit_cell()
        cr = co.crystal_rotation_matrix()
        print("labelit index unit cell:", uc)
        from rstbx.simage import refine_uc_cr
        refined = refine_uc_cr.refine(
          work_params=O.work_params,
          spots=O.spots,
          good_i_seqs=ai.get_observed_spot_i_seqs_good_only(),
          miller_indices=ai.hklobserved(),
          unit_cell=uc,
          crystal_rotation=cr)
        uc = refined.unit_cell
        cr = refined.crystal_rotation
        print()
      import cctbx.crystal
      crystal_symmetry = cctbx.crystal.symmetry(
        unit_cell=uc,
        space_group_symbol="P1")
      d_min = O.work_params.d_min
      if (d_min is None):
        d_min = O.work_params.wavelength
      import cctbx.miller
      miller_set = cctbx.miller.build_set(
        crystal_symmetry=crystal_symmetry,
        d_min=d_min,
        anomalous_flag=True)
      from rstbx.simage import image_simple
      O.predicted_spots = image_simple(store_spots=True).compute(
        unit_cell=miller_set.unit_cell(),
        miller_indices=miller_set.indices(),
        spot_intensity_factors=None,
        crystal_rotation_matrix=cr,
        ewald_radius=1/O.work_params.wavelength,
        ewald_proximity=O.work_params.ewald_proximity,
        signal_max=O.work_params.signal_max,
        detector_distance=O.work_params.detector.distance,
        detector_size=O.work_params.detector.size,
        detector_pixels=O.work_params.detector.pixels,
        point_spread=O.work_params.point_spread,
        gaussian_falloff_scale=O.work_params.gaussian_falloff_scale).spots
      print("Number of predicted spots:", O.predicted_spots.size())
      print()
    O.Refresh()

  def draw_image(O):
    w, h = O.work_params.detector.pixels
    assert w == h
    p = w
    assert p != 0
    wx_image = wx.EmptyImage(p, p)
    if (O.image is not None):
      _ = O.active_wavelengths
      if   (_ == 1): im = O.image
      elif (_ == 2): im = O.image_2
      else:
        from rstbx.simage import combine_rgb_images
        im = combine_rgb_images([O.image, O.image_2])
      wx_image.SetData(im)
    wx_bitmap = wx_image.ConvertToBitmap()
    dc = wx.PaintDC(win=O)
    dc = wx.BufferedDC(dc)
    dc.Clear()
    w, h = O.GetSizeTuple()
    dc.DrawBitmap(bmp=wx_bitmap, x=w-p, y=0, useMask=False)
    dc.SetPen(wx.Pen("GREY", 0))
    dc.SetBrush(wx.Brush("GREY", wx.CROSSDIAG_HATCH))
    if (w > p):
      dc.DrawRectangle(0, 0, w-(p+1), h)
    elif (h > p):
      dc.DrawRectangle(0, p+1, w, h-(p+1))
    if (O.spots is not None):
      dc.SetPen(wx.Pen("RED", 1))
      dc.SetBrush(wx.Brush("WHITE", wx.TRANSPARENT))
      for spot in O.spots:
        x,y = spot.ctr_mass_x()+0.5, spot.ctr_mass_y()+0.5
        dc.DrawCircle(x=w-p+y, y=x, radius=5)
    if (O.predicted_spots is not None):
      dc.SetPen(wx.Pen("BLUE", 1))
      dc.SetBrush(wx.Brush("WHITE", wx.TRANSPARENT))
      for spot in O.predicted_spots:
        x,y,_ = spot
        dc.DrawCircle(x=w-p+y, y=x, radius=5)

  def OnSize(O, event):
    if (O.recompute()):
      O.Refresh()

  def OnPaint(O, event):
    if (O.image is None and not O.recompute()):
      return
    O.draw_image()

  def OnChar(O, event):
    key = event.GetKeyCode()
    if (key == ord("c")):
      O.spots = None
      O.predicted_spots = None
      O.Refresh()
    elif (key == ord("u")):
      O.work_params.force_unit_spot_intensities = \
        not O.work_params.force_unit_spot_intensities
      if (O.recompute()):
        O.Refresh()
    elif (key == ord("w")):
      if (O.image_2 is not None):
        O.active_wavelengths = (O.active_wavelengths + 1) % 3
        O.update_active_wavelengths()
        O.Refresh()
    elif (key == ord("s")):
      if (O.spots is None):
        O.run_spotfinder()
      else:
        O.spots = None
        O.Refresh()
    elif (key in [ord("i"), ord("I")]):
      if (O.predicted_spots is None):
        O.run_labelit_index(use_original_uc_cr=(key==ord("I")))
      else:
        O.predicted_spots = None
        O.Refresh()
    else:
      print("No action for this key stroke.")

class main_panel(wx.Panel):

  def __init__(O, parent, work_params):
    super(main_panel, O).__init__(parent=parent, id=-1)
    O.work_params = work_params

    O.variable_name_by_wx_id = {}
    O.variable_values_by_name = {}
    v_sizer = wx.BoxSizer(orient=wx.VERTICAL)

    def add_detector_pixels():
      h_sizer = wx.BoxSizer(orient=wx.HORIZONTAL)
      label = wx.StaticText(parent=O, id=-1, label="Detector pixels:")
      h_sizer.Add(item=label)
      dp = wx.StaticText(parent=O, id=-1, label="None")
      f = dp.GetFont()
      f.SetWeight(wx.BOLD)
      dp.SetFont(f)
      h_sizer.Add(item=dp, flag=wx.LEFT, border=5)
      v_sizer.AddSpacer(3)
      v_sizer.Add(item=h_sizer)
      return dp

    O.wx_detector_pixels = add_detector_pixels()

    def add_active_wavelengths():
      h_sizer = wx.BoxSizer(orient=wx.HORIZONTAL)
      label = wx.StaticText(parent=O, id=-1, label="Active wavelengths:")
      h_sizer.Add(item=label)
      dp = wx.StaticText(parent=O, id=-1, label="None")
      f = dp.GetFont()
      f.SetWeight(wx.BOLD)
      dp.SetFont(f)
      h_sizer.Add(item=dp, flag=wx.LEFT, border=5)
      v_sizer.AddSpacer(3)
      v_sizer.Add(item=h_sizer)
      return dp

    O.wx_active_wavelengths = add_active_wavelengths()

    def add_slider(variable_name, val_min_max):
      h_sizer = wx.BoxSizer(orient=wx.HORIZONTAL)
      ctrl_id = wx.NewId()
      slider = wx.Slider(
        parent=O,
        id=ctrl_id,
        value=val_min_max[0],
        minValue=val_min_max[1],
        maxValue=val_min_max[2],
        size=(150, -1),
        style=wx.SL_HORIZONTAL|wx.SL_AUTOTICKS|wx.SL_LABELS)
      O.variable_name_by_wx_id[ctrl_id] = variable_name
      O.variable_values_by_name[variable_name] = val_min_max[0]
      slider.Bind(event=wx.EVT_SCROLL, handler=O.OnSliderScroll)
      h_sizer.Add(item=slider)
      label = wx.StaticText(parent=O, id=-1, label=variable_name)
      h_sizer.Add(item=label)
      v_sizer.Add(item=h_sizer)
      v_sizer.AddSpacer(3)

    from libtbx.math_utils import normalize_angle
    xyz = O.work_params.euler_angles_xyz
    for variable_name,value in zip(["rot x", "rot y", "rot z"], xyz):
      add_slider(variable_name, (
        normalize_angle(value, deg=True, zero_centered=True),
        -180,
        180))
    v_sizer.AddSpacer(3)

    def add_fs(min_val, max_val, increment, digits, label, value):
      import wx.lib.agw.floatspin as FS
      ctrl_id = wx.NewId()
      fs = FS.FloatSpin(
        parent=O,
        id=ctrl_id,
        min_val=min_val,
        max_val=max_val,
        increment=increment,
        value=value,
        agwStyle=FS.FS_LEFT)
      O.variable_name_by_wx_id[ctrl_id] = label
      fs.SetFormat("%f")
      fs.SetDigits(digits)
      fs.Bind(event=FS.EVT_FLOATSPIN, handler=O.OnFloatSpin),
      h_sizer = wx.BoxSizer(orient=wx.HORIZONTAL)
      h_sizer.Add(item=fs)
      label = wx.StaticText(parent=O, id=-1, label=label)
      h_sizer.Add(item=label, flag=wx.LEFT, border=5)
      v_sizer.Add(item=h_sizer)
      v_sizer.AddSpacer(3)

    add_fs(
      min_val=0.1,
      max_val=10,
      increment=0.1,
      digits=6,
      label="Wavelength 1",
      value=O.work_params.wavelength)

    add_fs(
      min_val=0.1,
      max_val=10,
      increment=0.1,
      digits=6,
      label="Wavelength 2",
      value=O.work_params.wavelength_2)

    if (O.work_params.d_min is None):
      O.work_params.d_min = O.work_params.wavelength
    add_fs(
      min_val=0.1,
      max_val=10,
      increment=0.1,
      digits=6,
      label="d-min",
      value=O.work_params.d_min)

    add_fs(
      min_val=-1,
      max_val=1,
      increment=0.01,
      digits=6,
      label="Ewald proximity",
      value=O.work_params.ewald_proximity)

    add_fs(
      min_val=1,
      max_val=500,
      increment=50,
      digits=2,
      label="Detector distance",
      value=O.work_params.detector.distance)

    def add_sp(label, value):
      sp = wx.SpinCtrl(parent=O, id=-1, min=1, max=100, initial=value)
      sp.Bind(event=wx.EVT_SPINCTRL, handler=O.OnSpin),
      h_sizer = wx.BoxSizer(orient=wx.HORIZONTAL)
      h_sizer.Add(item=sp)
      label = wx.StaticText(parent=O, id=-1, label=label)
      h_sizer.Add(item=label, flag=wx.LEFT, border=5)
      v_sizer.Add(item=h_sizer)
      v_sizer.AddSpacer(3)

    add_sp(
      label="Point spread",
      value=O.work_params.point_spread)

    add_fs(
      min_val=0,
      max_val=100,
      increment=1,
      digits=1,
      label="Gaussian falloff scale",
      value=O.work_params.gaussian_falloff_scale)

    ucp = O.work_params.unit_cell.parameters()
    for variable_name,value in zip(["a", "b", "c"], ucp[:3]):
      add_slider(variable_name, (
        value,
        min(10, round(value-0.5, 0)),
        max(100, round(value+5, -1))))
    for variable_name,value in zip(["alpha", "beta", "gamma"], ucp[3:]):
      add_slider(variable_name, (
        value,
        min(60, round(value-5, -1)),
        max(105, round(value+5, -1))))

    O.detector_surface = detector_surface(parent=O, work_params=O.work_params)

    topsizer = wx.BoxSizer(orient=wx.HORIZONTAL)
    topsizer.Add(item=O.detector_surface, proportion=1, flag=wx.EXPAND)
    topsizer.Add(item=v_sizer, flag=wx.ALL, border=10)
    O.SetSizer(topsizer)
    topsizer.Layout()

  def reset_work_params(O):
    def getvar():
      return O.variable_values_by_name[variable_name]
    uc_params = []
    for variable_name in ["a", "b", "c", "alpha", "beta", "gamma"]:
      uc_params.append(getvar())
    from cctbx import uctbx
    try:
      uc = uctbx.unit_cell(uc_params)
    except RuntimeError:
      pass # simply keep previous
    else:
      O.work_params.unit_cell = uc
    xyz = []
    for variable_name in ["rot x", "rot y", "rot z"]:
      xyz.append(getvar())
    O.work_params.euler_angles_xyz = xyz

  def OnSliderScroll(O, event):
    variable_name = O.variable_name_by_wx_id[event.GetId()]
    O.variable_values_by_name[variable_name] = event.GetPosition()
    O.reset_work_params()
    O.detector_surface.recompute()
    O.detector_surface.Refresh()

  def OnFloatSpin(O, event):
    val = event.GetEventObject().GetValue()
    label = O.variable_name_by_wx_id[event.GetId()]
    if (label == "Wavelength 1"):
      O.work_params.wavelength = val
    elif (label == "Wavelength 2"):
      O.work_params.wavelength_2 = val
    elif (label == "d-min"):
      O.work_params.d_min = val
    elif (label == "Ewald proximity"):
      O.work_params.ewald_proximity = val
    elif (label == "Detector distance"):
      O.work_params.detector.distance = val
    elif (label == "Gaussian falloff scale"):
      O.work_params.gaussian_falloff_scale = val
    else:
      raise RuntimeError("Unknown label: %s" % label)
    O.detector_surface.recompute()
    O.detector_surface.Refresh()

  def OnSpin(O, event):
    val = event.GetEventObject().GetValue()
    O.work_params.point_spread = val
    O.detector_surface.recompute()
    O.detector_surface.Refresh()

def run(args):
  from rstbx.simage import run_spotfinder
  work_params = run_spotfinder.process_args(
    args=args, extra_phil_str="""\
saturation_level = 1.0
  .type = float
""")
  if (work_params.wavelength_2 is None):
    work_params.wavelength_2 = work_params.wavelength
  app = wx.App()
  frame = wx.Frame(
    parent=None,
    id=-1,
    title="wx_simage",
    pos=wx.DefaultPosition,
    size=wx.Size(800, 600))
  main_panel(parent=frame, work_params=work_params)
  frame.Show()
  app.MainLoop()


 *******************************************************************************


 *******************************************************************************
rstbx/simulation/__init__.py
from __future__ import absolute_import, division, print_function
import boost_adaptbx.boost.python as bp
ext = bp.import_ext("rstbx_simulation_ext")
from rstbx_simulation_ext import *
from scitbx import matrix
from cctbx import crystal_orientation
from rstbx.simulation.constants import eV_per_inv_meter
import math

class xfel1(ext.xfel1):

  def show(self):
    print("In XFEL1 simulation")

  def __init__(self,detector=None,camera=None,structure=None,simulation=None):
    ext.xfel1.__init__(self)

    self.detector=detector
    self.camera=camera
    self.structure=structure
    self.sim=simulation

    self.uc = self.structure.p1_cell()

    self.bmat = matrix.sqr(self.uc.orthogonalization_matrix()).inverse().transpose()
    self.Ori = crystal_orientation.crystal_orientation( self.bmat,
      crystal_orientation.basis_type.reciprocal )

    energy_in_eV = eV_per_inv_meter / (self.camera.lambda0) # lambda in meters

    # top hat function for dispersion
    self.full_pass_eV = energy_in_eV * matrix.col([1.-(self.sim.bandpass/2.),
                                              1.+(self.sim.bandpass/2.)])

    self.full_pass_lambda = eV_per_inv_meter * matrix.col((1./self.full_pass_eV[0],
                                                           1./self.full_pass_eV[1]))

    intensities = self.structure.p1_intensities()
    self.set_indices(intensities.indices())
    self.set_intensities(intensities.data())

  def compute(self,axis,angle):
    shotOri = self.Ori.rotate_thru(axis,angle)
    beam_vector_B = matrix.col([0, 0, 1 / (self.camera.lambda0)])
    self.selected = self.select_proximal_indices(half_edge=int(self.detector.raw.focus()[0]/2),
                 detector_distance_m=self.camera.distance,
                 pixel_size_m=self.detector.pixel_sz,
                 orientation = shotOri,
                 mosaicity_full_width  = self.sim.mosaicity*(math.pi/180.),
                 bandpass_full_width = self.sim.bandpass,
                 wavelength_m = self.camera.lambda0,
                 limiting_resolution_Ang = self.structure.limiting_resolution)
    print("Selected %d reflections close to the Ewald sphere in this orientation"%len(self.selected))

    self.detector.raw.fill(0.0)
    self.image = self.raw_diffraction(selection = self.selected,
                            pixels = self.detector.raw,
                            mosaic_domains = self.sim.tracing_impacts,
                            detector_distance_m=self.camera.distance,
                            pixel_size_m=self.detector.pixel_sz,
                            darwin_factor = self.sim.darwin_factor)


 *******************************************************************************


 *******************************************************************************
rstbx/simulation/constants.py
from __future__ import absolute_import, division, print_function
electron_radius = 2.818E-15 # classical electron radius in meters

plank_constant = 6.62606896E-34 # Joule-seconds

speed_of_light = 299792458.E0 # meters/second

Joules_per_eV = 1.602176487E-19

#conversion factor from inverse meters to eV:
eV_per_inv_meter = speed_of_light * plank_constant * 1./(Joules_per_eV)



 *******************************************************************************


 *******************************************************************************
rstbx/simulation/sim_pdf.py
from __future__ import absolute_import, division, print_function
from six.moves import range
from scitbx.array_family import flex
page_origin = (20.,220.)
boxedge = 500.

class PointTransform:
  '''provide the necessary transformation to go from image pixel coordinates
     to coordinates on the printed page of the .pdf report'''

  def __init__(self,detector_edge):
    self.boxedge = boxedge
    self.page_origin = page_origin
    self.size1 = detector_edge
    self.size2 = detector_edge
    self.subwindow_origin=[0.,0.]
    self.subwindow_fraction=1.


  def toPage(self, image_pixel_xy):

    image_fractional_coords = ((1.-image_pixel_xy[0]/self.size1),
                               image_pixel_xy[1]/self.size2)
    image_subwindow_coords = ((image_fractional_coords[1]-self.subwindow_origin[1])/
                              self.subwindow_fraction,
                              (image_fractional_coords[0]-self.subwindow_origin[0])/
                              self.subwindow_fraction)
    if 0.<image_subwindow_coords[0]<1. and 0.<image_subwindow_coords[1]<1.:
      page_coords = (image_subwindow_coords[0]*self.boxedge + self.page_origin[0],
                     (1.-image_subwindow_coords[1])*self.boxedge + self.page_origin[1]
      )
      return page_coords
    return None


from reportlab.pdfgen.canvas import Canvas
from reportlab.lib.pagesizes import letter
from reportlab.lib.units import cm,mm
class Graph:

  def __init__(self,fileout):
    self.c = Canvas(fileout,pagesize=letter)

  def title(self,text):
    print(text)
    lines = text.split('\n')
    self.c.setFont('Helvetica',12)
    self.c.drawString(2*cm,26*cm,lines[0])
    if len(lines)>1:
      self.c.drawString(2*cm,25.5*cm,lines[1])

  def setTransform(self,detector_edge):
    #given the raw image fractional coordinates of the subwindow origin
    self.T = PointTransform(detector_edge)

  def __del__(self):
    self.c.save()

class PDF:
  def __init__(self,filename):
    self.R = Graph(filename)

  def make_image_plots_detail(self,ray_sim):

    normal = ray_sim.sim.tracing_impacts

    self.R.setTransform(ray_sim.detector.raw.focus()[0])
    self.R.title(
    "%.3f bandpass + %.3f degrees mosaicity (full widths); perfect optics"%(
      ray_sim.sim.bandpass,
      ray_sim.sim.mosaicity)+
"\nEnergy %4.1f KeV;  Detector distance %6.1f mm;   Limiting resolution %6.2f Angstrom"%(
      (12.398/(ray_sim.camera.lambda0*1E10)),
      ray_sim.camera.distance*1000.,
      ray_sim.structure.limiting_resolution))
    data_array = 255-ray_sim.image
    import numpy
    try:
      import PIL.Image as Image
    except ImportError:
      import Image
    imageout = Image.frombuffer("L",data_array.focus(),
      data_array.as_numpy_array().astype(numpy.uint8).tostring(),
      "raw","L",0,1
      )
    self.R.c.drawInlineImage(imageout,x=2*cm,y=9*cm, width=15*cm, height=15*cm)
    self.R.c.showPage()
    return self


if __name__=="__main__":
   data_array = flex.double(flex.grid((768,768)),1.0)
   print(data_array.focus())
   data_array = flex.double(flex.grid((7,7)),255)
   for x in range(7):
     data_array[(3,x)] = 0.
     data_array[(x,3)] = 0.
   try:
     import PIL.Image as Image
   except ImportError:
     import Image
   import numpy
   args = ("L",0,1)
   imageout = Image.frombuffer("L",data_array.focus(),
     data_array.as_float().as_numpy_array().astype(numpy.uint8).tostring(),
     "raw","L",0,1)

   imageout.save("newfile.png","PNG")


 *******************************************************************************


 *******************************************************************************
rstbx/simulation/sim_utils.py
from __future__ import absolute_import, division, print_function
from six.moves import range
import math,random
from libtbx.test_utils import approx_equal
from scitbx import matrix

def generate_random_rotation(count):
  for x in range(count):

    u1=random.random()
    u2=random.random()
    u3=random.random()
    two_pi=2.0*math.pi

    #random unit quaternion, Steven M. LaValle, Planning Algorithms
    # Cambridge University Press, 2006, p. 198.
    # http://planning.cs.uiuc.edu
    q = [math.sqrt(1.-u1)*math.sin(two_pi*u2),
         math.sqrt(1.-u1)*math.cos(two_pi*u2),
         math.sqrt(u1)*math.sin(two_pi*u3),
         math.sqrt(u1)*math.cos(two_pi*u3),
        ]

    #use quaternion formula to find angle of rotation
    angle =2.* math.acos(q[0])

    #find vector of rotation
    denom = math.sin(angle/2.)
    vector = (q[1]/denom, q[2]/denom, q[3]/denom)
    assert approx_equal(matrix.col(q).length() , 1.0)
    assert approx_equal(matrix.col(vector).length(),1.0)
    yield vector, angle


if __name__=="__main__":
  for vector, angle in generate_random_rotation(50):
    V = matrix.col(vector)
    assert approx_equal(V.length(),1.0)
  print("OK")


 *******************************************************************************


 *******************************************************************************
rstbx/simulation/tst_xfel1_simple.py
from __future__ import absolute_import, division, print_function
from rstbx.diffraction.fastbragg import detector,standard_camera,crystal_structure
from rstbx.simulation.constants import electron_radius
from rstbx.simulation import xfel1
from rstbx.simulation.sim_pdf import PDF
from rstbx.simulation.sim_utils import generate_random_rotation

# Instantiation of the Detector, array size & pixel edge in meters
Det = detector(slowpixels=1516,fastpixels=1516,pixel_size=0.00022)
Det.show()

Cam = standard_camera(detector = Det,
                      mean_xtd_distance_m = 0.150,
                      mean_xray_wavelength_m = 1.24E-10)
Cam.show()

Pdb = crystal_structure(pdb_code='2alp',standard_camera=Cam)
Pdb.show()

square_crystal_edge = 5.E-6 # in meters
square_focus_edge = 5.E-6 # in meters
vol_crystal = square_crystal_edge**3 # volume of the crystal in meters**3
I_beam = 2E12 #number of photons per LCLS pulse
I_beam_flux = I_beam/(square_focus_edge**2)
darwin_numerator = I_beam_flux * (electron_radius**2) * vol_crystal

class Params:pass
Sim = Params()
Sim.mosaicity = 0.10 #degrees
Sim.bandpass = 0.002
Sim.tracing_impacts = 1000
Sim.darwin_factor = darwin_numerator/(Pdb.p1_cell().volume()/1E30)#vol:meters**3

if __name__=="__main__":

    simulation1 = xfel1(detector=Det,camera=Cam,structure=Pdb,simulation=Sim)
    simulation1.show()
    plotter = PDF("./xsim1_%s_m%03d_xtd%03d_res%02d.pdf"%(Pdb.pdb_code,
      int(1000*Sim.mosaicity),
      int(Cam.distance),
      int(10*Pdb.limiting_resolution)
      ))

    #all indices for the asymmetric unit, and all intensities
    idx,intensity = (simulation1.indices_all, simulation1.intensities_all)

    for shot in generate_random_rotation(1):
      #shot = ((0.1551649112858198, 0.987395705748476, -0.031202092480033007),
      #        2.4190024383592474)

      simulation1.compute(axis = shot[0], angle = shot[1])

      ##### State information that is available for each image ####
      #miller indices that are near or at reflection condition on this shot
      simulation1.selected
      #raw counts for these selected miller indices (the partial recorded intensity)
      simulation1.signals
      #the fraction of spot recorded for these selected miller indices
      simulation1.partialities
      #the recorded image as flex<int> with flex.grid(2)
      simulation1.image
      #pixel coordinates of each spots (floating point x,y values; not sure if offset by 1/2 pxl)
      #not actually tested yet
      simulation1.spots

      plotter.make_image_plots_detail(simulation1)

"""
where to go from here 6/30/11:
apply point spread function to make things easier to see
test whether the formula for proximity is really inclusive enough
test mosaicity, bandpass
figure out what to do about contrast level; apply these things at the C++ level
make things consistent in terms of what things are called & exactly
where they are stored.  Use boost python injector?
"""


 *******************************************************************************


 *******************************************************************************
rstbx/slip_viewer/__init__.py


 *******************************************************************************


 *******************************************************************************
rstbx/slip_viewer/calibration_frame.py
# -*- mode: python; coding: utf-8; indent-tabs-mode: nil; python-indent: 2 -*-
#
# $Id$

from __future__ import absolute_import, division, print_function
from six.moves import range

import wx
from scitbx.matrix import col


class SBSettingsFrame(wx.MiniFrame):
  def __init__(self, *args, **kwds):
    super(SBSettingsFrame, self).__init__(*args, **kwds)
    szr = wx.BoxSizer(wx.VERTICAL)
    panel = SBSettingsPanel(self)
    self.SetSizer(szr)
    szr.Add(panel, 1, wx.EXPAND)
    szr.Fit(panel)
    self.panel = panel
    self.sizer = szr
    self.Fit()
    self.Bind(wx.EVT_CLOSE, lambda evt : self.Destroy(), self)

  # XXX Could have a set_image() function instead of referring back to
  # the frame all the time?


class SBSettingsPanel(wx.Panel):
  # XXX Names: they're not really settings.  XXX Allow for setting
  # rotation, and provide a hierarchical drop-down menu to play with
  # detector, panel, sensor and ASIC.

  def __init__(self, *args, **kwds):
    super(SBSettingsPanel, self).__init__(*args, **kwds)
    sizer = wx.BoxSizer(wx.VERTICAL)
    self.SetSizer(sizer)

    # Number of decimal digits for distances.
    self.digits = 2

    # Quad translation controls
    from wx.lib.agw.floatspin import EVT_FLOATSPIN, FloatSpin

    img = self.GetParent().GetParent().pyslip.tiles.raw_image
    d = img.get_detector()
    self._quad_spinners = []
    for serial in range(4):
      fast, slow = d.hierarchy()[serial].get_origin()[0:2]
      name_quadrant = ["Q0", "Q1", "Q2", "Q3"][serial]
      box = wx.BoxSizer(wx.HORIZONTAL)

      for (name_direction, value) in [("fast", fast), ("slow", slow)]:
        name_ctrl = name_quadrant + "_" + name_direction + "_ctrl"

        spinner = FloatSpin(
          self, digits=self.digits, name=name_ctrl, value=value)
        self.Bind(EVT_FLOATSPIN, self.OnUpdateQuad, spinner)

        box.Add(spinner,
                0, wx.RIGHT|wx.TOP|wx.BOTTOM|wx.ALIGN_CENTER_VERTICAL, 5)
        box.Add(wx.StaticText(self, label=name_quadrant + " " + name_direction),
                0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)

        setattr(self, "_" + name_ctrl, spinner)
        self._quad_spinners.append(spinner)

      sizer.Add(box)

    #Spinner amount control
    box = wx.BoxSizer(wx.HORIZONTAL)
    self._spinner_amt_control = FloatSpin(
      self, digits=self.digits, name="spin_amount", value=1, min_val= 0.1, increment=0.1)
    self.Bind(EVT_FLOATSPIN, self.OnSpinAmount, self._spinner_amt_control)
    box.Add(self._spinner_amt_control,
            0, wx.RIGHT|wx.TOP|wx.BOTTOM|wx.ALIGN_CENTER_VERTICAL, 5)
    box.Add(wx.StaticText(self, label="Spinner increment (mm)"),
            0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
    sizer.Add(box)

    box = wx.BoxSizer(wx.HORIZONTAL)

    btn = wx.Button(self, label="Restore metrology")
    box.Add(btn, flag=wx.ALL, border=5)
    self.Bind(wx.EVT_BUTTON, self.OnRestoreMetrology, btn)

    btn = wx.Button(self, label="Save current metrology")
    box.Add(btn, flag=wx.ALL, border=5)
    self.Bind(wx.EVT_BUTTON, self.OnSaveMetrology, btn)

    sizer.Add(box, flag=wx.ALIGN_CENTER)

    # XXX Rename to metrology tool?


  def OnRestoreMetrology(self, event):
    print("Not implemented")
    return

    dialog = wx.FileDialog(
      self,
      defaultDir="",
      message="Restore metrology file",
      style=wx.FD_OPEN,
      wildcard="Phil files (*.eff; *.def)|*.eff;*.def")
    if dialog.ShowModal() == wx.ID_OK:
      path = dialog.GetPath()
      if (path != ""):
        from serialtbx.detector.legacy_metrology.metrology import \
          master_phil, metrology_as_transformation_matrices
        from libtbx import phil

        frame = self.GetParent().GetParent()
        stream = open(path)
        metrology_phil = master_phil.fetch(sources=[phil.parse(stream.read())])
        stream.close()

        # Merge restored metrology into the raw image
        from libtbx.phil import experimental
        experimental.merge_params_by_key(
          frame.pyslip.tiles.raw_image._metrology_params,
          metrology_phil.extract(),
          'serial')

        img = frame.pyslip.tiles.raw_image
        img.apply_metrology_from_matrices(metrology_as_transformation_matrices(
          metrology_phil.extract()))

        # Update the view, trigger redraw.  XXX Duplication
        # w.r.t. OnUpdateQuad().
        tiles = frame.pyslip.tiles
        tiles.flex_image = frame.pyslip.tiles.raw_image.get_flex_image(
          brightness=tiles.current_brightness / 100)
        tiles.flex_image.adjust(color_scheme=tiles.current_color_scheme)

        tiles.reset_the_cache()
        tiles.tile_cache = tiles.cache[tiles.zoom_level]
        tiles.tile_list = tiles.lru[tiles.zoom_level]
        frame.pyslip.Update()

        # Update the controls, remember to reset the default values
        # for the spinners.
        for serial in range(4):
          fast, slow = img.get_panel_fast_slow(serial)
          name_quadrant = ["Q0", "Q1", "Q2", "Q3"][serial]

          spinner = getattr(self, "_" + name_quadrant + "_fast_ctrl")
          spinner.SetDefaultValue(fast)
          spinner.SetValue(fast)

          spinner = getattr(self, "_" + name_quadrant + "_slow_ctrl")
          spinner.SetDefaultValue(slow)
          spinner.SetValue(slow)


  def OnSaveMetrology(self, event):
    import pycbf, os

    dialog = wx.FileDialog(
      self,
      defaultDir=os.curdir,
      defaultFile="quadrants.def",
      message="Save metrology file",
      style=wx.FD_SAVE | wx.FD_OVERWRITE_PROMPT,
      wildcard="Phil files (*.def)|*.def")
    if dialog.ShowModal() == wx.ID_OK:
      path = str(dialog.GetPath())
      if (path != ""):
        # The detector object of the format instance is adjusted when the quadrant calibration
        # arrows are clicked.  Sync those adjustments to a new cbf handle, drop uneeded categories
        # (categories frame specific but not metrology specific) and write the file.
        frame = self.GetParent().GetParent()
        img = frame.pyslip.tiles.raw_image
        header=img.image_set.get_format_class()(img.full_path)
        header.sync_detector_to_cbf(img.get_detector())
        cbf = header._cbf_handle
        cbf.find_category("array_data")                  ; cbf.remove_category()
        cbf.find_category("array_structure")             ; cbf.remove_category()
        cbf.find_category("array_intensities")           ; cbf.remove_category()
        cbf.find_category("diffrn_radiation")            ; cbf.remove_category()
        cbf.find_category("diffrn_radiation_wavelength") ; cbf.remove_category()
        cbf.find_category("diffrn_measurement")          ; cbf.remove_category()
        cbf.find_category("diffrn_scan")                 ; cbf.remove_category()
        cbf.find_category("diffrn_scan_frame")           ; cbf.remove_category()

        cbf.write_widefile(path,pycbf.CBF,\
              pycbf.MIME_HEADERS|pycbf.MSG_DIGEST|pycbf.PAD_4K,0)

        print("Saved cbf header to", path)


  def OnUpdateQuad(self, event):
    # Get the name of the spinner and its delta, the deviation from
    # the default value.  Update the default for the next event.
    obj = event.EventObject
    name = obj.GetName()
    value = obj.GetValue()
    delta = float(value - obj.GetDefaultValue())
    obj.SetDefaultValue(value)

    # Update the frame's effective metrology parameters.
    frame = self.GetParent().GetParent()
    img = frame.pyslip.tiles.raw_image

    quads = img.get_detector().hierarchy()

    if   (name == "Q0_fast_ctrl"): quad, delta = (quads[0], col((delta,0,0)))
    elif (name == "Q0_slow_ctrl"): quad, delta = (quads[0], col((0,delta,0)))
    elif (name == "Q1_fast_ctrl"): quad, delta = (quads[1], col((delta,0,0)))
    elif (name == "Q1_slow_ctrl"): quad, delta = (quads[1], col((0,delta,0)))
    elif (name == "Q2_fast_ctrl"): quad, delta = (quads[2], col((delta,0,0)))
    elif (name == "Q2_slow_ctrl"): quad, delta = (quads[2], col((0,delta,0)))
    elif (name == "Q3_fast_ctrl"): quad, delta = (quads[3], col((delta,0,0)))
    elif (name == "Q3_slow_ctrl"): quad, delta = (quads[3], col((0,delta,0)))
    else:
      raise RuntimeError("Unknown control name " + name)

    ldm = quad.get_local_d_matrix()
    fast = (ldm[0],ldm[3],ldm[6])
    slow = (ldm[1],ldm[4],ldm[7])

    orig = col((ldm[2],ldm[5],ldm[8])) + delta

    quad.set_local_frame(fast,slow,orig)

    # Update the view, trigger redraw.
    tiles = frame.pyslip.tiles
    tiles.set_image(tiles.raw_image)
    tiles.flex_image.adjust(color_scheme=tiles.current_color_scheme)

    tiles.reset_the_cache()
    tiles.tile_cache = tiles.cache[tiles.zoom_level]
    tiles.tile_list = tiles.lru[tiles.zoom_level]
    frame.pyslip.Update()

  def OnSpinAmount(self, event):
    obj = event.EventObject
    for spinner in self._quad_spinners:
      spinner.SetIncrement(obj.GetValue())


 *******************************************************************************


 *******************************************************************************
rstbx/slip_viewer/example_frame_plugin_hidden.py
from __future__ import absolute_import, division, print_function
# -*- Mode: Python; c-basic-offset: 2; indent-tabs-mode: nil; tab-width: 8 -*-
#
# $Id: ring_frame.py 18950 2013-12-20 20:23:08Z phyy-nx $

import wx

### Enable the plugin by renaming to end in "_frame_plugin.py"

class ExampleSettingsFrame(wx.MiniFrame):
  def __init__(self, *args, **kwds):
    super(ExampleSettingsFrame, self).__init__(*args, **kwds)
    szr = wx.BoxSizer(wx.VERTICAL)
    panel = ExampleSettingsPanel(self)
    self.SetSizer(szr)
    szr.Add(panel, 1, wx.EXPAND)
    szr.Fit(panel)
    self.panel = panel
    self.sizer = szr
    self.Fit()
    self.Bind(wx.EVT_CLOSE, lambda evt : self.Destroy(), self)


class ExampleSettingsPanel(wx.Panel):
  def __init__(self, *args, **kwds):

    super(ExampleSettingsPanel, self).__init__(*args, **kwds)

    # Needed to draw and delete the overlay
    self._pyslip = self.GetParent().GetParent().pyslip

    sizer = wx.BoxSizer(wx.VERTICAL)
    self.SetSizer(sizer)

    # Number of decimal digits
    self.digits = 2

    from wx.lib.agw.floatspin import EVT_FLOATSPIN, FloatSpin

    # Set initial values
    self._radius = 100
    self._center = [0, 0]
    radius_max = 2000
    radius_min = 10

    # Bind data to controls -- duplicate this section for each control
    box = wx.BoxSizer(wx.HORIZONTAL)
    self.slider = wx.Slider(self, maxValue=radius_max,
                            minValue=radius_min, size=(250, -1),
                            style=wx.SL_AUTOTICKS | wx.SL_HORIZONTAL,
                            value=self._radius)
    box.Add(self.slider,
            0, wx.RIGHT | wx.TOP | wx.BOTTOM | wx.ALIGN_CENTER_VERTICAL, 5)
    self.Bind(wx.EVT_SLIDER, self.OnSlide, self.slider)

    self.spinner = FloatSpin(self, digits=self.digits, max_val=radius_max,
                             min_val=radius_min, value=self._radius)
    box.Add(self.spinner,
            0, wx.RIGHT | wx.TOP | wx.BOTTOM | wx.ALIGN_CENTER_VERTICAL, 5)
    self.Bind(EVT_FLOATSPIN, self.OnSpin, self.spinner)

    sizer.Add(box)
    # end duplicate section

    # Update
    self.DrawRing()


  def __del__(self):
    # Delete layer method
    if (hasattr(self, "_ring_layer") and self._ring_layer is not None):
      self._pyslip.DeleteLayer(self._ring_layer)


  def OnSlide(self, event):
    # Keep slider and spinner synchronized
    obj = event.EventObject
    self._radius = obj.GetValue()
    self.spinner.SetValue(self._radius)

    self.DrawRing()

  def OnSpin(self, event):
    # Keep slider and spinner synchronized
    obj = event.EventObject
    self._radius = obj.GetValue()
    self.slider.SetValue(self._radius)

    self.DrawRing()

  def _draw_ring_layer(self, dc, data, map_rel):
    """Draw a points layer.

    dc       the device context to draw on
    data     an iterable of point tuples:
             (x, y, place, radius, colour, x_off, y_off, pdata)
    map_rel  points relative to map if True, MUST BE TRUE for lightweight
    Assumes all points are the same colour, saving 100's of ms.
    """

    assert map_rel is True
    if len(data)==0:
      return
    (lon, lat, place, radius, colour, x_off, y_off, pdata) = data[0]

    scale = 2**self._pyslip.tiles.zoom_level

    # Draw points on map/view, using transparency if implemented.
    try:
      dc = wx.GCDC(dc)
    except NotImplementedError:
      pass
    dc.SetPen(wx.Pen(colour))
    dc.SetBrush(wx.Brush(colour, wx.TRANSPARENT))
    for (lon, lat, place, radius, colour, x_off, y_off, pdata) in data:
      (x, y) = self._pyslip.ConvertGeo2View((lon, lat))
      dc.DrawCircle(x, y, radius * scale)


  def DrawRing(self):
    detector = self._pyslip.tiles.raw_image.get_detector()
    beam     = self._pyslip.tiles.raw_image.get_beam()

    if len(detector) > 1:
      beam_pixel_fast, beam_pixel_slow = detector[0].millimeter_to_pixel(  # FIXME assumes all detector elements use the same
        detector.hierarchy().get_beam_centre(beam.get_s0()))               # millimeter-to-pixel convention
    else:
      beam_pixel_fast, beam_pixel_slow = detector[0].millimeter_to_pixel(
        detector[0].get_beam_centre(beam.get_s0()))

    center = self._pyslip.tiles.picture_fast_slow_to_map_relative(
      beam_pixel_fast + self._center[0], beam_pixel_slow + self._center[1])

    ring_data = [(center[0], center[1],
                  {"colour": "red", "radius": self._radius})]

    # Remove the old ring layer, and draw a new one.
    if (hasattr(self, "_ring_layer") and self._ring_layer is not None):
      self._pyslip.DeleteLayer(self._ring_layer)
      self._ring_layer = None
    self._ring_layer = self._pyslip.AddPointLayer(
      ring_data,
      map_rel=True,
      visible=True,
      show_levels=[-3, -2, -1, 0, 1, 2, 3, 4, 5],
      renderer=self._draw_ring_layer,
      name="<ring_layer>")

class PluginHelper(object):
  _plugin_layer = "_example_layer"
  _plugin_title = "Example ring-drawing tool"
  _plugin_hide_text = "Hide example tool"
  _plugin_show_text = "Show example tool"
  _plugin_settings_frame = ExampleSettingsFrame
  _plugin_settings_panel = ExampleSettingsPanel


 *******************************************************************************


 *******************************************************************************
rstbx/slip_viewer/frame.py
# -*- mode: python; coding: utf-8; indent-tabs-mode: nil; python-indent: 2 -*-
#
# Known issues: Recentering on resize and when switching between
# different image types.  Ring centre on image switch.
#
# $Id$

from __future__ import absolute_import, division, print_function
from six.moves import range

import os
import wx

from rstbx.viewer.frame import EVT_EXTERNAL_UPDATE
from rstbx.viewer.frame import XrayFrame as XFBaseClass
from rstbx.viewer import settings as rv_settings, image as rv_image
from wxtbx import bitmaps

from .slip_display import AppFrame

class chooser_wrapper(object):
  def __init__(self, image_set, index):
    self.image_set = image_set
    self.path = os.path.basename(image_set.get_path(index))
    self.full_path = image_set.get_path(index)
    self.index = index
    self._raw_data = None

  def __str__(self):
    return "%s [%d]"%(self.path,self.index+1)

  def get_detector(self):  return self.image_set.get_detector()
  def get_scan(self):  return self.image_set.get_scan()
  def get_beam(self):  return self.image_set.get_beam()
  def get_mask(self):
    return self.image_set.get_mask(self.index)

  def get_raw_data(self):
    if self._raw_data is None:
      return self.image_set[self.index]
    return self._raw_data

  def set_raw_data(self, raw_data):
    self._raw_data = raw_data

  def get_detectorbase(self):
    return self.image_set.get_detectorbase(self.index)

  def get_vendortype(self):
    return self.image_set.get_vendortype(self.index)

  def show_header(self):
    return self.image_set.get_detectorbase(self.index).show_header()

class XrayFrame(AppFrame,XFBaseClass):
  def __init__(self, *args, **kwds):
    self.params = kwds.get("params", None)
    if "params" in kwds:
      del kwds["params"] #otherwise wx complains

    ### Collect any plugins
    import imp
    slip_viewer_dir = os.path.join(os.path.dirname(__file__))
    contents = os.listdir(slip_viewer_dir)
    plugin_names = [f.split(".py")[0] for f in contents if f.endswith("_frame_plugin.py")]
    self.plugins = {}
    for name in plugin_names:
      self.plugins[name] = imp.load_source(name, os.path.join(slip_viewer_dir, name + ".py"))
    if len(plugin_names) > 0:
      print("Loaded plugins: " + ", ".join(plugin_names))

    wx.Frame.__init__(self,*args,**kwds)
    self.settings = rv_settings()

    self.sizer = wx.BoxSizer(wx.VERTICAL)
    self.SetSizer(self.sizer)

    # initialization is done in stages as windows are created
    self.pyslip = None
    self.viewer = wx.Panel(self, wx.ID_ANY)
    self.viewer.SetMinSize((640,640))
    self.viewer.SetBackgroundColour(wx.BLACK)
    self.viewer.ClearBackground()
    self.sizer.Add(self.viewer, 1, wx.EXPAND)

    self.statusbar = self.CreateStatusBar()
    self.settings_frame = None
    self._calibration_frame = None
    self._ring_frame = None
    self._uc_frame = None
    self._score_frame = None
    self._plugins_frame = {key:None for key in self.plugins}
    self.zoom_frame = None
    self.plot_frame = None

    self.metrology_matrices = None

    # Currently displayed image.  XXX Can this be zapped?
    self._img = None

    self._distl = None
    self.toolbar = self.CreateToolBar(style=wx.TB_TEXT)
    self.setup_toolbar()
    self.toolbar.Realize()
    self.mb = wx.MenuBar()
    self.setup_menus()
    self.SetMenuBar(self.mb)
    self.Fit()
    self.SetMinSize(self.GetSize())
    self.SetSize((720,720))

    self.Bind(EVT_EXTERNAL_UPDATE, self.OnExternalUpdate)

    self.Bind(wx.EVT_UPDATE_UI, self.OnUpdateUICalibration,
              id=self._id_calibration)
    self.Bind(wx.EVT_UPDATE_UI, self.OnUpdateUINext,
              id=wx.ID_FORWARD)
    self.Bind(wx.EVT_UPDATE_UI, self.OnUpdateUIPrevious,
              id=wx.ID_BACKWARD)
    self.Bind(wx.EVT_UPDATE_UI, self.OnUpdateUIRing,
              id=self._id_ring)
    self.Bind(wx.EVT_UPDATE_UI, self.OnUpdateUIUC,
              id=self._id_uc)
    self.Bind(wx.EVT_UPDATE_UI, self.OnUpdateUIScore,
              id=self._id_score)
    for p in self.plugins:
      self.Bind(wx.EVT_UPDATE_UI, self.OnUpdateUIPluginWrapper(p),
              id=self._id_plugins[p])

  # consolidate initialization of PySlip object into a single function
  def init_pyslip(self):
    self.set_pyslip(self.viewer)
    self.init_pyslip_presizer()

  def Show(self):
    # Due to the asynchronous nature of X11 on Linux, just showing a frame
    # does not guarantee window creation. The frame calls Raise() so that it
    # will be shown. This addresses an error with PySlip requiring the
    # window to exist before instantiation.
    super(XrayFrame,self).Show()
    self.Raise()

  def setup_toolbar(self):
    XFBaseClass.setup_toolbar(self)

    btn = self.toolbar.AddLabelTool(id=wx.ID_SAVEAS,
    label="Save As...",
    bitmap=bitmaps.fetch_icon_bitmap("actions","save_all", 32),
    shortHelp="Save As...",
    kind=wx.ITEM_NORMAL)
    self.Bind(wx.EVT_MENU, self.OnSaveAs, btn)

  # using StaticBox creates a horizontal white bar in Linux
  # replaces make_gui in slip_display.py
  def make_gui(self, parent):
    parent.sizer = wx.BoxSizer(wx.HORIZONTAL)
    parent.SetSizer(parent.sizer)
    parent.sizer.Add(self.pyslip,1,wx.EXPAND)

  def init_pyslip_presizer(self):
    self.demo_select_dispatch = {}

    #self.tile_directory = None#"/Users/nksauter/rawdata/demo/insulin_1_001.img"

    # build the GUI
    self.make_gui(self.viewer)

    from . import pyslip

    # finally, bind events to handlers
    self.pyslip.Bind(pyslip.EVT_PYSLIP_SELECT, self.handle_select_event)
    self.pyslip.Bind(pyslip.EVT_PYSLIP_POSITION, self.handle_position_event)
    self.pyslip.Bind(pyslip.EVT_PYSLIP_LEVEL, self.handle_level_change)

  def init_pyslip_postsizer(self):
    self.pyslip.ZoomToLevel(-2)#tiles.zoom_level
    self.pyslip.GotoPosition(
      self.pyslip.tiles.get_initial_instrument_centering_within_picture_as_lon_lat()
    )

  def setup_menus(self):
    file_menu = wx.Menu()
    self.mb.Append(file_menu, "File")
    item = file_menu.Append(-1, "Open integration results...")
    self.Bind(wx.EVT_MENU, self.OnLoadIntegration, item)
    item = file_menu.Append(-1, "Open image...")
    self.Bind(wx.EVT_MENU, self.OnLoadFile, item)
    self._actions_menu = wx.Menu()
    self.mb.Append(self._actions_menu, "Actions")
    #item = self._actions_menu.Append(-1, "Change beam center...")
    #self.Bind(wx.EVT_MENU, self.OnChangeBeamCenter, item)
    #item = self._actions_menu.Append(-1, "Reset beam center to header value")
    #self.Bind(wx.EVT_MENU, lambda evt: self.viewer.ResetBeamCenter(), item)
    item = self._actions_menu.Append(-1, "Save As...")
    self.Bind(wx.EVT_MENU, self.OnSaveAs, item)

    # Known wxWidgets/wxPython issue
    # (http://trac.wxwidgets.org/ticket/12394): stock item ID is
    # expected for zero-length text.  Work around by making text
    # contain single space. XXX Placement
    self._id_calibration = wx.NewId()
    item = self._actions_menu.Append(self._id_calibration, " ")
    self.Bind(wx.EVT_MENU, self.OnCalibration, source=item)

    # XXX Placement
    self._id_ring = wx.NewId()
    item = self._actions_menu.Append(self._id_ring, " ")
    self.Bind(wx.EVT_MENU, self.OnRing, source=item)

    # XXX Placement
    self._id_uc = wx.NewId()
    item = self._actions_menu.Append(self._id_uc, " ")
    self.Bind(wx.EVT_MENU, self.OnUC, source=item)

    # XXX Placement
    self._id_score = wx.NewId()
    item = self._actions_menu.Append(self._id_score, " ")
    self.Bind(wx.EVT_MENU, self.OnScore, source=item)

    self._id_plugins = {}
    for p in self.plugins:
      self._id_plugins[p] = wx.NewId()
      item = self._actions_menu.Append(self._id_plugins[p], " ")
      self.Bind(wx.EVT_MENU, self.OnPluginWrapper(p), source=item)

  def has_four_quadrants(self):
    d = self.pyslip.tiles.raw_image.get_detector()
    return len(d) > 1 and len(d.hierarchy()) == 4

  def add_file_name_or_data(self, file_name_or_data):
      """The add_file_name_or_data() function appends @p
      file_name_or_data to the image chooser, unless it is already
      present.  For file-backed images, the base name is displayed in
      the chooser.  If necessary, the number of entries in the chooser
      is pruned.  The function returns the index of the recently added
      entry.  XXX This is probably the place for heuristics to determine
      if the viewer was given a pattern, or a plain list of files.  XXX
      Rename this function, because it only deals with the chooser?
      """

      key = self.get_key(file_name_or_data)
      for i in range(self.image_chooser.GetCount()):
        if (key == str(self.image_chooser.GetClientData(i))):
          return i
      if (self.image_chooser.GetCount() >= self.CHOOSER_SIZE):
        self.image_chooser.Delete(0)
      i = self.image_chooser.GetCount()
      if (type(file_name_or_data) is dict):
        self.image_chooser.Insert(key, i, None)
      elif (isinstance(file_name_or_data, chooser_wrapper)):
        self.image_chooser.Insert(key, i, file_name_or_data)
      else :
        self.image_chooser.Insert(os.path.basename(key), i, key)
      return i

  def get_beam_center_px(self):
    """
    Get the beam center in pixel coordinates relative to the tile closest to it.
    @return panel_id, beam_center_fast, beam_center_slow. panel_id is the panel the
    returned coordinates are relative to.
    """
    detector = self.get_detector()
    beam     = self.get_beam()
    if abs(detector[0].get_distance()) == 0:
      return 0.0, 0.0

    # FIXME assumes all detector elements use the same millimeter-to-pixel convention
    try:
      # determine if the beam intersects one of the panels
      panel_id, (x_mm,y_mm) = detector.get_ray_intersection(beam.get_s0())
    except RuntimeError as e:
      if not ("DXTBX_ASSERT(" in str(e) and ") failure" in str(e)):
        # unknown exception from dxtbx
        raise e
      if len(detector) > 1:
        # find the panel whose center is closest to the beam.
        panel_id = 0
        lowest_res = 0
        for p_id, panel in enumerate(detector):
          w, h = panel.get_image_size()
          res = panel.get_resolution_at_pixel(beam.get_s0(), (w//2,h//2))
          if res > lowest_res:
            panel_id = p_id
            lowest_res = res
        x_mm,y_mm = detector[panel_id].get_beam_centre(beam.get_s0())

      else:
        panel_id = 0
        # FIXME this is horrible but cannot find easier way without
        # restructuring code - N.B. case I am debugging now is one
        # panel detector *parallel to beam* for which the question is
        # ill posed.
        try:
          x_mm,y_mm = detector[0].get_beam_centre(beam.get_s0())
        except RuntimeError as e:
          if 'DXTBX_ASSERT' in str(e):
            x_mm, y_mm = 0.0, 0.0
          else:
            raise e

    beam_pixel_fast, beam_pixel_slow = detector[panel_id].millimeter_to_pixel(
      (x_mm, y_mm))

    return panel_id, beam_pixel_fast, beam_pixel_slow

  def load_image(self, file_name_or_data, get_raw_data=None, show_untrusted=False):
    """The load_image() function displays the image from @p
    file_name_or_data.  The chooser is updated appropriately.
    """

    # Due to a bug in wxPython 3.0.2 for Linux
    # http://trac.wxwidgets.org/ticket/16034
    # the creation of the PySlip object is deferred until it is needed and
    # after other windows are created
    if (self.pyslip is None):
      self.init_pyslip()
    # The settings dialog is created after PySlip because it may require
    # values from PySlip
    if (self.settings_frame is None):
      self.OnShowSettings(None)
    self.Layout()

    if (isinstance(file_name_or_data, chooser_wrapper)):
      img = rv_image(file_name_or_data)
    else :
      try:
        img = rv_image(file_name_or_data.get_detectorbase())
      except AttributeError:
        img = rv_image(os.path.abspath(file_name_or_data))

    try:
      title = file_name_or_data.full_path
    except AttributeError as e:
      title = str(file_name_or_data)
    self.SetTitle(title)

    # Update the selection in the chooser.
    i = self.add_file_name_or_data(file_name_or_data)
    self.image_chooser.SetSelection(i)

    self.pyslip.tiles.show_untrusted = show_untrusted
    self.pyslip.tiles.current_brightness = self.settings.brightness
    self.pyslip.tiles.current_color_scheme = self.settings.color_scheme

    self.pyslip.tiles.set_image(
      file_name_or_data=img, metrology_matrices=self.metrology_matrices,
      get_raw_data=get_raw_data)

    # Initialise position zoom level for first image.  XXX Why do we
    # have to coll ZoomToLevel to refresh subsequent images?
    if (self._img is None):
      self.init_pyslip_postsizer()
    else:
      self.pyslip.ZoomToLevel(self.pyslip.tiles.zoom_level)

    self._img = img # XXX

    self.settings_frame.set_image(self._img)
    self.update_statusbar() # XXX Not always working?
    #self.Layout()

    detector = self.get_detector()
    if abs(detector[0].get_distance()) > 0:

      def map_coords(x, y, p):
        if len(self.pyslip.tiles.raw_image.get_detector()) > 1:
          y, x = self.pyslip.tiles.flex_image.tile_readout_to_picture(
            p, y - 0.5, x - 0.5)
        return self.pyslip.tiles.picture_fast_slow_to_map_relative(
          x, y)

      panel_id, beam_pixel_fast, beam_pixel_slow = self.get_beam_center_px()
      self.beam_center_cross_data = [
        ((map_coords(beam_pixel_fast + 3., beam_pixel_slow, panel_id),
          map_coords(beam_pixel_fast - 3., beam_pixel_slow, panel_id)),
         {'width': 2, 'color': '#0000FFA0', 'closed': False}),
        ((map_coords(beam_pixel_fast, beam_pixel_slow + 3., panel_id),
          map_coords(beam_pixel_fast, beam_pixel_slow - 3., panel_id)),
         {'width': 2, 'color': '#0000FFA0', 'closed': False})
                               ]

    # Unconditionally delete extra layers--update_settings() will add
    # them back if appropriate.  This also creates the self.*_layer
    # variables.
    if hasattr(self, 'beam_layer') and self.beam_layer is not None:
      self.pyslip.DeleteLayer(self.beam_layer, update=False)
    self.beam_layer = None

    if hasattr(self, 'spotfinder_layer') and self.spotfinder_layer is not None:
      self.pyslip.DeleteLayer(self.spotfinder_layer)
    self.spotfinder_layer = None

    if hasattr(self, 'tile_layer') and self.tile_layer is not None:
      self.pyslip.DeleteLayer(self.tile_layer)
    self.tile_layer = None

    if hasattr(self, 'tile_text_layer') and self.tile_text_layer is not None:
      self.pyslip.DeleteLayer(self.tile_text_layer)
    self.tile_text_layer = None

    # if hasattr(self, 'plugins_layer') and hasattr(self.plugins_layer, "__iter__"):
    #   for key in self.plugins_layer:
    #     if self.plugins_layer[key] is not None:
    #       self.pyslip.DeleteLayer(self.plugins_layer[key])
    # self.plugins_layer = {key:None for key in self.plugins}

    self.update_settings()

    # Destroy the calibration frame if it present but unsupported for
    # this image.  XXX Need to do something about the ring tool too
    # when switching between different kinds of images.  XXX Centering
    # is broken when switching between different kinds of images.
    if (self._calibration_frame and
        not self.has_four_quadrants()):
      self.OnCalibration(None)

  def get_detector(self):
    return self.pyslip.tiles.raw_image.get_detector()

  def get_beam(self):
    return self.pyslip.tiles.raw_image.get_beam()

  def get_key(self, file_name_or_data):
      """This overridden get_key() function returns the key of @p file_name_or_data
      if it's an DetectorImageBase object.  Otherwise it returns the super class's
      key
      """
      from iotbx.detectors.detectorbase import DetectorImageBase
      if isinstance(file_name_or_data, DetectorImageBase):
        return file_name_or_data.filename
      elif isinstance(file_name_or_data, chooser_wrapper):
        return str(file_name_or_data)
      else: return super(XrayFrame, self).get_key(file_name_or_data)

  def update_settings(self, layout=True):
    # XXX The zoom level from the settings panel are not taken into
    # account here.

    new_brightness = self.settings.brightness
    new_color_scheme = self.settings.color_scheme
    if new_brightness is not self.pyslip.tiles.current_brightness or \
       new_color_scheme is not self.pyslip.tiles.current_color_scheme:
      self.pyslip.tiles.update_brightness(new_brightness,new_color_scheme)

    if self.settings.show_beam_center:
      if self.beam_layer is None and hasattr(self, 'beam_center_cross_data'):
        self.beam_layer = self.pyslip.AddPolygonLayer(
          self.beam_center_cross_data, name="<beam_layer>",
          show_levels=[-2, -1, 0, 1, 2, 3, 4, 5], update=False)
    elif self.beam_layer is not None:
      self.pyslip.DeleteLayer(self.beam_layer, update=False)
      self.beam_layer = None

    if self.settings.show_spotfinder_spots:
      if self.spotfinder_layer is None:
        tdata = self.pyslip.tiles.get_spotfinder_data(self.params)
        self.spotfinder_layer = self.pyslip.AddPointLayer(
          tdata, color="green", name="<spotfinder_layer>",
          radius=2,
          renderer = self.pyslip.LightweightDrawPointLayer,
          show_levels=[-2, -1, 0, 1, 2, 3, 4, 5])
    elif self.spotfinder_layer is not None:
      self.pyslip.DeleteLayer(self.spotfinder_layer)
      self.spotfinder_layer = None

    if self.settings.show_effective_tiling:
      if self.tile_layer is None:
        tdata, ttdata = self.pyslip.tiles.get_effective_tiling_data(self.params)
        self.tile_layer = self.pyslip.AddPolygonLayer(
          tdata, name="<tiling_layer>",
          show_levels=[-2, -1, 0, 1, 2, 3, 4, 5])
      if self.tile_text_layer is None:
        self.tile_text_layer = self.pyslip.AddTextLayer(
          ttdata, name="<tiling_text_layer>",
          show_levels=[-2, -1, 0, 1, 2, 3, 4, 5],
          colour='#0000FFA0',
          textcolour='#0000FFA0',
          fontsize=30,
          placement='cc',
          radius=0)
    elif (self.tile_layer is not None) and (self.tile_text_layer is not None):
        self.pyslip.DeleteLayer(self.tile_layer)
        self.tile_layer = None
        self.pyslip.DeleteLayer(self.tile_text_layer)
        self.tile_text_layer = None

    if hasattr(self,"user_callback"):
      self.user_callback(self)
    self.pyslip.Update() #triggers redraw

  def OnCalibration(self, event):
    from rstbx.slip_viewer.calibration_frame import SBSettingsFrame

    if not self._calibration_frame:
      self._calibration_frame = SBSettingsFrame(
        self, wx.ID_ANY, "Quadrant calibration",
        style=wx.CAPTION | wx.CLOSE_BOX)
      self._calibration_frame.Show()
      self._calibration_frame.Raise()
    else:
      self._calibration_frame.Destroy()


  def OnRing(self, event):
    from .ring_frame import RingSettingsFrame

    if not self._ring_frame:
      self._ring_frame = RingSettingsFrame(
        self, wx.ID_ANY, "Ring tool",
        style=wx.CAPTION | wx.CLOSE_BOX)
      self._ring_frame.Show()
      self._ring_frame.Raise()
    else:
      self._ring_frame.Destroy()

  def OnUC(self, event):
    from .uc_frame import UCSettingsFrame

    if not self._uc_frame:
      self._uc_frame = UCSettingsFrame(
        self, wx.ID_ANY, "Unit cell tool",
        style=wx.CAPTION | wx.CLOSE_BOX)
      self._uc_frame.Show()
      self._uc_frame.Raise()
    else:
      self._uc_frame.Destroy()

  def OnScore(self, event):
    from .score_frame import ScoreSettingsFrame

    if not self._score_frame:
      self._score_frame = ScoreSettingsFrame(
        self, wx.ID_ANY, "Score tool",
        style=wx.CAPTION | wx.CLOSE_BOX)
      self._score_frame.Show()
      self._score_frame.Raise()
    else:
      self._score_frame.Destroy()

  def OnPluginWrapper(self, p):
    def OnPlugin(event):
      if not self._plugins_frame[p]:
        helper = self.plugins[p].PluginHelper
        self._plugins_frame[p] = helper._plugin_settings_frame(
          self, wx.ID_ANY, helper._plugin_title,
          style=wx.CAPTION | wx.CLOSE_BOX)
        self._plugins_frame[p].Show()
        self._plugins_frame[p].Raise()
      else:
        self._plugins_frame[p].Destroy()
    return OnPlugin

  def OnUpdateUICalibration(self, event):
    # If quadrant calibration is not supported for this image, disable
    # the corresponding menu item.  Toggle the menu item text
    # depending on the state of the tool.

    if self.has_four_quadrants():
      event.Enable(True)
      if self._calibration_frame:
        event.SetText("Hide quadrant calibration")
      else:
        event.SetText("Show quadrant calibration")
    else:
      event.Enable(False)
      event.SetText("Show quadrant calibration")


  def OnUpdateUINext(self, event):
    # Enable/disable the "Next" button based on the image's position
    # in the list.

    event.Enable(
      self.image_chooser.GetSelection() + 1 < self.image_chooser.GetCount())


  def OnUpdateUIPrevious(self, event):
    # Enable/disable the "Previous" button based on the image's
    # position in the list.

    event.Enable(self.image_chooser.GetSelection() >= 1)


  def OnUpdateUIRing(self, event):
    # Toggle the menu item text depending on the state of the tool.

    if self._ring_frame:
      event.SetText("Hide ring tool")
    else:
      event.SetText("Show ring tool")

  def OnUpdateUIUC(self, event):
    # Toggle the menu item text depending on the state of the tool.

    if self._uc_frame:
      event.SetText("Hide unit cell tool")
    else:
      event.SetText("Show unit cell tool")


  def OnUpdateUIScore(self, event):
    # Toggle the menu item text depending on the state of the tool.

    if self._score_frame:
      event.SetText("Hide score tool")
    else:
      event.SetText("Show score tool")

  def OnUpdateUIPluginWrapper(self, p):
    def OnUpdateUIPlugin(event):
      # Toggle the menu item text depending on the state of the tool.

      helper = self.plugins[p].PluginHelper
      if self._plugins_frame[p]:
        event.SetText(helper._plugin_hide_text)
      else:
        event.SetText(helper._plugin_show_text)
    return OnUpdateUIPlugin


  def OnSaveAs(self, event):
    ### XXX TODO: Save overlays
    ### XXX TODO: Fix bug where multi-asic images are slightly cropped due to tranformation error'

    try:
      import PIL.Image as Image
    except ImportError:
      import Image

    dialog = wx.FileDialog(
      self,
      defaultDir='',
      message="Save PNG or PDF file",
      style=wx.FD_SAVE | wx.FD_OVERWRITE_PROMPT,
      wildcard="PNG file (*.png)|*.png|PDF file (*.pdf)|*.pdf")
    if dialog.ShowModal() != wx.ID_OK:
      return

    file_name = dialog.GetPath()
    if file_name == '':
      return

    self.update_statusbar("Writing " + file_name + "...")
    if dialog.GetFilterIndex() == 0:
        from six.moves import cStringIO as StringIO

        # XXX Copied from tile_generation.py; all its disclaimers
        # apply.
        raw_img = self.pyslip.tiles.raw_image
        detector = raw_img.get_detector()
        data = raw_img.get_raw_data()
        if not isinstance(data, tuple): # XXX should not need this test
          data = (data,)
        if len(detector) > 1:
          from .tile_generation import _get_flex_image_multipanel
          flex_img = _get_flex_image_multipanel(
            brightness=self.settings.brightness / 100,
            panels=detector,
            raw_data=data,
            beam=raw_img.get_beam())
        else:
          from .tile_generation import _get_flex_image
          flex_img = _get_flex_image(
            brightness=self.settings.brightness / 100,
            data=data[0],
            saturation=detector[0].get_trusted_range()[1],
            vendortype=raw_img.get_vendortype())

        if flex_img.supports_rotated_tiles_antialiasing_recommended:
            currentZoom = self.pyslip.level
            self.pyslip.tiles.UseLevel(0) #1:1 zoom level

            try:
              x, y, width, height = self._img._raw.bounding_box_mm()
              x1, y1 = self._img._raw.detector_coords_as_image_coords(x,y)
              x2, y2 = self._img._raw.detector_coords_as_image_coords(x+width,y+height)
            except AttributeError:
              x1 = min([p.get_pixel_lab_coord(c)[0]/p.get_pixel_size()[0] \
                        for p in detector \
                        for c in [(0,0),(0,p.get_image_size()[1]),(p.get_image_size()[0],0),(p.get_image_size()[0],p.get_image_size()[1])]])
              y1 = min([p.get_pixel_lab_coord(c)[1]/p.get_pixel_size()[1] \
                        for p in detector \
                        for c in [(0,0),(0,p.get_image_size()[1]),(p.get_image_size()[0],0),(p.get_image_size()[0],p.get_image_size()[1])]])
              x2 = max([p.get_pixel_lab_coord(c)[0]/p.get_pixel_size()[0] \
                        for p in detector \
                        for c in [(0,0),(0,p.get_image_size()[1]),(p.get_image_size()[0],0),(p.get_image_size()[0],p.get_image_size()[1])]])
              y2 = max([p.get_pixel_lab_coord(c)[1]/p.get_pixel_size()[1] \
                        for p in detector \
                        for c in [(0,0),(0,p.get_image_size()[1]),(p.get_image_size()[0],0),(p.get_image_size()[0],p.get_image_size()[1])]])

            # Map > View - determine layout in X direction
            x_offset = x1
            import math
            start_x_tile = int(math.floor(x_offset / self.pyslip.tile_size_x))
            stop_x_tile = ((x2 + self.pyslip.tile_size_x - 1)/ self.pyslip.tile_size_x)
            stop_x_tile = int(stop_x_tile)
            col_list = range(start_x_tile, stop_x_tile)
            x_pix = start_x_tile * self.pyslip.tile_size_y - x_offset

            y_offset = y1
            start_y_tile = int(math.floor(y_offset / self.pyslip.tile_size_y))
            stop_y_tile = ((y2 + self.pyslip.tile_size_y - 1) / self.pyslip.tile_size_y)
            stop_y_tile = int(stop_y_tile)
            row_list = range(start_y_tile, stop_y_tile)
            y_pix_start = start_y_tile * self.pyslip.tile_size_y - y_offset

            bitmap = wx.EmptyBitmap(x2-x1, y2-y1)
            dc = wx.MemoryDC()
            dc.SelectObject(bitmap)

            # start pasting tiles
            for x in col_list:
                y_pix = y_pix_start
                for y in row_list:
                    dc.DrawBitmap(self.pyslip.tiles.GetTile(x, y), x_pix, y_pix, False)
                    y_pix += self.pyslip.tile_size_y
                x_pix += self.pyslip.tile_size_x

            dc.SelectObject(wx.NullBitmap)

            wximg = wx.ImageFromBitmap(bitmap)
            imageout = Image.new('RGB', (wximg.GetWidth(), wximg.GetHeight()))
            imageout.frombytes(wximg.GetData())

            self.pyslip.tiles.UseLevel(currentZoom)

        else: # write the image out at full resolution
            flex_img.setWindow(0.0, 0.0, 1)
            flex_img.spot_convention(0)
            flex_img.adjust(color_scheme=self.settings.color_scheme)
            flex_img.prep_string()
            data_string = flex_img.export_string
            try:
              imageout = Image.fromstring("RGB",
                                     (flex_img.ex_size2(), flex_img.ex_size1()),
                                     data_string)
            except NotImplementedError:
              imageout = Image.frombytes("RGB",
                                     (flex_img.ex_size2(), flex_img.ex_size1()),
                                     data_string)

        out = StringIO()
        imageout.save(out, "PNG")
        open(file_name, "wb").write(out.getvalue())

    elif dialog.GetFilterIndex() == 1:
        from reportlab.lib.units import inch
        from reportlab.pdfgen import canvas

        # Dots per inch in PDF output, and fudge factor to not make
        # fine features impossibly small.  XXX The fudge factor should
        # go.
        DPI = 72
        LINE_WIDTH_FACTOR = 0.6

        # XXX Copied from tile_generation.py; all its disclaimers
        # apply.
        raw_img = self.pyslip.tiles.raw_image
        detector = raw_img.get_detector()
        data = raw_img.get_raw_data()
        if not isinstance(data, tuple): # XXX should not need this test
          data = (data,)
        if len(detector) > 1:
          from .tile_generation import _get_flex_image_multipanel
          flex_img = _get_flex_image_multipanel(
            brightness=self.settings.brightness / 100,
            panels=detector,
            raw_data=data,
            beam=raw_img.get_beam())
        else:
          from .tile_generation import _get_flex_image
          flex_img = _get_flex_image(
            brightness=self.settings.brightness / 100,
            data=data[0],
            saturation=detector[0].get_trusted_range()[1],
            vendortype=raw_img.get_vendortype())

        flex_img.setWindow(0, 0, 1)
        flex_img.adjust(color_scheme=self.settings.color_scheme)
        flex_img.prep_string()

        # XXX Order of size1/size2 correct?
        pdf_size = (flex_img.size2() * inch / DPI,
                    flex_img.size1() * inch / DPI)
        pdf_canvas = canvas.Canvas(filename=file_name, pagesize=pdf_size)
        try:
          pil_img = Image.fromstring(
            'RGB', (flex_img.size2(), flex_img.size1()), flex_img.export_string)
        except NotImplementedError:
          pil_img = Image.frombytes(
            'RGB', (flex_img.size2(), flex_img.size1()), flex_img.export_string)

        pdf_canvas.drawInlineImage(
          pil_img, 0, 0, width=pdf_size[0], height=pdf_size[1])

        for layer_id in self.pyslip.layer_z_order:
          layer = self.pyslip.layer_mapping[layer_id]

          # XXX This would probably be more elegant if these were
          # functions in some layer class.  Note repeated roundabout
          # way (via a wx.Pen object) to extract RGB values from the
          # colour parameter.
          if layer.type == self.pyslip.TypeEllipse:
            from math import atan2, degrees, hypot
            from scitbx.matrix import col

            for (p, place, width, colour, closed, filled, fillcolour,
                 x_off, y_off, pdata) in layer.data:
              if layer.map_rel:
                pp = []
                for i in range(len(p)):
                  fs = self.pyslip.tiles.map_relative_to_picture_fast_slow(
                    p[i][0], p[i][1])
                  pp.append((fs[0] * inch / DPI,
                             pdf_size[1] - fs[1] * inch / DPI))
                ellipse_center = col(pp[0])
                major = col(pp[1]) - ellipse_center
                minor = col(pp[2]) - ellipse_center
              else:
                raise NotImplementedError(
                  "PDF output in view-relative coordinates not implemented")

              pen = wx.Pen(colour)
              pdf_canvas.setLineWidth(width * LINE_WIDTH_FACTOR)
              pdf_canvas.setStrokeColorRGB(pen.Colour.Red() / 255,
                                           pen.Colour.Green() / 255,
                                           pen.Colour.Blue() / 255)

              angle = atan2(major.elems[1], major.elems[0])
              r_major = hypot(major.elems[0], major.elems[1])
              r_minor = hypot(minor.elems[0], minor.elems[1])

              pdf_canvas.saveState()
              pdf_canvas.translate(
                ellipse_center.elems[0], ellipse_center.elems[1])

              pdf_canvas.rotate(degrees(angle))
              pdf_canvas.ellipse(-r_major, -r_minor, r_major, r_minor)
              pdf_canvas.restoreState()

          elif layer.type == self.pyslip.TypeImage:
            raise NotImplementedError(
              "PDF output of image layers not implemented")

          elif layer.type == self.pyslip.TypePoint:
            for (lon, lat, place, radius, colour,
                 x_off, y_off, pdata) in layer.data:
              if layer.map_rel:
                fs = self.pyslip.tiles.map_relative_to_picture_fast_slow(
                  lon, lat)
              else:
                raise NotImplementedError(
                  "PDF output in view-relative coordinates not implemented")

              pt = (fs[0] * inch / DPI, pdf_size[1] - fs[1] * inch / DPI)
              pen = wx.Pen(colour)
              pdf_canvas.setLineWidth(radius)
              pdf_canvas.setStrokeColorRGB(pen.Colour.Red() / 255,
                                           pen.Colour.Green() / 255,
                                           pen.Colour.Blue() / 255)
              pdf_canvas.circle(pt[0], pt[1], 0.5 * radius * inch / DPI)

          elif layer.type == self.pyslip.TypePolygon:
            for (p, place, width, colour, closed, filled, fillcolour,
                 x_off, y_off, pdata) in layer.data:
              path = pdf_canvas.beginPath()
              for i in range(len(p)):
                if layer.map_rel:
                  fs = self.pyslip.tiles.map_relative_to_picture_fast_slow(
                    p[i][0], p[i][1])
                else:
                  raise NotImplementedError(
                    "PDF output in view-relative coordinates not implemented")

                pt = (fs[0] * inch / DPI, pdf_size[1] - fs[1] * inch / DPI)
                if i == 0:
                  path.moveTo(pt[0], pt[1])
                else:
                  path.lineTo(pt[0], pt[1])

              if closed:
                path.close()

              pen = wx.Pen(colour)
              pdf_canvas.setFillColorRGB(pen.Colour.Red() / 255,
                                         pen.Colour.Green() / 255,
                                         pen.Colour.Blue() / 255)
              pdf_canvas.setLineWidth(width * LINE_WIDTH_FACTOR)
              pdf_canvas.setStrokeColorRGB(pen.Colour.Red() / 255,
                                           pen.Colour.Green() / 255,
                                           pen.Colour.Blue() / 255)
              pdf_canvas.drawPath(path, fill=filled)

          elif layer.type == self.pyslip.TypeText:
            for (lon, lat, tdata, placement,
                 radius, colour, textcolour, fontname, fontsize,
                 offset_x, offset_y, data) in layer.data:
              if placement != 'cc':
                print(Warning("Only centered placement available when drawing text on pdf"))
              if layer.map_rel:
                fs = self.pyslip.tiles.map_relative_to_picture_fast_slow(
                  lon, lat)
              else:
                raise NotImplementedError(
                  "PDF output in view-relative coordinates not implemented")
              from reportlab.pdfbase.pdfmetrics import stringWidth
              scale = 5 # XXX this scaleup by 5 is arbitrary!
              try:
                w = stringWidth(tdata, fontname, fontsize*scale)
              except KeyError:
                fontname = "Helvetica"
                w = stringWidth(tdata, fontname, fontsize*scale)
              if fs[0] - (w/2) < 0: # handle text falling off the left side
                txt = pdf_canvas.beginText(x = 0, y = fs[1])
              else:
                txt = pdf_canvas.beginText(x = fs[0]-(w/2), y = fs[1])
              txt.setFont(fontname, fontsize*scale)
              txt.setFillColor(textcolour)
              txt.setStrokeColor(textcolour)
              txt.textLine(tdata)
              pdf_canvas.drawText(txt)

        pdf_canvas.save()

    self.update_statusbar("Writing " + file_name + "..." + " Done.")


from rstbx.viewer.frame import SettingsFrame

def override_SF_set_image(self,image):
  self.Layout()
  self.Fit()
SettingsFrame.set_image = override_SF_set_image


 *******************************************************************************


 *******************************************************************************
rstbx/slip_viewer/pyslip.py
# -*- mode: python; coding: utf-8; indent-tabs-mode: nil; python-indent: 2 -*-
#
# $Id$

"""
A 'slippy map' widget for wxPython.

So why is this widget called 'pySlip'?

Well, in the OpenStreetMap world[1], a 'slippy map' is a browser map view
served by a tile server that can be panned and zoomed in the same way as
popularised by Google maps.  Such a map feels 'slippery', I guess.

Rather than 'slippy' I went for the slightly more formal 'pySlip' since the
thing is written in Python and therefore must have the obligatory 'py' prefix.

Even though this was originally written for a geographical application, the
underlying system only assumes a cartesian 2D coordinate system.  So pySlip
could be used to present a game map, 2D CAD view, or whatever.  The major
difficulty for most uses is to generate the map tiles.

[1] http://wiki.openstreetmap.org/index.php/Slippy_Map
"""
from __future__ import absolute_import, division, print_function
from six.moves import range


# Copyright (c) 2010, Ross Wilson (rzzzwilson@gmail.com). All rights reserved.
#
# Redistribution and use in source and binary forms, with or
# without modification, are permitted provided that the following conditions
# are met:
#  * Redistributions of source code must retain the above copyright notice,
#    this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
#  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.


import os
import sys
import glob
from six.moves import cPickle as pickle
import wx
from scitbx.matrix import col
import math

# if we don't have log.py, don't crash
try:
    import log
    log = log.Log('pyslip.log', log.Log.DEBUG)
except Exception:

    def log(*args, **kwargs):
        pass


__version__ = '2.2'

__all__ = ['PySlip']

WX3 = wx.VERSION[0] == 3

# type of SELECT events
EventPointSelect = 0
EventBoxSelect = 1
EventRightPointSelect = 2
EventRightBoxSelect = 3


######
# utility routines.
######

def point_inside_polygon(x, y, poly):
    """Decide if point is inside polygon.

    x     x coord of point in question
    y     y coord of point in question
    poly  polygon in form [(x1,y1), (x2,y2), ...]

    Returns True if point is properly inside polygon.
    May return True or False if point on edge of polygon.

    Slightly modified version of the 'published' algorithm found on the 'net.
    Instead of indexing into the poly, create a new poly that 'wraps around'.
    Even with the extra code, it runs in 2/3 the time.
    """

    l_poly = list(poly)
    new_poly = l_poly[:]
    new_poly.append(l_poly[0])

    inside = False

    (p1x, p1y) = new_poly[0]

    for (p2x, p2y) in new_poly:
        if y > min(p1y, p2y):
            if y <= max(p1y, p2y):
                if x <= max(p1x, p2x):
                    if p1y != p2y:
                        xinters = (y-p1y)*(p2x-p1x)/(p2y-p1y) + p1x
                    if p1x == p2x or x <= xinters:
                        inside = not inside
        (p1x, p1y) = (p2x, p2y)

    return inside


######
# Base class for the widget canvas - buffered and flicker-free.
######

class _BufferedCanvas(wx.Panel):
    """Implements a buffered, flicker-free canvas widget.

    This class is based on:
        http://wiki.wxpython.org/index.cgi/BufferedCanvas
    """

    # The backing buffer
    buffer = None

    def __init__(self, parent, id=wx.ID_ANY, pos=wx.DefaultPosition,
                 size=wx.DefaultSize, style=wx.NO_FULL_REPAINT_ON_RESIZE):
        """Initialize the canvas.

        parent  reference to 'parent' widget
        id      the unique widget ID
        pos     canvas position
        size    canvas size
        style   wxPython style
        """

        wx.Panel.__init__(self, parent, id, pos, size, style)

        # Bind events
        self.Bind(wx.EVT_PAINT, self.OnPaint)
        self.Bind(wx.EVT_SIZE, self.OnSize)

        # Disable background erasing (flicker-licious)
        def disable_event(*pargs, **kwargs):
            pass            # the sauce, please
        self.Bind(wx.EVT_ERASE_BACKGROUND, disable_event)

        # set callback upon onSize event
        self.onSizeCallback = None

    def Draw(self, dc):
        """Stub: called when the canvas needs to be re-drawn."""

        pass

    def Update(self):
        """Causes the canvas to be updated."""

        dc = wx.BufferedDC(wx.ClientDC(self), self.buffer)
        if WX3:
            dc.BeginDrawing()
        dc.Clear()
        self.Draw(dc)
        if WX3:
            dc.EndDrawing()

    def OnPaint(self, event):
        """Paint the canvas to the screen."""

        # Blit the front buffer to the screen
        wx.BufferedPaintDC(self, self.buffer)

    def OnSize(self, event=None):
        """Create a new off-screen buffer to hold drawn data."""

        (width, height) = self.GetClientSizeTuple() if WX3 else self.GetClientSize()
        if width == 0:
            width = 1
        if height == 0:
            height = 1
        self.buffer = wx.EmptyBitmap(width, height)

        self.view_width = width
        self.view_height = height

        # call onSize callback, if registered
        if self.onSizeCallback:
            self.onSizeCallback()

        # Now update the screen
        self.Update()

######
# Base class for a tile object - handles access to tiles.
######

class _Tiles(object):
    """An object to handle a pyslip tiles directory.

    Uses 'elephant' caching - it never forgets!
    TODO: Add more sophisticated limit + 'drop LRU' caching.
    """

    # the name of the tile info file (under the main tile dir)
    TileInfoFilename = 'tile.info'

    # expected form of individual tile level directories (2 decimal digits)
    TileFilenameTemplate = '[0-9][0-9]'

    # name of picture file to use if tile missing (under the main tile dir)
    MissingTileFilename = 'missing_tile.png'

    # maximum number of tiles held in each level cache
    MaxTileList = 4096

    def __init__(self, tile_dir):
        """Initialise a Tiles instance.

        tile_dir  root directory of tiles
        """

        # open top-level info file
        self.tile_dir = tile_dir
        info_file = os.path.join(tile_dir, self.TileInfoFilename)
        try:
            fd = open(info_file, 'rb')
            (self.extent, self.tile_size,
                 self.sea_colour, self.land_colour) = pickle.load(fd)
            fd.close()
        except IOError:
            msg = "'%s' doesn't appear to be a tile directory" % tile_dir
            raise Exception(msg)

        (self.tile_size_x, self.tile_size_y) = self.tile_size

        # get list of tile levels
        tile_mask = os.path.join(tile_dir, self.TileFilenameTemplate)
        self.levels = [int(os.path.basename(l))
                           for l in glob.glob(os.path.join(tile_mask))]

        # setup the tile caches and LRU lists
        self.cache = {}
        self.lru = {}
        for l in self.levels:
            self.cache[l] = {}
            self.lru[l] = []
        self.missing_tile = None

        # set min and max tile levels
        self.min_level = min(self.levels)
        self.max_level = max(self.levels)

    def UseLevel(self, n):
        """Prepare to serve tiles from the required level.

        n  The required level

        Returns a tuple (map_width, map_height, ppd_x, ppd_y) if succesful,
        else None.  The width/height values are pixels.  The ppd_? values are
        pixels-per-degree values for X and Y direction.
        """

        # try to get cache for this level, no cache means no level
        try:
            self.tile_cache = self.cache[n]
            self.tile_list = self.lru[n]
        except KeyError:
            return None

        # get tile info
        info = self.GetInfo(n)
        if info is None:
            return None

        (self.num_tiles_x, self.num_tiles_y, self.ppd_x, self.ppd_y) = info

        # store partial path to level dir
        self.tile_level_dir = os.path.join(self.tile_dir, '%02d' % n)

        return (self.tile_size_x * self.num_tiles_x,
                self.tile_size_y * self.num_tiles_y,
                self.ppd_x, self.ppd_y)

    def GetInfo(self, level):
        """Get tile info for a particular level.

        level  the level to get tile info for

        Returns (num_tiles_x, num_tiles_y, ppd_x, ppd_y).
        """

        # see if we can open the tile info file.
        info_file = os.path.join(self.tile_dir, '%02d' % level,
                                 self.TileInfoFilename)
        try:
            fd = open(info_file, 'rb')
        except IOError:
            return None

        # OK, looks like we actually do have this level!
        info = pickle.load(fd)
        fd.close()

        return info

    def GetTile(self, x, y):
        """Get bitmap for tile at tile coords (x, y).

        x  X coord of tile required (tile coordinates)
        y  Y coord of tile required (tile coordinates)

        Returns bitmap object containing the tile image.

        Tile coordinates are measured from map top-left.

        If tile is in cache, read from there, else read from file & put
        into cache.  Use LRU cache algorithm to limit memory usage.
        """

        try:
            # if tile in cache, return it from there
            pic = self.tile_cache[(x, y)]
            index = self.tile_list.index((x, y))
            del self.tile_list[index]
        except KeyError:
            # tile *not* in cache: get image, cache and return it
            img_name = os.path.join(self.tile_level_dir,
                                    'tile_%d_%d.png' % (x, y))

            # load tile as not in cache
            if not os.path.exists(img_name):
                # tile not there, use 'missing tile'
                if not self.missing_tile:
                    # load missing tile
                    img_name = os.path.join(self.tile_dir,
                                            self.MissingTileFilename)
                    img = wx.Image(img_name, wx.BITMAP_TYPE_ANY)
                    self.missing_tile = img.ConvertToBitmap()
                pic = self.missing_tile
            else:
                # new tile, check if we must drop old tiles - LRU
                # remove oldest index at last element, then delete from dict
                if len(self.tile_list) > self.MaxTileList:
                    drop_element = self.tile_list.pop()
                    del self.tile_cache[drop_element]

                # we have the tile file - read into memory, cache & return
                img = wx.Image(img_name, wx.BITMAP_TYPE_ANY)
                pic = img.ConvertToBitmap()
                self.tile_cache[(x, y)] = pic

        self.tile_list.insert(0, (x, y))
        return pic

######
# A layer class - encapsulates all layer data.
######

class _Layer(object):
    """A Layer object."""

    DefaultDelta = 5        # default selection delta

    def __init__(self, id=0, painter=None, data=None, map_rel=True,
                 visible=False, show_levels=None, selectable=False,
                 name="<no name given>", type=None):
        """Initialise the Layer object.

        id           unique layer ID
        painter      render function
        data         the layer data
        map_rel      True if layer is map-relative, else layer-relative
        visible      layer visibility
        show_levels  list of levels at which to auto-show the level
        selectable   True if select operates on this layer, Else False
        name         the name of the layer (for debug)
        type         a layer 'type' flag
        """

        self.painter = painter          # routine to draw layer
        self.data = data                # data that defined the layer
        self.map_rel = map_rel          # True if layer is map relative
        self.visible = visible          # True if layer visible
        self.show_levels = show_levels  # None or list of levels to auto-show
        self.selectable = selectable    # True if we can select on this layer
        self.delta = self.DefaultDelta  # minimum distance for selection
        self.name = name                # name of this layer
        self.type = type                # type of layer
        self.id = id                    # ID of this layer

    def __str__(self):
        return ('<pyslip Layer: id=%d, name=%s, map_rel=%s, visible=%s'
                % (self.id, self.name, str(self.map_rel), str(self.visible)))

###############################################################################
# A Resource class that abstracts loading/storing resources from/to disk.
###############################################################################

class Resource(object):
    """A class to allow the loading of layer data to/from disk as a resource.

    An instance of Resource has the following attributes/methods:
        .layers      a dictionary of named Layer objects
        .AddLayer()  add a layer to the resource
        .GetLayer()  get a layer resource by name and type
        .Read()      read a resource from disk
        .Write()     write resource to disk
    """

    def __init__(self, fname=None):
        """Initialise a Resource object, optionally loading data from disk.

        fname  path to a resource file to read
        """

        # set default attributes
        self.layers = {}
        self.filename = fname
        if fname:
            self.Read(fname)

    def Read(self, fname):
        """Read a resource from disk.

        fname  path to file to read

        fname overwrites self.filename.
        """

        self.filename = fname

        try:
            import json
            self.layers = json.load(open(fname))
        except IOError as e:
            msg = 'Error opening %s: %s' % (fname, str(e))
            raise IOError(msg)

    def Write(self, fname=None):
        """Write the Resource to disk.

        fname  path to file to write (default is load self.filename)

        If fname is supplied, it overwrites self.filename.
        """

        if fname:
            self.filename = fname

        if not self.filename:
            raise Exception('Write() called but no filename supplied')

        import json
        json.dump(self.layers, open(self.filename, 'wb'), ensure_ascii=False,
                      indent=2, separators=(',', ':'))

    def AddLayer(self, name, layer_type, data):
        """Add a layer to the Resource.

        name        name of the layer
        layer_type  type of the layer
        data        layer data
        """

        self.layers[name] = (layer_type, data)

    def GetLayers(self):
        """Get layers object.

        Returns a dict: {'layer_name': <layer_data>, ...}
        """

        return self.layers

    def GetLayer(self, name):
        """Get a layer by name.

        name  name of the layer to get

        Returns a tuple (layer_type, data), or None if not found.
        """

        return self.layers.get(name, None)

    def DeleteLayer(self, name):
        """Delete a layer by name.

        name  name of the layer to delete
        """

        try:
            del self.layers[name]
        except KeyError:
            pass

    def __len__(self):
        """Makes len(Resource) return number of layers held."""

        return len(self.layers)

###############################################################################
# The wxPython pySlip widget events.
# define the events that are raised by the pySlip widget
###############################################################################

# point/box select
_myEVT_PYSLIP_SELECT = wx.NewEventType()
EVT_PYSLIP_SELECT = wx.PyEventBinder(_myEVT_PYSLIP_SELECT, 1)

# point RIGHT select
_myEVT_PYSLIP_RIGHTSELECT = wx.NewEventType()
EVT_PYSLIP_RIGHTSELECT = wx.PyEventBinder(_myEVT_PYSLIP_RIGHTSELECT, 1)

# level change
_myEVT_PYSLIP_LEVEL = wx.NewEventType()
EVT_PYSLIP_LEVEL = wx.PyEventBinder(_myEVT_PYSLIP_LEVEL, 1)

# mouse geo position change
_myEVT_PYSLIP_POSITION = wx.NewEventType()
EVT_PYSLIP_POSITION = wx.PyEventBinder(_myEVT_PYSLIP_POSITION, 1)


class _PySlipEvent(wx.PyCommandEvent):
    """Event sent from the pySlip widget."""

    def __init__(self, eventType, id):
        """Construct a PySlip event.

        eventType  type of event
        id         unique event number

        Event will be adorned with attributes by raising code.
        """

        wx.PyCommandEvent.__init__(self, eventType, id)

###############################################################################
# The wxPython pySlip widget proper
###############################################################################

class PySlip(_BufferedCanvas):
    """A widget to display a tiled map, a la Google maps."""

    # keep a temporary list of placement dictionaries for later compilation
    placements = []

    # dictionary for map-relative image placement
    # assumes variables x, y, w, h, w2, h2, x_off & y_off are set
    # perturbs x and y to top-left image corner for placing
    image_map_placement = {'cc': 'x=x-w2+x_off;  y=y-h2+y_off',
                           'nw': 'x=x+x_off;     y=y+y_off',
                           'cn': 'x=x-w2+x_off;  y=y+y_off',
                           'ne': 'x=x-w+x_off;   y=y+y_off',
                           'ce': 'x=x-w+x_off;   y=y-h2+y_off',
                           'se': 'x=x-w+x_off;   y=y-h+y_off',
                           'cs': 'x=x-w2+x_off;  y=y-h+y_off',
                           'sw': 'x=x+x_off;     y=y-h+y_off',
                           'cw': 'x=x+x_off;     y=y-h2+y_off'}
    placements.append(image_map_placement)

    # dictionary for view-relative image placement
    # assumes variables x, y, w, h, dc_w, dc_h, x_off, y_off are set
    # perturbs x and y to top-left image corner for drawing
    image_view_placement = {'cc': 'x=dc_w2-w2;     y=dc_h2-h2',
                            'nw': 'x=x_off;        y=y_off',
                            'cn': 'x=dc_w2-w2;     y=y_off',
                            'ne': 'x=dc_w-w-x_off; y=y_off',
                            'ce': 'x=dc_w-w-x_off; y=dc_h2-h2',
                            'se': 'x=dc_w-w-x_off; y=dc_h-h-y_off',
                            'cs': 'x=dc_w2-w2;     y=dc_h-h-y_off',
                            'sw': 'x=x_off;        y=dc_h-h-y_off',
                            'cw': 'x=x_off;        y=dc_h2-h2'}
    placements.append(image_view_placement)

    # map-relative text placement dictionary
    # assumes variables x, y, w, h, dc_w, dc_h, x_off, y_off are set
    # w and h are text width and height
    # perturbs x and y to correct values for the placement
    text_map_placement = {'cc': 'x=x-w2;      y=y-h2',
                          'nw': 'x=x+x_off;   y=y+y_off',
                          'cn': 'x=x-w2;      y=y+y_off',
                          'ne': 'x=x-w-x_off; y=y+y_off',
                          'ce': 'x=x-w-x_off; y=y-h2',
                          'se': 'x=x-w-x_off; y=y-h-y_off',
                          'cs': 'x=x-w2;      y=y-h-y_off',
                          'sw': 'x=x+x_off;   y=y-h-y_off',
                          'cw': 'x=x+x_off;   y=y-h2'}
    placements.append(text_map_placement)

    # view-relative text placement dictionary
    # assumes variables x, y, w, h, dc_w, dc_h, x_off, y_off are set
    # w and h are text width and height
    # perturbs x and y to correct values for the placement
    text_view_placement = {'cc': 'x=x+dc_w2-w2; y=y+dc_h2-h2',
                           'nw': 'x=x;          y=y',
                           'cn': 'x=x+dc_w2-w2; y=y',
                           'ne': 'x=x+dc_w-w;   y=y',
                           'ce': 'x=x+dc_w-w;   y=y+dc_h2-h2',
                           'se': 'x=x+dc_w-w;   y=y+dc_h-h',
                           'cs': 'x=x+dc_w2-w2; y=y+dc_h-h',
                           'sw': 'x=x;          y=y+dc_h-h',
                           'cw': 'x=x;          y=y+dc_h2-h2'}
    placements.append(text_view_placement)

    # view-relative polygon placement dictionary
    # assumes variables x, y, dc_w, dc_h, x_off, y_off are set
    # perturbs x and y to correct values for the placement
    poly_view_placement = {'cc': 'x=x+dc_w2;      y=y+dc_h2',
                           'nw': 'x=x+x_off;      y=y+y_off',
                           'cn': 'x=x+dc_w2;      y=y+y_off',
                           'ne': 'x=x+dc_w-x_off; y=y+y_off',
                           'ce': 'x=x+dc_w-x_off; y=y+dc_h2-y_off',
                           'se': 'x=x+dc_w-x_off; y=y+dc_h-y_off',
                           'cs': 'x=x+dc_w2;      y=y+dc_h-y_off',
                           'sw': 'x=x+x_off;      y=y+dc_h-y_off',
                           'cw': 'x=x+x_off;      y=y+dc_h2'}
    placements.append(poly_view_placement)

    # dictionary for view-relative point placement
    # assumes variables x, y, dc_w, dc_h, x_off, y_off are set
    # perturbs x and y to point centre for drawing
    point_view_placement = {'cc': 'x=x+dc_w2;      y=y+dc_h2',
                            'nw': 'x=x+x_off;      y=y+y_off',
                            'cn': 'x=x+dc_w2;      y=y+y_off',
                            'ne': 'x=x+dc_w-x_off; y=y+y_off',
                            'ce': 'x=x+dc_w-x_off; y=y+dc_h2',
                            'se': 'x=x+dc_w-x_off; y=y+dc_h-y_off',
                            'cs': 'x=x+dc_w2;      y=y+dc_h-y_off',
                            'sw': 'x=x+x_off;      y=y+dc_h-y_off',
                            'cw': 'x=x+x_off;      y=y+dc_h2'}
    placements.append(point_view_placement)

    # now pre-compile all the placement string dictionaries
    for p_dict in placements:
        for key in p_dict:
            p_dict[key] = compile(p_dict[key], 'string', 'exec')
    del placements

    # panel background colour
    BackgroundColour = wx.WHITE

    # default text attributes - map relative
    DefaultTextPlacement = 'se'
    DefaultTextRadius = 2
    DefaultTextColour = wx.BLACK
    DefaultTextTextColour = wx.BLACK
    DefaultTextOffsetX = 5
    DefaultTextOffsetY = 1
    DefaultTextFontname = 'ArialMT'
    DefaultTextFontSize = 9
    DefaultTextData = None

    # default text attributes - view relative
    DefaultTextViewPlacement = 'se'
    DefaultTextViewRadius = 0
    DefaultTextViewColour = wx.BLACK
    DefaultTextViewTextColour = wx.BLACK
    DefaultTextViewOffsetX = 0
    DefaultTextViewOffsetY = 0
    DefaultTextViewFontname = 'ArialMT'
    DefaultTextViewFontSize = 9
    DefaultTextViewData = None

    # default point attributes
    DefaultPointPlacement = 'nw'
    DefaultPointRadius = 3
    DefaultPointColour = wx.RED
    DefaultPointOffsetX = 0
    DefaultPointOffsetY = 0
    DefaultPointData = None

    # default image attributes
    DefaultImagePlacement = 'cc'
    DefaultImageRadius = 0
    DefaultImageColour = wx.BLACK
    DefaultImageOffsetX = 0
    DefaultImageOffsetY = 0

    # default polygon attributes
    DefaultPolygonPlacement = 'cc'
    DefaultPolygonWidth = 1
    DefaultPolygonColour = wx.RED
    DefaultPolygonClose = False
    DefaultPolygonFilled = False
    DefaultPolygonFillcolour = 'blue'
    DefaultPolygonOffsetX = 0
    DefaultPolygonOffsetY = 0

    # layer type values
    TypePoint = 0
    TypeImage = 1
    TypePolygon = 2
    TypeText = 3
    TypeEllipse = 4

    def __init__(self, parent, tile_dir=None, start_level=None,
                 min_level=None, max_level=None, **kwargs):
        """Initialise a pySlip instance.

        parent       reference to parent object
        tile_dir     the root tile directory
        start_level  initial tile level to start at
        min_level    the minimum tile level to use
        max_level    the maximum tile level to use
        **kwargs     keyword args for Panel
        """

        # create and initialise the base panel
        _BufferedCanvas.__init__(self, parent=parent, **kwargs)
        self.SetBackgroundColour(PySlip.BackgroundColour)

        # get tile info
        self.tiles = _Tiles(tile_dir)

        if max_level:
            self.max_level = max_level
        else:
            self.max_level = self.tiles.max_level
        if min_level:
            self.min_level = min_level
        else:
            self.min_level = self.tiles.min_level
        if start_level:
            self.level = start_level
        else:
            self.level = self.min_level

        self.tile_size_x = self.tiles.tile_size_x
        self.tile_size_y = self.tiles.tile_size_y

        # set some internal state
        self.view_width = None          # view size in pixels
        self.view_height = None

        self.ppd_x = 0                  # pixel_per_degree for current tileset
        self.ppd_y = 0

        self.view_offset_x = 0          # pixel offset at left & top of view
        self.view_offset_y = 0

        self.NS_wrap = False            # disallow wraparound N-S
        self.EW_wrap = False            # disallow wraparound E-W

        self.view_llon = self.view_rlon = None  # view limits
        self.view_tlat = self.view_blat = None

        self.was_dragging = False               # True if dragging map
        self.move_dx = 0                        # drag delta values
        self.move_dy = 0
        self.last_drag_x = None                 # previous drag position
        self.last_drag_y = None

        self.ignore_next_up = False             # ignore next LEFT UP event
        self.ignore_next_right_up = False       # ignore next RIGHT UP event

        self.is_box_select = False              # True if box selection
        self.sbox_1_x = self.sbox_1_y = None    # box size

        # layer stuff
        self.next_layer_id = 1      # source of unique layer IDs
        self.layer_z_order = []     # layer Z order, contains layer IDs
        self.layer_mapping = {}     # maps layer ID to layer data

        # True if we send event to report mouse position in view
        self.mouse_position_event = True

        # True if event on right mouse click (right button up event)
        self.right_click_event = False

        # True if we send event on level change
        self.change_level_event = True

        # set up dispatch dictionary for layer select handlers
        # for point select
        self.layerPSelHandler = {self.TypePoint: self.GetNearestPointInLayer,
                                 self.TypeImage: self.GetNearestImageInLayer,
                                 self.TypePolygon:
                                     self.GetNearestPolygonInLayer,
                                 self.TypeText: self.GetNearestTextInLayer}

        # for box select
        self.layerBSelHandler = {self.TypePoint: self.GetBoxSelPointsInLayer,
                                 self.TypeImage: self.GetBoxSelImagesInLayer,
                                 self.TypePolygon:
                                     self.GetBoxSelPolygonsInLayer,
                                 self.TypeText: self.GetBoxSelTextsInLayer}

        # bind event handlers
        self.Bind(wx.EVT_MOTION, self.OnMove)
        self.Bind(wx.EVT_LEFT_DOWN, self.OnLeftDown)
        self.Bind(wx.EVT_LEFT_DCLICK, self.OnLeftDClick)
        self.Bind(wx.EVT_LEFT_UP, self.OnLeftUp)
        self.Bind(wx.EVT_MIDDLE_DOWN, self.OnMiddleDown)
        self.Bind(wx.EVT_MIDDLE_UP, self.OnMiddleUp)
        self.Bind(wx.EVT_RIGHT_DOWN, self.OnRightDown)
        self.Bind(wx.EVT_RIGHT_DCLICK, self.OnRightDClick)
        self.Bind(wx.EVT_RIGHT_UP, self.OnRightUp)
        self.Bind(wx.EVT_MOUSEWHEEL, self.OnMouseWheel)
        self.Bind(wx.EVT_ENTER_WINDOW, self.OnEnterWindow)
        self.Bind(wx.EVT_LEAVE_WINDOW, self.OnLeaveWindow)

        # OK, use the tile level the user wants
        self.ZoomToLevel(self.level)

        # set callback when parent resizes
        self.onSizeCallback = self.ResizeCallback

        # force a resize, which sets up the rest of the state
        self.OnSize()

    def OnEnterWindow(self, event):
        """Event handler when mouse enters widget."""

        pass

    def OnLeaveWindow(self, event):
        """Event handler when mouse leaves widget."""

        self.RaiseMousePositionEvent(None)

    ######
    # "add a layer" routines
    ######

    def AddPointLayer(self, points, map_rel=True, visible=True,
                      show_levels=None, selectable=False,
                      name='<points_layer>', update=True, **kwargs):
        """Add a layer of points.

        points       iterable of point data:
                         (x, y, [attributes])
                     where x & y are either lon&lat (map) or x&y (view) coords
                     and attributes is an optional dictionary of attributes for
                     each point with keys like:
                         'placement'  a placement string
                         'radius'     radius of point in pixels
                         'colour'     colour of point
                         'offset_x'   X offset
                         'offset_y'   Y offset
                         'data'       point data object
        map_rel      points are map relative if True, else view relative
        visible      True if the layer is to be immediately visible
        show_levels  list of levels at which layer is auto-shown (or None)
        selectable   True if select operates on this layer
        name         the 'name' of the layer - mainly for debug
        kwargs       a layer-specific attributes dictionary, has keys:
                         'placement'  a placement string
                         'radius'     radius of point in pixels
                         'colour'     colour of point
                         'offset_x'   X offset
                         'offset_y'   Y offset
                         'data'       point data object
        """

        # get global values
        default_placement = kwargs.get('placement',
                                       self.DefaultPointPlacement)
        default_radius = kwargs.get('radius', self.DefaultPointRadius)
        default_colour = self.get_i18n_kw(kwargs, ('colour', 'color'),
                                          self.DefaultPointColour)
        default_offset_x = kwargs.get('offset_x', self.DefaultPointOffsetX)
        default_offset_y = kwargs.get('offset_y', self.DefaultPointOffsetY)
        default_data = kwargs.get('data', self.DefaultPointData)

        # create data iterable for draw method
        draw_data = []              # list to hold draw data

        for pt in points:
            if len(pt) == 3:
                (x, y, attributes) = pt
            elif len(pt) == 2:
                (x, y) = pt
                attributes = {}
            else:
                msg = ('Points data must be iterable of tuples: '
                       '(x, y, [dict])\n'
                       'Got: %s' % str(pt))
                raise Exception(msg)

            # plug in any required layer defaults (override globals)
            placement = attributes.get('placement', default_placement)
            radius = attributes.get('radius', default_radius)
            colour = self.get_i18n_kw(attributes, ('colour', 'color'),
                                      default_colour)
            offset_x = attributes.get('offset_x', default_offset_x)
            offset_y = attributes.get('offset_y', default_offset_y)
            data = attributes.get('data', default_data)

            draw_data.append((x, y, placement.lower(),
                              radius, colour, offset_x, offset_y, data))

        return self.AddLayer(kwargs.get("renderer",self.DrawPointLayer), draw_data, map_rel,
                             visible=visible, show_levels=show_levels,
                             selectable=selectable, name=name,
                             type=self.TypePoint, update=update)

    def AddEllipseLayer(self, data, map_rel=True, visible=True,
                        show_levels=None, selectable=False,
                        name='<polygon_layer>', update=True, **kwargs):
        # get global values, if required
        default_placement = kwargs.get('placement',
                                       self.DefaultPolygonPlacement)
        default_width = kwargs.get('width', self.DefaultPolygonWidth)
        default_colour = self.get_i18n_kw(kwargs, ('colour', 'color'),
                                          self.DefaultPolygonColour)
        default_close = kwargs.get('closed', self.DefaultPolygonClose)
        default_filled = kwargs.get('filled', self.DefaultPolygonFilled)
        default_fillcolour = self.get_i18n_kw(kwargs,
                                              ('fillcolour', 'fillcolor'),
                                              self.DefaultPolygonFillcolour)
        default_offset_x = kwargs.get('offset_x', self.DefaultPolygonOffsetX)
        default_offset_y = kwargs.get('offset_y', self.DefaultPolygonOffsetY)

        draw_data = []
        for x in range(0,len(data),5):
          # Calculate ellipse center, major and minor axes.
          side1=col(( (data[x][0]+data[x+1][0])/2., (data[x][1]+data[x+1][1])/2.))
          side2=col(( (data[x+1][0]+data[x+2][0])/2., (data[x+1][1]+data[x+2][1])/2.))
          side3=col(( (data[x+2][0]+data[x+3][0])/2., (data[x+2][1]+data[x+3][1])/2.))
          side4=col(( (data[x+3][0]+data[x+4][0])/2., (data[x+3][1]+data[x+4][1])/2.))

          ellipse_center = (side1+side3)/2.
          semimajor_axis = side3 - ellipse_center
          semiminor_axis = side2 - ellipse_center

          p = (ellipse_center.elems,
               (semimajor_axis + ellipse_center).elems,
               (semiminor_axis + ellipse_center).elems)

          draw_data.append((p, default_placement.lower(),
                            default_width, default_colour, True,
                            default_filled, default_fillcolour,
                            default_offset_x, default_offset_y, None))

        return self.AddLayer(self.DrawLightweightEllipticalSpline, draw_data, map_rel,
                             visible, show_levels=show_levels,
                             selectable=False, name=name,
                             type=self.TypeEllipse, update=update)

    def DrawLightweightEllipticalSpline(self, dc, data, map_rel):
        assert map_rel

        # draw polygons on map/view
        # Draw points on map/view, using transparency if implemented.
        # No point in attempting to recover from the error below,
        # because ellipses require a GraphicsContext.
        try:
            dc = wx.GCDC(dc)
        except NotImplementedError:
            return

        (p, place, width, colour, closed,
             filled, fillcolour, x_off, y_off, pdata) = data[0]

        dc.SetPen(wx.Pen(colour, width=width))

        if filled:
            dc.SetBrush(wx.Brush(fillcolour))
        else:
            dc.SetBrush(wx.TRANSPARENT_BRUSH)

        assert closed
        assert x_off==0
        assert y_off==0

        # Ellipses can be convenintly rendered on a graphics context,
        # but not on a generic device context.
        gc = dc.GetGraphicsContext()
        for (p, place, width, colour, closed,
             filled, fillcolour, x_off, y_off, pdata) in data:

            # Gather ellipse center, major and minor axes in view
            # coordinates.
            (ellipse_center, semimajor_axis, semiminor_axis) = [
                self.ConvertGeo2View(lonlat) for lonlat in p]

            major = col(semimajor_axis) - col(ellipse_center)
            minor = col(semiminor_axis) - col(ellipse_center)
            angle = math.atan2(major.elems[1], major.elems[0])
            r_major = math.hypot(major.elems[0], major.elems[1])
            r_minor = math.hypot(minor.elems[0], minor.elems[1])

            gc.PushState()
            gc.Translate(ellipse_center[0], ellipse_center[1])
            gc.Rotate(angle)
            gc.DrawEllipse(-r_major, -r_minor, 2 * r_major, 2 * r_minor)
            gc.PopState()


    def AddPolygonLayer(self, data, map_rel=True, visible=True,
                        show_levels=None, selectable=False,
                        name='<polygon_layer>', update=True, **kwargs):
        """Add a layer of polygon data to the map.

        data         iterable of polygon tuples:
                         (<iter>[, attributes])
                     where <iter> is another iterable of (x, y) tuples and
                     attributes is a dictionary of polygon attributes:
                         placement   a placement string (view-relative only)
                         width       width of polygon edge lines
                         colour      colour of edge lines
                         close       if True closes polygon
                         filled      polygon is filled (implies closed)
                         fillcolour  fill colour
                         offset_x    X offset
                         offset_y    Y offset
                         data        polygon data object
        map_rel      points drawn relative to map if True, else view relative
        visible      True if the layer is to be immediately visible
        show_levels  list of levels at which layer is auto-shown (or None)
        selectable   True if select operates on this layer
        name         name of this layer
        kwargs       extra keyword args, layer-specific:
                         placement   placement string (view-rel only)
                         width       width of polygons in pixels
                         colour      colour of polygon edge lines
                         close       True if polygon is to be closed
                         filled      if True, fills polygon
                         fillcolour  fill colour
                         offset_x    X offset
                         offset_y    Y offset
        """

        # get global values, if required
        default_placement = kwargs.get('placement',
                                       self.DefaultPolygonPlacement)
        default_width = kwargs.get('width', self.DefaultPolygonWidth)
        default_colour = self.get_i18n_kw(kwargs, ('colour', 'color'),
                                          self.DefaultPolygonColour)
        default_close = kwargs.get('closed', self.DefaultPolygonClose)
        default_filled = kwargs.get('filled', self.DefaultPolygonFilled)
        default_fillcolour = self.get_i18n_kw(kwargs,
                                              ('fillcolour', 'fillcolor'),
                                              self.DefaultPolygonFillcolour)
        default_offset_x = kwargs.get('offset_x', self.DefaultPolygonOffsetX)
        default_offset_y = kwargs.get('offset_y', self.DefaultPolygonOffsetY)

        # create draw_data iterable
        draw_data = []
        for d in data:
            if len(d) == 2:
                (p, attributes) = d
            elif len(d) == 1:
                p = d
                attributes = {}
            else:
                msg = ('Polygon data must be iterable of tuples: '
                       '(poly, [attributes])\n'
                       'Got: %s' % str(d))
                raise Exception(msg)

            # get polygon attributes
            placement = attributes.get('placement', default_placement)
            width = attributes.get('width', default_width)
            colour = self.get_i18n_kw(attributes, ('colour', 'color'),
                                      default_colour)
            close = attributes.get('closed', default_close)
            filled = attributes.get('filled', default_filled)
            if filled:
                close = True
            fillcolour = self.get_i18n_kw(attributes,
                                          ('fillcolour', 'fillcolor'),
                                          default_fillcolour)
            offset_x = attributes.get('offset_x', default_offset_x)
            offset_y = attributes.get('offset_y', default_offset_y)
            data = attributes.get('data', None)

            # if polygon is to be filled, ensure closed
            if close:
                p = list(p)
                p.append(p[0])

            draw_data.append((p, placement.lower(), width, colour, close,
                              filled, fillcolour, offset_x, offset_y, data))

        return self.AddLayer(self.DrawPolygonLayer, draw_data, map_rel,
                             visible=visible, show_levels=show_levels,
                             selectable=selectable, name=name,
                             type=self.TypePolygon, update=update)

    def AddImageLayer(self, data, map_rel=True, visible=True,
                      show_levels=None, selectable=False,
                      name='<image_layer>', **kwargs):
        """Add a layer of images to the map.

        data         list of (lon, lat, fname[, attributes]) (map_rel)
                     or list of (x, y, fname, [attributes]) (view relative)
                     attributes is a dictionary of attribute keys:
                         placement  a placement string
                         offset_x   X offset
                         offset_y   Y offset
                         data       image data object
        map_rel      points drawn relative to map if True, else view relative
        visible      True if the layer is to be immediately visible
        show_levels  list of levels at which layer is auto-shown (or None)
        selectable   True if select operates on this layer
        name         name of this layer
        kwargs       dictionary of extra params:
                         placement  string describing placement wrt hotspot
                         offset_x   hotspot X offset in pixels
                         offset_y   hotspot Y offset in pixels

        The hotspot is placed at (lon, lat) or (x, y).  'placement' controls
        where the image is displayed relative to the hotspot.
        """

        # get global attribute values
        default_placement = kwargs.get('placement',
                                       self.DefaultImagePlacement)
        default_offset_x = kwargs.get('offset_x', self.DefaultImageOffsetX)
        default_offset_y = kwargs.get('offset_y', self.DefaultImageOffsetY)

        # define cache variables for the image data
        fname_cache = None
        bmp_cache = None
        w_cache = None
        h_cache = None          # used to optimize file access

        # load all image files, convert to bitmaps, create draw_data iterable
        draw_data = []
        for d in data:
            if len(d) == 4:
                (lon, lat, fname, attributes) = d
            elif len(d) == 3:
                (lon, lat, fname) = d
                attributes = {}
            else:
                msg = ('Points data must be iterable of tuples: '
                       '(x, y, [dict])\nGot: %s' % str(d))
                raise Exception(msg)

            placement = attributes.get('placement', default_placement)
            offset_x = attributes.get('offset_x', default_offset_x)
            offset_y = attributes.get('offset_y', default_offset_y)
            data = attributes.get('data', None)

            if fname == fname_cache:
                bmap = bmp_cache
                w = w_cache
                h = h_cache
            else:
                fname_cache = fname
                img = wx.Image(fname, wx.BITMAP_TYPE_ANY)
                bmp_cache = bmap = img.ConvertToBitmap()
                (w, h) = bmap.GetSize()
                w_cache = w
                h_cache = h
            draw_data.append((lon, lat, bmap, w, h, placement.lower(),
                              offset_x, offset_y, data))

        return self.AddLayer(self.DrawImageLayer, draw_data, map_rel,
                             visible=visible, show_levels=show_levels,
                             selectable=selectable, name=name,
                             type=self.TypeImage)

    def AddTextLayer(self, text, map_rel=True, visible=True, show_levels=None,
                     selectable=False, name='<text_layer>', update=True, **kwargs):
        """Add a text layer to the map.

        text         list of sequence of (lon, lat, text, [dict]) coordinates
        map_rel      points drawn relative to map if True, else view relative
        visible      True if the layer is to be immediately visible
        show_levels  list of levels at which layer is auto-shown
        selectable   True if select operates on this layer
        name         name of this layer
        kwargs       a dictionary of changeable text attributes
                         (placement, radius, fontname, fontsize, colour, data)
                     these supply any data missing in 'data'
        """

        if map_rel:
            default_placement = kwargs.get('placement', self.DefaultTextPlacement)
            default_radius = kwargs.get('radius', self.DefaultTextRadius)
            default_fontname = kwargs.get('fontname', self.DefaultTextFontname)
            default_fontsize = kwargs.get('fontsize', self.DefaultTextFontSize)
            default_colour = self.get_i18n_kw(kwargs, ('colour', 'color'),
                                              self.DefaultTextColour)
            default_textcolour = self.get_i18n_kw(kwargs,
                                                  ('textcolour', 'textcolor'),
                                                  self.DefaultTextTextColour)
            default_offset_x = kwargs.get('offset_x', self.DefaultTextOffsetX)
            default_offset_y = kwargs.get('offset_y', self.DefaultTextOffsetY)
            default_data = kwargs.get('data', self.DefaultTextData)
        else:
            default_placement = kwargs.get('placement', self.DefaultTextViewPlacement)
            default_radius = kwargs.get('radius', self.DefaultTextViewRadius)
            default_fontname = kwargs.get('fontname', self.DefaultTextViewFontname)
            default_fontsize = kwargs.get('fontsize', self.DefaultTextViewFontSize)
            default_colour = self.get_i18n_kw(kwargs, ('colour', 'color'),
                                              self.DefaultTextViewColour)
            default_textcolour = self.get_i18n_kw(kwargs,
                                                  ('textcolour', 'textcolor'),
                                                  self.DefaultTextViewTextColour)
            default_offset_x = kwargs.get('offset_x', self.DefaultTextViewOffsetX)
            default_offset_y = kwargs.get('offset_y', self.DefaultTextViewOffsetY)
            default_data = kwargs.get('data', self.DefaultTextData)

        # create data iterable ready for drawing
        draw_data = []
        for t in text:
            if len(t) == 4:
                (lon, lat, tdata, attributes) = t
            elif len(t) == 3:
                (lon, lat, tdata) = t
                attributes = {}
            else:
                msg = ('Text data must be iterable of tuples: '
                       '(lon, lat, text, [dict])\n'
                       'Got: %s' % str(t))
                raise Exception(msg)

            # plug in any required defaults
            placement = attributes.get('placement', default_placement)
            radius = attributes.get('radius', default_radius)
            fontname = attributes.get('fontname', default_fontname)
            fontsize = attributes.get('fontsize', default_fontsize)
            colour = self.get_i18n_kw(attributes, ('colour', 'color'),
                                      default_colour)
            textcolour = self.get_i18n_kw(attributes,
                                          ('textcolour', 'textcolor'),
                                          default_textcolour)
            offset_x = attributes.get('offset_x', default_offset_x)
            offset_y = attributes.get('offset_y', default_offset_y)
            data = attributes.get('data', default_data)

            draw_data.append((lon, lat, tdata, placement.lower(),
                              radius, colour, textcolour, fontname, fontsize,
                              offset_x, offset_y, data))

        return self.AddLayer(self.DrawTextLayer, draw_data, map_rel,
                             visible=visible, show_levels=show_levels,
                             selectable=selectable, name=name,
                             type=self.TypeText, update=update)

    def AddLayer(self, render, data, map_rel, visible, show_levels,
                 selectable, name, type, update=True):
        """Add a generic layer to the system.

        render       the function used to render the layer
        data         actual layer data (depends on layer type)
        map_rel      True if points are map relative, else view relative
        visible      True if layer is to be immediately shown, else False
        show_levels  list of levels at which to auto-show the layer
        selectable   True if select operates on this layer
        name         name for this layer
        type         flag for layer 'type'

        Returns unique ID of the new layer.
        """

        # get layer ID
        id = self.next_layer_id
        self.next_layer_id += 1

        # prepare the show_level value
        if show_levels is None:
            show_levels = range(self.min_level, self.max_level + 1)

        # create layer, add unique ID to Z order list
        l = _Layer(id=id, painter=render, data=data, map_rel=map_rel,
                   visible=visible, show_levels=show_levels,
                   selectable=selectable, name=name, type=type)

        self.layer_mapping[id] = l
        self.layer_z_order.append(id)

        # force display of new layer if it's visible
        if visible and update:
            self.Update()

        return id

    ######
    # Layer manipulation routines.
    ######

    def ShowLayer(self, id):
        """Show a layer.

        id  the layer id
        """

        self.layer_mapping[id].visible = True
        self.Update()

    def HideLayer(self, id):
        """Hide a layer.

        id  the layer id
        """

        self.layer_mapping[id].visible = False
        self.Update()

    def DeleteLayer(self, id, update=True):
        """Delete a layer.

        id  the layer id
        """

        # just in case we got None
        if id:
            # see if what we are about to remove might be visible
            visible = self.layer_mapping[id].visible
            del self.layer_mapping[id]
            self.layer_z_order.remove(id)

            # if layer was visible, refresh display
            if visible and update:
                self.Update()

    def SetLayerShowLevels(self, id, show_levels=None):
        """Update the show_levels list for a layer.

        id           ID of the layer we are going to update
        show_levels  new layer show list
        """

        # just in case we got None
        if id:
            layer = self.layer_mapping[id]

            # prepare the show_level value
            if show_levels is None:
                show_levels = range(self.min_level, self.max_level + 1)[:]

            layer.show_levels = show_levels

            # if layer was visible, refresh display
            if visible:
                self.Update()

    def SetLayerSelectable(self, id, selectable=False):
        """Update the .selectable attribute for a layer.

        id          ID of the layer we are going to update
        selectable  new .selectable attribute value (True or False)
        """

        # just in case we got None
        if id:
            layer = self.layer_mapping[id]
            layer.selectable = selectable

    ######
    # Play with layers Z order
    ######

    def PushLayerToBack(self, id):
        """Make layer specified be drawn at back of Z order.

        id  ID of the layer to push to the back
        """

        self.layer_z_order.remove(id)
        self.layer_z_order.insert(0, id)
        self.Update()

    def PopLayerToFront(self, id):
        """Make layer specified be drawn at front of Z order.

        id  ID of the layer to pop to the front
        """

        self.layer_z_order.remove(id)
        self.layer_z_order.append(id)
        self.Update()

    def PlaceLayerBelowLayer(self, id, top_id):
        """Place a layer so it will be drawn behind another layer.

        id      ID of layer to place underneath 'top_id'
        top_id  ID of layer to be drawn *above* 'id'
        """

        self.layer_z_order.remove(id)
        i = self.layer_z_order.index(top_id)
        self.layer_z_order.insert(i, id)
        self.Update()

    ######
    # Layer drawing routines
    ######

    def LightweightDrawPointLayer2(self, dc, data, map_rel):
        """Draw a points layer.

        dc       the device context to draw on
        data     an iterable of point tuples:
                     (x, y, place, radius, colour, x_off, y_off, pdata)
        map_rel  points relative to map if True, MUST BE TRUE for lightweight
        Assumes all points are the same colour, saving 100's of ms.

        In contrast to LightweightDrawPointLayer, this function draws
        rectangles or points (rather than circles) for performance reasons.
        """
        assert map_rel is True
        if len(data)==0: return
        (lon, lat, place,
                 radius, colour, x_off, y_off, pdata) = data[0]

        # draw points on map/view
        if map_rel:
            # GCDC device context permits antialiasing and transparent colors.
            # But, signficant time savings by not allowing these features
            # It's not clear that we actually want or use them anyway
            #dc = wx.GCDC(dc)            # allow transparent colours
            dc.SetPen(wx.Pen(colour))
            dc.SetBrush(wx.Brush(colour))
            points = []
            rectangles = []
            if radius:
                diameter = 2 * radius
            for (lon, lat, place,
                 radius, colour, x_off, y_off, pdata) in data:
                pt = self.ConvertGeo2ViewMasked((lon, lat))
                if pt:
                    (x, y) = pt
                    if radius:
                        rectangles.append(
                            (x + x_off - radius, y + y_off - radius,
                             diameter, diameter))
                    else:
                        points.append((x + x_off, y + y_off))
            if len(points):
                dc.DrawPointList(points)
            if len(rectangles):
                dc.DrawRectangleList(rectangles)

    def LightweightDrawPointLayer(self, dc, data, map_rel):
        """Draw a points layer.

        dc       the device context to draw on
        data     an iterable of point tuples:
                     (x, y, place, radius, colour, x_off, y_off, pdata)
        map_rel  points relative to map if True, MUST BE TRUE for lightweight
        Assumes all points are the same colour, saving 100's of ms.
        """
        assert map_rel is True
        if len(data)==0: return
        (lon, lat, place,
                 radius, colour, x_off, y_off, pdata) = data[0]

        # draw points on map/view
        if map_rel:
            # GCDC device context permits antialiasing and transparent colors.
            # But, signficant time savings by not allowing these features
            # It's not clear that we actually want or use them anyway
            #dc = wx.GCDC(dc)            # allow transparent colours
            dc.SetPen(wx.Pen(colour))
            dc.SetBrush(wx.Brush(colour))
            for (lon, lat, place,
                 radius, colour, x_off, y_off, pdata) in data:
                pt = self.ConvertGeo2ViewMasked((lon, lat))
                if pt:
                    (x, y) = pt
                    if radius:
                        dc.DrawCircle(x + x_off, y + y_off, radius)

    def DrawPointLayer(self, dc, data, map_rel):
        """Draw a points layer.

        dc       the device context to draw on
        data     an iterable of point tuples:
                     (x, y, place, radius, colour, x_off, y_off, pdata)
        map_rel  points relative to map if True, else relative to view
        """

        # draw points on map/view
        if map_rel:
            dc = wx.GCDC(dc)            # allow transparent colours
            for (lon, lat, place,
                 radius, colour, x_off, y_off, pdata) in data:
                pt = self.ConvertGeo2ViewMasked((lon, lat))
                if pt:
                    dc.SetPen(wx.Pen(colour))
                    dc.SetBrush(wx.Brush(colour))
                    (x, y) = pt
                    if radius:
                        dc.DrawCircle(x + x_off, y + y_off, radius)
        else:
            (dc_w, dc_h) = dc.GetSize()
            dc_w2 = dc_w / 2
            dc_h2 = dc_h / 2
            dc_h -= 1
            dc_w -= 1
            dc = wx.GCDC(dc)            # allow transparent colours
            for (x, y, place, radius, colour, x_off, y_off, pdata) in data:
                dc.SetPen(wx.Pen(colour))
                dc.SetBrush(wx.Brush(colour))
                exec(self.point_view_placement[place])
                if radius:
                    dc.DrawCircle(x, y, radius)

    def DrawPolygonLayer(self, dc, data, map_rel):
        """Draw a polygon layer.

        dc       the device context to draw on
        data     an iterable of polygon tuples:
                     (p, placement, width, colour, closed,
                      filled, fillcolour, offset_x, offset_y, data)
                 where p is an iterable of points: (x, y)
        map_rel  points relative to map if True, else relative to view
        """

        # draw polygons on map/view
        polygons = []
        lines = []
        pens = []
        brushes = []
        if map_rel:
            # Draw points on map/view, using transparency if implemented.
            try:
                dc = wx.GCDC(dc)
            except NotImplementedError:
                pass
            for (p, place, width, colour, closed,
                 filled, fillcolour, x_off, y_off, pdata) in data:
                # gather all polygon points as view coords
                p_lonlat = []
                for lonlat in p:
                    (x, y) = self.ConvertGeo2View(lonlat)
                    if closed:
                        p_lonlat.append((x + x_off, y + y_off))
                    else:
                        p_lonlat.extend((x + x_off, y + y_off))

                pens.append(wx.Pen(colour, width=width))

                if filled:
                    brushes.append(wx.Brush(fillcolour))
                else:
                    brushes.append(wx.TRANSPARENT_BRUSH)

                if closed:
                    polygons.append(p_lonlat)
                else:
                    lines.append(p_lonlat)
        else:
            (dc_w, dc_h) = dc.GetSize()
            dc_w2 = dc_w / 2
            dc_h2 = dc_h / 2
            dc_w -= 1
            dc_h -= 1
            dc = wx.GCDC(dc)            # allow transparent colours
            for (p, place, width, colour, closed,
                 filled, fillcolour, x_off, y_off, pdata) in data:
                # fetch the exec code, don't refetch for each point in polygon
                place_exec = self.poly_view_placement[place]
                pp = []
                for (x, y) in p:
                    exec(place_exec)
                    if closed:
                        pp.append((x, y))
                    else:
                        pp.extend((x, y))

                pens.append(wx.Pen(colour, width=width))
                if filled:
                    brushes.append(wx.Brush(fillcolour))
                else:
                    brushes.append(wx.TRANSPARENT_BRUSH)

                if closed:
                    polygons.append(pp)
                else:
                    lines.append(pp)
        if len(lines):
            dc.DrawLineList(lines, pens=pens)
        if len(polygons):
            dc.DrawPolygonList(polygons, pens=pens, brushes=brushes)

    def DrawImageLayer(self, dc, images, map_rel):
        """Draw an image Layer on the view.

        dc       the device context to draw on
        images   a sequence of image tuple sequences
                   (x,y,bmap,w,h,placement,offset_x,offset_y,idata)
        map_rel  points relative to map if True, else relative to view
        """

        # draw images on map/view
        if map_rel:
            for (lon, lat, bmap, w, h, place, x_off, y_off, idata) in images:
                w2 = w / 2
                h2 = h / 2
                pt = self.ConvertGeo2ViewMasked((lon, lat))
                if pt:
                    (x, y) = pt
                    exec(self.image_map_placement[place])
                    dc.DrawBitmap(bmap, x, y, False)
        else:
            (dc_w, dc_h) = dc.GetSize()
            dc_w2 = dc_w / 2
            dc_h2 = dc_h / 2
            for (x, y, bmap, w, h, place, x_off, y_off, idata) in images:
                w2 = w / 2
                h2 = h / 2
                exec(self.image_view_placement[place])
                dc.DrawBitmap(bmap, x, y, False)

    def DrawTextLayer(self, dc, text, map_rel):
        """Draw a text Layer on the view.

        dc       the device context to draw on
        text     a sequence of tuples:
                     (lon, lat, tdata, placement, radius, colour, fontname,
                      fontsize, offset_x, offset_y, tdata)
        map_rel  points relative to map if True, else relative to view
        """

        if text is None:
            return

        # draw text on map/view
        if map_rel:
            dc = wx.GCDC(dc)            # allow transparent colours
            for t in text:
                (lon, lat, tdata, place, radius, colour, textcolour,
                     fontname, fontsize, x_off, y_off, data) = t

                # convert geo position to view (returns None if off-view)
                pt = self.ConvertGeo2ViewMasked((lon, lat))
                if pt:
                    (x, y) = pt

                    # set font characteristics
                    dc.SetPen(wx.Pen(colour))
                    dc.SetBrush(wx.Brush(colour))
                    dc.SetTextForeground(colour)
                    font = wx.Font(fontsize, wx.SWISS, wx.NORMAL, wx.NORMAL,
                                   False, fontname)
                    dc.SetFont(font)

                    # draw hotpoint circle
                    if radius:
                        dc.DrawCircle(x, y, radius)

                    # place the text relative to hotpoint
                    (w, h, _, _) = dc.GetFullTextExtent(tdata)
                    w2 = w / 2
                    h2 = h / 2
                    exec(self.text_map_placement[place])
                    dc.SetTextForeground(textcolour)
                    dc.DrawText(tdata, x, y)
        else:
            # we need the size of the DC
            (dc_w, dc_h) = dc.GetSize()
            dc_w2 = dc_w / 2
            dc_h2 = dc_h / 2
            dc_w -= 1
            dc_h -= 1
            dc = wx.GCDC(dc)            # allow transparent colours
            for t in text:
                # for each text element, get unpacked data
                (x, y, tdata, place, radius, colour, textcolour,
                     fontname, fontsize, x_off, y_off, data) = t

                # set font characteristics
                dc.SetPen(wx.Pen(colour))
                dc.SetBrush(wx.Brush(colour))
                dc.SetTextForeground(colour)
                font = wx.Font(fontsize, wx.SWISS, wx.NORMAL, wx.NORMAL,
                               False, fontname)
                dc.SetFont(font)

                # draw hotpoint circle - do placement with x & y zero
                (save_x, save_y) = (x, y)
                (w, h, w2, h2, x, y) = (0, 0, 0, 0, 0, 0)
                exec(self.text_view_placement[place])
                if radius:
                    dc.DrawCircle(x, y, radius)
                (x, y) = (save_x, save_y)

                # place the text relative to hotpoint
                (w, h, _, _) = dc.GetFullTextExtent(tdata)  # size of text
                w2 = w / 2
                h2 = h / 2
                exec(self.text_view_placement[place])
                dc.SetTextForeground(textcolour)
                dc.DrawText(tdata, x, y)

    ######
    # Positioning methods
    ######

    def GotoPosition(self, posn):
        """Set view to centre on a position in the current level.

        posn  a tuple (lon,lat) to centre view on
        """
        (lon, lat) = posn

        x = (lon - self.map_llon) * self.ppd_x
        y = (self.map_tlat - lat) * self.ppd_y
        self.view_offset_x = x - self.view_width / 2
        self.view_offset_y = y - self.view_height / 2

        # set the left/right/top/bottom lon/lat extents
        self.RecalcViewLonLatLimits()

        self.Update()

    def GotoLevelAndPosition(self, level, posn):
        """Goto a map level and set view to centre on a position.

        level  the map level to use
        posn   a tuple (lon,lat) to centre view on

        Does nothing if we can't use desired level.
        """

        if self.ZoomToLevel(level):
            self.GotoPosition(posn)

    def ZoomToArea(self, posn, size):
        """Set view to level and position to view an area.

        posn  a tuple (lon,lat) to centre view on
        size  a tuple (width,height) of area in degrees

        Centre an area and zoom to view such that the area will fill
        approximately 50% of width or height, whichever is greater.

        Use the ppd_x and ppd_y values in the level 'tiles.info' file.
        """
        # unpack area width/height (degrees)
        (awidth, aheight) = size

        # step through levels (smallest first) and check view size (degrees)
        for l in self.tiles.levels:
            level = l
            (_, _, ppd_x, ppd_y) = self.tiles.getInfo(l)
            view_deg_width = self.view_width / ppd_x
            view_deg_height = self.view_height / ppd_y

            # if area >= 50% of view, finished
            if awidth >= view_deg_width / 2 or aheight >= view_deg_height / 2:
                break

        self.GotoLevelAndPosition(level, posn)

    ######
    # Convert between geo and view coordinates
    ######

    def ConvertGeo2View(self, lonlat):
        """Convert a geo (lon+lat) position to view pixel coords.

        lonlat  (longitude, latitude) of point

        Return screen pixels coordinates of the point (x,y).
        """

        (lon, lat) = lonlat

        return ((lon - self.view_llon) * self.ppd_x,
                (self.view_tlat - lat) * self.ppd_y)

    def ConvertGeo2ViewMasked(self, lonlat):
        """Convert a geo (lon+lat) position to view pixel coords.

        lonlat  (longitude, latitude) of point

        Return screen pixels coordinates of the point (x,y) or None
        if point is off-view.
        """

        (lon, lat) = lonlat

        if (self.view_llon <= lon <= self.view_rlon and
                self.view_blat <= lat <= self.view_tlat):
            return self.ConvertGeo2View(lonlat)

        return None

    def ConvertView2Geo(self, xy):
        """Convert an x,y view position to geo lon+lat.

        xy  tuple of view X & Y coordinate (pixels)

        Return a tuple (lon, lat) - geo coordinates of the point.
        """

        (x, y) = xy

        # x_pix is from left map edge, y_pix from top map edge
        x_pix = x + self.view_offset_x
        y_pix = y + self.view_offset_y

        lon = self.map_llon + x_pix / self.ppd_x
        lat = self.map_tlat - y_pix / self.ppd_y

        return (lon, lat)

    ######
    # GUI stuff
    ######

    def OnMove(self, event):
        """Handle a mouse move (map drag or rectangle select).

        event  the mouse move event

        If SHIFT key is down, do rectangle select.
        Otherwise pan the map if we are dragging.
        """

        # for windows, set focus onto pyslip window
        # linux seems to do this automatically
        if sys.platform == 'win32' and self.FindFocus() != self:
            self.SetFocus()

        # get current mouse position
        (x, y) = event.GetPositionTuple() if WX3 else event.GetPosition()

        self.RaiseMousePositionEvent((x, y))

        if event.Dragging() and event.LeftIsDown():
            # are we doing box select?
            if self.is_box_select:
                # set select box point 2 at mouse position
                (self.sbox_w, self.sbox_h) = (x - self.sbox_1_x,
                                              y - self.sbox_1_y)
            elif not self.last_drag_x is None:
                # no, just a map drag
                self.was_dragging = True
                dx = self.last_drag_x - x
                dy = self.last_drag_y - y

                # move the map in the view
                self.view_offset_x += dx
                self.view_offset_y += dy

                # adjust remembered X,Y
                self.last_drag_x = x
                self.last_drag_y = y

                self.RecalcViewLonLatLimits()

            # redraw client area
            self.Update()

    def OnLeftDown(self, event):
        """Left mouse button down. Prepare for possible drag."""

        click_posn = event.GetPositionTuple() if WX3 else event.GetPosition()

        if event.ShiftDown():
            self.is_box_select = True
            self.SetCursor(wx.StockCursor(wx.CURSOR_CROSS))
            (self.sbox_w, self.sbox_h) = (0, 0)
            (self.sbox_1_x, self.sbox_1_y) = click_posn
        else:
            self.is_box_select = False
            self.SetCursor(wx.StockCursor(wx.CURSOR_HAND))
            (self.last_drag_x, self.last_drag_y) = click_posn
        event.Skip()

    def OnLeftUp(self, event):
        """Left mouse button up.

        Note that when we iterate through the layer_z_order list we must
        iterate on a *copy* as the user select process can modify
        self.layer_z_order.
        """

        self.last_drag_x = self.last_drag_y = None

        if self.ignore_next_up:
            self.ignore_next_up = False
            return

        self.SetCursor(wx.StockCursor(wx.CURSOR_DEFAULT))

        # we need a repaint to remove any selection box, but NOT YET!
        delayed_paint = self.sbox_1_x       # True if box select active

        # if any layers interested, inform of possible select
        if not self.was_dragging:
            if self.is_box_select:
                # possible box selection
                ll_corner_v = (self.sbox_1_x, self.sbox_1_y)
                tr_corner_v = (self.sbox_1_x + self.sbox_w,
                               self.sbox_1_y + self.sbox_h)
                ll_corner_m = self.ConvertView2Geo(ll_corner_v)
                tr_corner_m = self.ConvertView2Geo(tr_corner_v)

                # check each layer for a box select event
                # we work on a copy as user response could change order
                for id in self.layer_z_order[:]:
                    l = self.layer_mapping[id]
                    # if layer visible and selectable
                    if l.selectable and l.visible:
                        if l.map_rel:
                            # map-relative, get all points selected (if any)
                            p_data = self.layerBSelHandler[l.type](l,
                                                                  ll_corner_m,
                                                                  tr_corner_m)
                        else:
                            # view-relative
                            p_data = self.layerBSelHandler[l.type](l,
                                                                  ll_corner_v,
                                                                  tr_corner_v)
                        self.RaiseSelectEvent(EventBoxSelect, l, p_data)

                        # user code possibly updated screen
                        delayed_paint = True
                self.is_box_select = False
            else:
                # possible point selection
                clickpt_v = event.GetPositionTuple() if WX3 else event.GetPosition()
                clickpt_m = self.ConvertView2Geo(clickpt_v)
                # check each layer for a point select callback
                # we work on a copy as user callback could change order
                for id in self.layer_z_order[:]:
                    l = self.layer_mapping[id]
                    # if layer visible and selectable
                    if l.selectable and l.visible and \
                        (l.type in self.layerPSelHandler):
                        if l.map_rel:
                            p_data = self.layerPSelHandler[l.type](l,
                                                                   clickpt_m)
                        else:
                            p_data = self.layerPSelHandler[l.type](l,
                                                                   clickpt_v)
                        self.RaiseSelectEvent(EventPointSelect, l, p_data,
                                              vposn=clickpt_v,
                                              mposn=clickpt_m)

                        # user code possibly updated screen
                        delayed_paint = True

        # turn off drag
        self.was_dragging = False

        # turn off box selection mechanism
        self.is_box_select = False
        self.sbox_1_x = self.sbox_1_y = None

        # force PAINT event if required
        if delayed_paint:
            self.Update()

    def OnLeftDClick(self, event):
        """Left mouse button double-click.

        Zoom in (if possible).
        Zoom out (if possible) if shift key is down.
        """

        # ignore next Left UP event
        self.ignore_next_up = True

        # TODO: should ignore double-click off the map, but within view
        # a possible workaround is to limit minimum view level

        # get view coords of mouse double click, want same centre afterwards
        xy = event.GetPositionTuple() if WX3 else event.GetPosition()

        if event.ShiftDown():
            # zoom out if shift key also down
            if self.ZoomToLevel(self.level - 1):
                self.ZoomOut(xy)
        else:
            # zoom in
            if self.ZoomToLevel(self.level + 1):
                self.ZoomIn(xy)

        # Raise position event to update the status text.
        self.RaiseMousePositionEvent(xy)

    def OnMiddleDown(self, event):
        """Middle mouse button down.  Do nothing in this version."""

        pass

    def OnMiddleUp(self, event):
        """Middle mouse button up.  Do nothing in this version."""

        pass

    def OnRightDown(self, event):
        """Right mouse button down. Prepare for right select (no drag)."""

        click_posn = event.GetPositionTuple() if WX3 else event.GetPosition()

        if event.ShiftDown():
            self.is_box_select = True
            self.SetCursor(wx.StockCursor(wx.CURSOR_CROSS))
            (self.sbox_w, self.sbox_h) = (0, 0)
            (self.sbox_1_x, self.sbox_1_y) = click_posn
        event.Skip()

    def OnRightUp(self, event):
        """Right mouse button up.

        Note that when we iterate through the layer_z_order list we must
        iterate on a *copy* as the user select process can modify
        self.layer_z_order.
        """

        if self.ignore_next_right_up:
            self.ignore_next_right_up = False
            return

        self.SetCursor(wx.StockCursor(wx.CURSOR_DEFAULT))

        # we need a repaint to remove any selection box, but NOT YET!
        delayed_paint = self.sbox_1_x       # True if box select active

        # if any layers interested, inform of possible select
        if self.is_box_select:
            # possible box selection
            ll_corner_v = (self.sbox_1_x, self.sbox_1_y)
            tr_corner_v = (self.sbox_1_x + self.sbox_w,
                           self.sbox_1_y + self.sbox_h)
            ll_corner_m = self.ConvertView2Geo(ll_corner_v)
            tr_corner_m = self.ConvertView2Geo(tr_corner_v)

            # check each layer for a box select event
            # we work on a copy as user response could change order
            for id in self.layer_z_order[:]:
                l = self.layer_mapping[id]
                if l.selectable and l.visible:   # and l.event_box_select:
                    if l.map_rel:
                        # map-relative, get all points selected (if any)
                        pts = self.layerBSelHandler[l.type](l, ll_corner_m,
                                                            tr_corner_m)
                    else:
                        # view-relative
                        pts = self.layerBSelHandler[l.type](l, ll_corner_v,
                                                            tr_corner_v)
                    self.RaiseSelectEvent(EventRightBoxSelect, l, pts)

                    # user code possibly updated screen
                    delayed_paint = True
            self.is_box_select = False
        else:
            # possible point selection
            clickpt_v = event.GetPositionTuple() if WX3 else event.GetPosition()
            clickpt_m = self.ConvertView2Geo(clickpt_v)
            # check each layer for a point select callback
            # we work on a copy as user callback could change order
            for id in self.layer_z_order[:]:
                l = self.layer_mapping[id]
                # if layer visible, selectable and there is a callback
                if l.selectable and l.visible:
                    if l.map_rel:
                        pt = self.layerPSelHandler[l.type](l, clickpt_m)
                    else:
                        pt = self.layerPSelHandler[l.type](l, clickpt_v)
                    self.RaiseSelectEvent(EventRightPointSelect, l, pt,
                                          mposn=clickpt_m,
                                          vposn=clickpt_v)

                    # user code possibly updated screen
                    delayed_paint = True

        # turn off box selection mechanism
        self.is_box_select = False
        self.sbox_1_x = self.sbox_1_y = None

        # force PAINT event to remove selection box (if required)
        if delayed_paint:
            self.Update()

    def OnRightDClick(self, event):
        """Right mouse button double-click."""

        # ignore next RIGHT UP event
        self.ignore_next_right_up = True

    def OnMouseWheel(self, event):
        """Mouse wheel event."""

        # get current mouse position
        mouse_x, mouse_y = event.GetPositionTuple() if WX3 else event.GetPosition()
        mouse_latlon = self.ConvertView2Geo((mouse_x, mouse_y))
        # get center of view in map coords
        x, y = self.view_width/2, self.view_height/2
        # determine which way to zoom, & *can* we zoom?
        if event.GetWheelRotation() > 0:
            if self.ZoomToLevel(self.level + 1):
                self.ZoomIn((x, y), update=False)
        else:
            if self.ZoomToLevel(self.level - 1):
                self.ZoomOut((x, y), update=False)

        # Translate the map so that the point under the mouse cursor is the same
        # after zooming in/out as before
        new_mouse_x, new_mouse_y = self.ConvertGeo2View(mouse_latlon)
        new_center = (x + (new_mouse_x - mouse_x),
                      y + (new_mouse_y - mouse_y))
        self.GotoPosition(self.ConvertView2Geo(new_center))

        # Raise position event to update the status text.
        self.RaiseMousePositionEvent(event.GetPositionTuple() if WX3 else event.GetPosition())

    ######
    # Method that overrides _BufferedCanvas.Draw() method.
    # This code does the actual drawing of tiles, layers, etc.
    ######

    def Draw(self, dc):
        """Do actual map tile and layers drawing.
        Overrides the _BufferedCanvas.draw() method.

        dc  device context to draw on

        The idea is to create 3 data structures that define the tiles
        to be drawn and where to draw them:
            row_list  list (left -> right) of tile rows
            col_list  list (left -> right) of tile columns
            posn      position at which to draw first (top-left) tile
        We will need this when we go to the 'wrap-around' feature.
        """

        # figure out how to draw tiles
        if False:# self.view_offset_x < 0: # NKS No wrapping or hard boundaries
            # View > Map in X - centre in X direction
            if self.EW_wrap:
                tile_margin = ((-self.view_offset_x + self.tile_size_x - 1) //
                               self.tile_size_x)
                col_start = (self.tiles.num_tiles_x -
                             tile_margin % self.tiles.num_tiles_x)
                col_list = []
                for i in range(2 * tile_margin + self.tiles.num_tiles_x):
                    ii = (i + col_start) % self.tiles.num_tiles_x
                    col_list.append(ii)
                x_pix = (self.view_offset_x
                         + (tile_margin - 1) * self.tile_size_x)
            else:
                col_list = range(0, self.tiles.num_tiles_x)
                x_pix = -self.view_offset_x
        else:
            # Map > View - determine layout in X direction
            x_offset = self.view_offset_x + self.move_dx
            import math # NKS allow negative tile coordinates
            start_x_tile = int(math.floor(x_offset / self.tile_size_x))
            stop_x_tile = ((x_offset + self.view_width + self.tile_size_x - 1)
                           / self.tile_size_x)
            stop_x_tile = int(stop_x_tile)
            col_list = range(start_x_tile, stop_x_tile)
            x_pix = start_x_tile * self.tile_size_y - x_offset

        if False:#self.view_offset_y < 0: # NKS No wrapping or hard boundaries
            # View > Map in Y - centre in Y direction
            if self.NS_wrap:
                tile_margin = ((-self.view_offset_y + self.tile_size_y - 1)
                               // self.tile_size_y)
                row_start = (self.tiles.num_tiles_y
                             - tile_margin % self.tiles.num_tiles_y)
                row_list = []
                for i in range(2 * tile_margin + self.tiles.num_tiles_y):
                    ii = (i + row_start) % self.tiles.num_tiles_y
                    row_list.append(ii)
                y_pix_start = self.view_offset_y + \
                                  (tile_margin - 1) * self.tile_size_y
            else:
                row_list = range(0, self.tiles.num_tiles_y)
                y_pix_start = -self.view_offset_y
        else:
            y_offset = self.view_offset_y + self.move_dy
            start_y_tile = int(math.floor(y_offset / self.tile_size_y))
            stop_y_tile = ((y_offset + self.view_height
                            + self.tile_size_y - 1) / self.tile_size_y)
            stop_y_tile = int(stop_y_tile)
            row_list = range(start_y_tile, stop_y_tile)
            y_pix_start = start_y_tile * self.tile_size_y - y_offset

        # start pasting tiles onto the view
        for x in col_list:
            y_pix = y_pix_start
            for y in row_list:
                dc.DrawBitmap(self.tiles.GetTile(x, y), x_pix, y_pix, False)
                y_pix += self.tile_size_y
            x_pix += self.tile_size_x

        # draw layers
        for id in self.layer_z_order:
            l = self.layer_mapping[id]
            if l.visible and self.level in l.show_levels:
                l.painter(dc, l.data, map_rel=l.map_rel)

        # draw selection rectangle, if any
        if self.sbox_1_x:
            penclr = wx.Colour(0, 0, 255)
            dc.SetPen(wx.Pen(penclr, width=1))
            brushclr = wx.Colour(0, 0, 0)
            dc.SetBrush(wx.Brush(brushclr, style=wx.TRANSPARENT))
            dc.DrawRectangle(self.sbox_1_x, self.sbox_1_y,
                             self.sbox_w, self.sbox_h)

    ######
    # Miscellaneous
    ######

    def ResizeCallback(self, event=None):
        """Handle a window resize.

        event  that caused the resize, may be None (not used)

        Handle all possible states of view and map:
           . new view entirely within map
           . map smaller than view (just centre map)

        Set up view state.
        """

        # get new size of the view
        (self.view_width, self.view_height) = self.GetClientSizeTuple() if WX3 else self.GetClientSize()

        # if map > view in X axis
        if self.map_width > self.view_width:
            self.max_x_offset = self.map_width - self.view_width
            # NKS allow background to show
            # do nothing unless background is showing
            # if map left edge right of view edge
            #if self.view_offset_x < 0:
            #    # move view to hide background at left
            #    self.view_offset_x = 0
            #elif self.view_offset_x + self.view_width > self.map_width:
            #    # move view to hide background at right
            #    self.view_offset_x = self.map_width - self.view_width
        else:
            # else view >= map - centre map in X direction
            self.max_x_offset = self.map_width - self.view_width

        # if map > view in Y axis
        if self.map_height > self.view_height:
            self.max_y_offset = self.map_height - self.view_height
            # NKS allow background to show
            # do nothing unless background is showing
            # if map top edge below view edge
            #if self.view_offset_y < 0:
            #    # move view to hide background at top
            #    self.view_offset_y = 0
            #elif self.view_offset_y + self.view_height > self.map_height:
            #    # move view to hide background at bottom
            #    self.view_offset_y = self.map_height - self.view_height
        else:
            # else view >= map - centre map in Y direction
            self.max_y_offset = self.map_height - self.view_height

        # set the left/right/top/bottom lon/lat extents
        self.RecalcViewLonLatLimits()

    def RecalcViewLonLatLimits(self):
        """Recalculate the view lon/lat extent values.

        Assumes only the .view_offset_? and .ppd_? values have been set.
        """

        self.view_llon = self.map_llon + self.view_offset_x / self.ppd_x
        self.view_rlon = self.view_llon + self.view_width / self.ppd_x

        self.view_tlat = self.map_tlat - self.view_offset_y / self.ppd_y
        self.view_blat = self.view_tlat - self.view_height / self.ppd_y

    def ZoomToLevel(self, level):
        """Use a new tile level.

        level  the new tile level to use.

        Returns True if all went well.
        Maintain centre of map, if possible.
        """

        if self.min_level <= level <= self.max_level:
            map_extent = self.tiles.UseLevel(level)
            if map_extent:
                self.level = level
                (self.map_width, self.map_height,
                     self.ppd_x, self.ppd_y) = map_extent
                (self.map_llon, self.map_rlon,
                     self.map_blat, self.map_tlat) = self.tiles.extent

                # do level change callback
                self.RaiseLevelChangeEvent(level)

                return True

        return False

    def GetMapCoordsFromView(self, posn):
        """Convert view pixel coordinates to map coordinates.

        posn  is a tuple (x, y) of view pixel coordinates

        Returns (x, y) map pixel coordinates.
        """

        # unpack the position
        (view_x, view_y) = posn

        # calculate map coords
        map_x = view_x + self.view_offset_x
        map_y = view_y + self.view_offset_y

        return (map_x, map_y)

    ######
    # Select helpers - get objects that were selected
    ######

    def GetNearestPointInLayer(self, layer, pt):
        """Determine if clicked location selects a point in layer data.

        layer  layer object we are looking in
        pt     click geo location (lon, lat) or screen (x, y)

        Return None (no selection) or ((x, y), data) of closest point.
        """

# TODO: speed this up?  Do we need to??
# http://en.wikipedia.org/wiki/Kd-tree
# would need to create kd-tree in AddLayer()

        (ptx, pty) = pt
        res = None
        dist = 9999999.0        # more than possible
        if layer.map_rel:
            for p in layer.data:
                (x, y, _, _, _, _, _, data) = p
                d = (x - ptx) * (x - ptx) + (y - pty) * (y - pty)
                if d < dist:
                    dist = d
                    res = ((x, y), data)

            if dist <= layer.delta:
                return res
        else:
            for p in layer.data:
                dc = wx.BufferedPaintDC(self, self.buffer)
                (dc_w, dc_h) = dc.GetSize()
                dc_w2 = dc_w / 2
                dc_h2 = dc_h / 2
                dc_h -= 1
                dc_w -= 1
                (x, y, place, _, _, x_off, y_off, pdata) = p
                exec(self.point_view_placement[place])
                d = (x - ptx) * (x - ptx) + (y - pty) * (y - pty)
                if d < dist:
                    dist = d
                    res = ((x, y), pdata)

            if dist <= layer.delta:
                return res

        return None

    def GetBoxSelPointsInLayer(self, layer, p1, p2):
        """Get list of points inside box.

        layer  reference to layer object we are working on
        p1     one corner point of selection box
        p2     opposite corner point of selection box

        We have to figure out which corner is which.

        Return a list of (lon, lat) of points inside box.
        Return None (no selection) or list [((lon, lat), data), ...]
        of points inside the selection box.
        """

# TODO: speed this up?  Do we need to??
        # get canonical box limits
        (p1x, p1y) = p1
        (p2x, p2y) = p2
        lx = min(p1x, p2x)      # left x coord
        rx = max(p1x, p2x)
        ty = max(p1y, p2y)      # top y coord
        by = min(p1y, p2y)

        # get a list of points inside the selection box
        result = []

        if layer.map_rel:
            for p in layer.data:
                (x, y, _, _, _, _, _, pdata) = p
                if lx <= x <= rx and by <= y <= ty:
                    result.append(((x, y), pdata))
        else:
            for p in layer.data:
                dc = wx.BufferedPaintDC(self, self.buffer)
                (dc_w, dc_h) = dc.GetSize()
                dc_w2 = dc_w / 2
                dc_h2 = dc_h / 2
                dc_h -= 1
                dc_w -= 1
                (x, y, place, _, _, x_off, y_off, pdata) = p
                exec(self.point_view_placement[place])
                if lx <= x <= rx and by <= y <= ty:
                    result.append(((x, y), pdata))

        return result

    def GetNearestImageInLayer(self, layer, pt):
        """Decide if clicked location selects an image object in layer data.

        layer  layer object we are looking in
        pt     click geo location (lon, lat)

        Return None (no selection) or data for closest image.
        """

        (ptx, pty) = pt
        res = None
        dist = 9999999.0        # more than possible
        for p in layer.data:
            x = p[0]
            y = p[1]
            d = (x - ptx) * (x - ptx) + (y - pty) * (y - pty)
            if d < dist:
                dist = d
                res = (x, y)

        if dist <= layer.delta:
            return res

        return None

    def GetBoxSelImagesInLayer(self, layer, p1, p2):
        """Get list of images inside box p1-p2.

        layer  reference to layer object we are working on
        p1     one corner point of selection box
        p2     opposite corner point of selection box

        We have to figure out which corner is which.

        Return a list of (lon, lat) of points inside box.
        """

        # get canonical box limits
        (p1x, p1y) = p1
        (p2x, p2y) = p2
        lx = min(p1x, p2x)      # left x coord
        rx = max(p1x, p2x)
        ty = max(p1y, p2y)      # top y coord
        by = min(p1y, p2y)

        result = []
        for p in layer.data:
            x = p[0]
            y = p[1]
            if lx <= x <= rx and by <= y <= ty:
                result.append((x, y))

        return result

    def GetNearestPolygonInLayer(self, layer, pt):
        """Get nearest polygon object in layer data.

        layer  layer object we are looking in
        pt     click geo location (lon, lat)

        Return None (no selection) or data for closest polygon.

        Code here originally supplied by Stefan Harwarth, from
        [http://paulbourke.net/geometry/insidepoly/].
        """

        (ptx, pty) = pt

        for poly in layer.data:
            p = poly[0]
            if point_inside_polygon(ptx, pty, p):
                return p

        return None

    def GetBoxSelPolygonsInLayer(self, layer, p1, p2):
        """Get list of polygons inside box p1-p2.

        layer  reference to layer object we are working on
        p1     one corner point of selection box
        p2     opposite corner point of selection box

        We have to figure out which corner is which.

        Return a list of (lon, lat) of points inside box.
        """

        return []

    def GetNearestTextInLayer(self, layer, pt):
        """Determine if clicked location selects a text object in layer data.

        layer  layer object we are looking in
        pt     click geo location (lon, lat)

        Return None (no selection) or data for closest text.

        Just search for text 'hotspot' - just like point select.
        Later make text sensitive (need text extent data).
        """

        (ptx, pty) = pt
        res = None
        dist = 1.0E+100        # more than possible
        for p in layer.data:
            (x, y, _, _, _, _, _, _, _, _, _, data) = p
            d = (x - ptx) * (x - ptx) + (y - pty) * (y - pty)
            if d < dist:
                dist = d
                res = ((x, y), data)

        if dist <= layer.delta:
            return res

        return None

    def GetBoxSelTextsInLayer(self, layer, p1, p2):
        """Get list of text objects inside box p1-p2.

        layer  reference to layer object we are working on
        p1     one corner point of selection box
        p2     opposite corner point of selection box

        We have to figure out which corner is which.

        Return a list of (lon, lat) of points inside box.
        Return None (no selection) or list [((lon, lat), data), ...]
        of points inside the selection box.
        """

        # get canonical box limits
        (p1x, p1y) = p1
        (p2x, p2y) = p2
        lx = min(p1x, p2x)      # left x coord
        rx = max(p1x, p2x)
        ty = max(p1y, p2y)      # top y coord
        by = min(p1y, p2y)

        # get a list of points inside the selection box
        result = []

        for p in layer.data:
            (x, y, _, _, _, _, _, _, _, _, _, data) = p
            if lx <= x <= rx and by <= y <= ty:
                result.append(((x, y), data))

        return result

    ######
    # The next two routines could be folded into one as they are the same.
    # However, if we ever implement a 'staged' zoom, we need both routines.
    ######

    def ZoomIn(self, xy, update=True):
        """Zoom map in to the next level.

        xy  is a tuple (x, y) of pixel coords of new centre after zoom

        if update == True (default) then self.Update() is called to redraw the canvas.

        The tile stuff has already been set to the correct level.

        """
        # set view state
        (map_x, map_y) = self.GetMapCoordsFromView(xy)
        self.view_offset_x = map_x * 2 - self.view_width / 2
        self.view_offset_y = map_y * 2 - self.view_height / 2

        # set some internal state through size code
        self.ResizeCallback()

        if update:
            self.Update()

    def ZoomOut(self, xy, update=True):
        """Zoom map out to the previous level.

        xy  is a tuple (x, y) of pixel coords of new centre after zoom

        The tile stuff has already been set to the correct level.

        """
        # set view state
        (map_x, map_y) = self.GetMapCoordsFromView(xy)
        self.view_offset_x = map_x / 2 - self.view_width / 2
        self.view_offset_y = map_y / 2 - self.view_height / 2

        # set some internal state through size code
        self.ResizeCallback()

        if update:
            self.Update()

    ######
    # Routines for pySlip events
    ######

    # there is no set_select_event() method and no self.select_event boolean
    # flag as the user controls selectability on a layer-by-layer basis.

    def RaiseSelectEvent(self, evtype, layer, point, mposn=None, vposn=None):
        """Raise a point SELECT event.

        evtype  select event type
        layer   layer the select was on
        point   point(s) selected, ie, a single or list of point tuples:
                    ((x, y), data)
        mposn   map coordinates of the mouse click
        vposn   view coordinates of the mouse click

        Note: this could be a BOX select, ie, multiple points in 'point'.
        """

        event = _PySlipEvent(_myEVT_PYSLIP_SELECT, self.GetId())
        event.evtype = evtype
        event.layer_id = layer.id
        event.point = point
        event.mposn = mposn
        event.vposn = vposn
        self.GetEventHandler().ProcessEvent(event)

    def SetLevelChangeEvent(self, event):
        """Set event routine on level change.

        event  True if event is to be raised on change
        """

        self.change_level_event = event

    def RaiseLevelChangeEvent(self, level):
        """Raise a LEVEL event."""

        if self.change_level_event:
            event = _PySlipEvent(_myEVT_PYSLIP_LEVEL, self.GetId())
            event.level = level
            self.GetEventHandler().ProcessEvent(event)

    def SetMousePositionEvent(self, event):
        """Set callback function on mouse move.

        event  True if event is to be raised on mouse move
        """

        self.mouse_position_event = event

    def RaiseMousePositionEvent(self, posn):
        """Raise a mouse position event.

        posn  the new mouse position (in view pixel coordinates)
        """

        if self.mouse_position_event:
            event = _PySlipEvent(_myEVT_PYSLIP_POSITION, self.GetId())
            if posn and self.PositionIsOnMap(posn):
                event.position = self.ConvertView2Geo(posn)
            else:
                event.position = None
            self.GetEventHandler().ProcessEvent(event)

    def PositionIsOnMap(self, posn):
        """Return True if 'posn' is actually on map (not just view).

        posn  a tuple (x,y) position in view pixel coordinates
        """

        return True #NKS always accept mouse coordinates
        (x, y) = posn

        if self.view_offset_x < 0:
            if x < -self.view_offset_x:
                return False
            if x > self.view_width + self.view_offset_x:
                return False

        if self.view_offset_y < 0:
            if y < -self.view_offset_y:
                return False
            if y > self.view_height + self.view_offset_y:
                return False

        return True

    def get_i18n_kw(self, kwargs, kws, default):
        """Get alternate international keyword value.

        kwargs   dictionary to look for keyword value
        kws      iterable of keyword spelling strings
        default  default value if no keyword found

        Returns the keyword value.
        """

        result = None
        for kw_str in kws[:-1]:
            result = kwargs.get(kw_str, None)
            if result:
                break
        else:
            result = kwargs.get(kws[-1], default)

        return result


 *******************************************************************************


 *******************************************************************************
rstbx/slip_viewer/ring_frame.py
from __future__ import absolute_import, division, print_function
# -*- Mode: Python; c-basic-offset: 2; indent-tabs-mode: nil; tab-width: 8 -*-
#
# $Id$

import wx
from six.moves import range


class RingSettingsFrame(wx.MiniFrame):
  def __init__(self, *args, **kwds):
    super(RingSettingsFrame, self).__init__(*args, **kwds)
    szr = wx.BoxSizer(wx.VERTICAL)
    panel = RingSettingsPanel(self)
    self.SetSizer(szr)
    szr.Add(panel, 1, wx.EXPAND)
    szr.Fit(panel)
    self.panel = panel
    self.sizer = szr
    self.Fit()
    self.Bind(wx.EVT_CLOSE, lambda evt : self.Destroy(), self)


class RingSettingsPanel(wx.Panel):
  def __init__(self, *args, **kwds):
    # XXX Support several rings.  Plot radial distribution somewhere
    # (not here), but maybe distribution along ring.  Drop-down menu
    # for ring center, and button to reset to beam center.

    super(RingSettingsPanel, self).__init__(*args, **kwds)

    # Needed to draw and delete the rings.  XXX Applies to
    # calibration_frame as well?
    self._pyslip = self.GetParent().GetParent().pyslip

    sizer = wx.BoxSizer(wx.VERTICAL)
    self.SetSizer(sizer)

    # Number of decimal digits for distances.
    self.digits = 2

    # Distance control XXX probably does not belong here
#    print "DISTANCE",self.GetParent().GetParent().viewer._img
#    box = wx.BoxSizer(wx.HORIZONTAL)
#    from wxtbx.phil_controls.floatctrl import FloatCtrl
#    from wxtbx.phil_controls import EVT_PHIL_CONTROL
#    self.distance_ctrl = FloatCtrl(self, pos=(300,180), size=(80,-1),
#    value=80.00,
#    name="Detector Distance")
#    self.distance_ctrl.SetMax(1000)
#    self.distance_ctrl.SetMin(5)
#    self.distance_ctrl.SetOptional(False)
#    box.Add(self.distance_ctrl, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
#    txtd = wx.StaticText(self, label="Detector Distance")
#    box.Add(txtd, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
#    s.Add(box)

    from wx.lib.agw.floatspin import EVT_FLOATSPIN, FloatSpin

    # XXX Should really make value be in Aangstroem resolution, and
    # have a non-linear slider.
    self._radius = 100
    self._center = [0, 0]
    radius_max = 2000
    radius_min = 10

    # Radius controls.
    box = wx.BoxSizer(wx.HORIZONTAL)

    self.slider = wx.Slider(self, maxValue=radius_max,
                            minValue=radius_min, size=(250, -1),
                            style=wx.SL_AUTOTICKS | wx.SL_HORIZONTAL,
                            value=self._radius)
    box.Add(self.slider,
            0, wx.RIGHT | wx.TOP | wx.BOTTOM | wx.ALIGN_CENTER_VERTICAL, 5)
    self.Bind(wx.EVT_SLIDER, self.OnSlide, self.slider)

    self.spinner = FloatSpin(self, digits=self.digits, max_val=radius_max,
                             min_val=radius_min, value=self._radius)
    box.Add(self.spinner,
            0, wx.RIGHT | wx.TOP | wx.BOTTOM | wx.ALIGN_CENTER_VERTICAL, 5)
    self.Bind(EVT_FLOATSPIN, self.OnSpin, self.spinner)

    self.auto = wx.Button(self, label="Auto fit")
    self.Bind(wx.EVT_BUTTON, self.OnAutoFit, self.auto)
    box.Add(self.auto, 0, wx.RIGHT | wx.TOP | wx.BOTTOM | wx.ALIGN_CENTER_VERTICAL, 5)

    sizer.Add(box)

    # Centering controls.
    box = wx.BoxSizer(wx.HORIZONTAL)

    self.spinner_fast = FloatSpin(
      self, digits=self.digits, name="fast_ctrl", value=self._center[0])
    box.Add(self.spinner_fast,
            0, wx.RIGHT | wx.TOP | wx.BOTTOM | wx.ALIGN_CENTER_VERTICAL, 5)
    box.Add(wx.StaticText(self, label="Center fast"),
            0, wx.ALL | wx.ALIGN_CENTER_VERTICAL, 5)
    self.Bind(EVT_FLOATSPIN, self.OnSpinCenter, self.spinner_fast)

    self.spinner_slow = FloatSpin(
      self, digits=self.digits, name="slow_ctrl", value=self._center[1])
    box.Add(self.spinner_slow,
            0, wx.RIGHT | wx.TOP | wx.BOTTOM | wx.ALIGN_CENTER_VERTICAL, 5)
    box.Add(wx.StaticText(self, label="Center slow"),
            0, wx.ALL | wx.ALIGN_CENTER_VERTICAL, 5)
    self.Bind(EVT_FLOATSPIN, self.OnSpinCenter, self.spinner_slow)

    sizer.Add(box)

    self.DrawRing()


  def __del__(self):
    if (hasattr(self, "_ring_layer") and self._ring_layer is not None):
      self._pyslip.DeleteLayer(self._ring_layer)


  def OnSlide(self, event):
    # Keep slider and spinner synchronized.
    obj = event.EventObject # XXX Is this construct sane?  See below
                            # and in calibration_frame, too!
    self._radius = obj.GetValue()
    self.spinner.SetValue(self._radius)

    self.DrawRing()

  def OnAutoFit(self, event):
    import math
    jitter = 6

    detector = self._pyslip.tiles.raw_image.get_detector()
    beam     = self._pyslip.tiles.raw_image.get_beam()
    # FIXME assumes all detector elements use the same millimeter-to-pixel convention
    if detector[0].get_distance() > 0:
      if len(detector) > 1:
        h = detector.hierarchy()
        if len(h) > 0:
          beam_pixel_fast, beam_pixel_slow = detector[0].millimeter_to_pixel(
            detector.hierarchy().get_beam_centre(beam.get_s0()))
        else:
          beam_pixel_fast, beam_pixel_slow = detector[0].millimeter_to_pixel(
            detector[0].get_beam_centre(beam.get_s0()))
      else:
        beam_pixel_fast, beam_pixel_slow = detector[0].millimeter_to_pixel(
          detector[0].get_beam_centre(beam.get_s0()))

    avg_distance = -sum([p.get_distance() for p in detector])/len(detector)

    beam_pixel_fast += self._center[0]
    beam_pixel_slow += self._center[1]

    def PointsOnCircle(center, radius, count):
      for r in range(count):
        t = (r/count)*2*math.pi
        yield (center[0] + (radius*math.cos(t)),
               center[1] + (radius*math.sin(t)))

    best = float("-inf")
    bestc = [self._center[0],self._center[1]]
    bestr = self._radius

    raw_data = self._pyslip.tiles.raw_image.get_raw_data()
    if not isinstance(raw_data, tuple):
      raw_data = (raw_data,)

    for j in range(-jitter, jitter, 1):
      j /= 2
      for i in range(-jitter, jitter, 1):
        i /= 2
        for r in range(-jitter, jitter, 1):
          r /= 2
          total = 0.0
          for point in PointsOnCircle((beam_pixel_fast+i,beam_pixel_slow+j),self._radius+r,360):
            mm = detector[0].pixel_to_millimeter(point)
            mm = (mm[0],mm[1],avg_distance)
            pid = detector.get_panel_intersection(mm)
            if pid >= 0:
              px = detector[pid].get_ray_intersection_px(mm)
              px = [int(round(px[0])),int(round(px[1]))]
              data = raw_data[pid]
              if px[0] >= 0 and px[0] < data.focus()[1] and px[1] >= 0 and px[1] < data.focus()[0]:
                total += data[px[1],px[0]]
          if total > best:
            best = total
            bestc = [self._center[0]+i,self._center[1]+j]
            bestr = self._radius+r
          print("r: % 3.1f, i: % 3.1f, j: % 3.1f, best: %f"%(r, i, j, best))
    print("DONE", bestc, bestr)
    self._radius = bestr
    self._center = bestc

    self.spinner.SetValue(bestr)
    self.spinner_fast.SetValue(bestc[0])
    self.spinner_slow.SetValue(bestc[1])

    self.DrawRing()

  def OnSpin(self, event):
    # Keep slider and spinner synchronized.  XXX OnSpinRadius()?
    obj = event.EventObject
    self._radius = obj.GetValue()
    self.slider.SetValue(self._radius)

    self.DrawRing()


  def OnSpinCenter(self, event):
    obj = event.EventObject
    name = obj.GetName()

    if (name == "fast_ctrl"):
      self._center[0] = obj.GetValue()
    elif (name == "slow_ctrl"):
      self._center[1] = obj.GetValue()

    self.DrawRing()


  def _draw_ring_layer(self, dc, data, map_rel):
    """Draw a points layer.

    dc       the device context to draw on
    data     an iterable of point tuples:
             (x, y, place, radius, colour, x_off, y_off, pdata)
    map_rel  points relative to map if True, MUST BE TRUE for lightweight
    Assumes all points are the same colour, saving 100's of ms.
    """

    assert map_rel is True
    if len(data)==0:
      return
    (lon, lat, place, radius, colour, x_off, y_off, pdata) = data[0]

    scale = 2**self._pyslip.tiles.zoom_level

    # Draw points on map/view, using transparency if implemented.
    try:
      dc = wx.GCDC(dc)
    except NotImplementedError:
      pass
    dc.SetPen(wx.Pen(colour))
    dc.SetBrush(wx.Brush(colour, wx.TRANSPARENT))
    for (lon, lat, place, radius, colour, x_off, y_off, pdata) in data:
      (x, y) = self._pyslip.ConvertGeo2View((lon, lat))
      dc.DrawCircle(x, y, radius * scale)


  def DrawRing(self):
    detector = self._pyslip.tiles.raw_image.get_detector()
    beam     = self._pyslip.tiles.raw_image.get_beam()

    xrayframe = self.GetParent().GetParent()
    panel_id, beam_pixel_fast, beam_pixel_slow = xrayframe.get_beam_center_px()

    if len(detector) > 1:
      beam_pixel_slow, beam_pixel_fast = xrayframe.pyslip.tiles.flex_image.tile_readout_to_picture(
        panel_id, beam_pixel_slow - 0.5, beam_pixel_fast - 0.5)

    center = self._pyslip.tiles.picture_fast_slow_to_map_relative(
      beam_pixel_fast + self._center[0], beam_pixel_slow + self._center[1])

    # XXX Transparency?
    ring_data = [(center[0], center[1],
                  {"colour": "red", "radius": self._radius})]

    # Remove the old ring layer, and draw a new one.  XXX Why
    # disappears at highest levels?
    if (hasattr(self, "_ring_layer") and self._ring_layer is not None):
      self._pyslip.DeleteLayer(self._ring_layer)
      self._ring_layer = None
    self._ring_layer = self._pyslip.AddPointLayer(
      ring_data,
      map_rel=True,
      visible=True,
      show_levels=[-3, -2, -1, 0, 1, 2, 3, 4, 5],
      renderer=self._draw_ring_layer,
      name="<ring_layer>")


 *******************************************************************************


 *******************************************************************************
rstbx/slip_viewer/score_frame.py
# -*- mode: python; coding: utf-8; indent-tabs-mode: nil; python-indent: 2 -*-
#
# $Id$

from __future__ import absolute_import, division, print_function
from six.moves import range

import wx

from collections import OrderedDict
_scores = OrderedDict()


class ScoreSettingsFrame(wx.MiniFrame):
  # XXX Is this scoring or rating?

  def __init__(self, *args, **kwds):
    super(ScoreSettingsFrame, self).__init__(*args, **kwds)
    szr = wx.BoxSizer(wx.VERTICAL)
    panel = ScoreSettingsPanel(self)
    self.SetSizer(szr)
    szr.Add(panel, 1, wx.EXPAND)
    szr.Fit(panel)
    self.panel = panel
    self.sizer = szr
    self.Fit()
    self.Bind(wx.EVT_CLOSE, lambda evt : self.Destroy(), self)


class ScoreSettingsPanel(wx.Panel):
  def __init__(self, *args, **kwds):
    from wxtbx import bitmaps

    super(ScoreSettingsPanel, self).__init__(*args, **kwds)

    # Needed for communication with the root frame.
    self._root_frame = self.GetParent().GetParent()

    sizer = wx.BoxSizer(wx.VERTICAL)
    self.SetSizer(sizer)

    self._id_text = wx.NewId()
    text = wx.StaticText(self, id= self._id_text, label="")
    sizer.Add(text, flag=wx.ALIGN_CENTER)

    # The score buttons.  XXX Would really like this to be stars or
    # some such.  Could then zap the static text above.
    box = wx.BoxSizer(wx.HORIZONTAL)
    self._id_buttons = []
    for i in range(6):
      btn = wx.Button(self, label="%d" % i)
      box.Add(btn, flag=wx.ALIGN_CENTER, border=5)
      self.Bind(wx.EVT_BUTTON, self.OnScore, btn)
      self._id_buttons.append(btn.GetId())
    sizer.Add(box)

    # XXX Would like to have label and short help for the buttons.
    # Buttons in wxWidgets version 2.9.1 and later support text and
    # bitmap, see SetBitmap, SetBitmapLabel, SetBitmapDisabled, etc.
    box = wx.BoxSizer(wx.HORIZONTAL)

    self._id_previous = wx.NewId()
    btn = wx.BitmapButton(
      self,
      id=self._id_previous,
      bitmap=bitmaps.fetch_icon_bitmap('actions', '1leftarrow'),
      style=wx.BORDER_NONE)
    box.Add(btn, flag=wx.ALIGN_CENTER, border=5)
    self.Bind(wx.EVT_BUTTON, self.OnPrevious, btn)

    btn = wx.Button(self, label="Save scores")
    box.Add(btn, flag=wx.ALIGN_CENTER, border=5)
    self.Bind(wx.EVT_BUTTON, self.OnSave, btn)

    self._id_next = wx.NewId()
    btn = wx.BitmapButton(
      self,
      id=self._id_next,
      bitmap=bitmaps.fetch_icon_bitmap('actions', '1rightarrow'),
      style=wx.BORDER_NONE)
    box.Add(btn, flag=wx.ALIGN_CENTER, border=5)
    self.Bind(wx.EVT_BUTTON, self.OnNext, btn)

    sizer.Add(box, flag=wx.ALIGN_CENTER)

    # Register update events for the dynamic widgets.
    self.Bind(wx.EVT_UPDATE_UI, self.OnUpdateNext, id=self._id_next)
    self.Bind(wx.EVT_UPDATE_UI, self.OnUpdatePrevious, id=self._id_previous)
    self.Bind(wx.EVT_UPDATE_UI, self.OnUpdateText, id=self._id_text)

    for i in range(self._root_frame.image_chooser.GetCount()):
      _scores[self._root_frame.get_key(self._root_frame.image_chooser.GetClientData(i))] = None

  def OnNext(self, event):
    self._root_frame.OnNext(event)


  def OnPrevious(self, event):
    self._root_frame.OnPrevious(event)


  def OnScore(self, event):
    score = self._id_buttons.index(event.EventObject.GetId())
    key = self._root_frame.get_key(self._root_frame.image_chooser.GetClientData(self._root_frame.image_chooser.GetSelection()))
    _scores[key] = score
    self.OnNext(event)


  def OnSave(self, event):
    dialog = wx.FileDialog(
      self,
      defaultDir='',
      message="Save scores",
      style=wx.FD_SAVE | wx.FD_OVERWRITE_PROMPT,
      wildcard="Text files (*.txt)|*.txt")
    if dialog.ShowModal() == wx.ID_OK:
      path = dialog.GetPath()
      if (path != ''):
        stream = open(path, "w")
        for (key, score) in _scores.iteritems():
          if score is None:
            print("%s None" % (key), file=stream)
          else:
            print("%s %d" % (key, score), file=stream)
        stream.close()
        print("Dumped scores to", path)


  def OnUpdateNext(self, event):
    root_next = self._root_frame.toolbar.FindById(wx.ID_FORWARD)
    event.Enable(root_next.IsEnabled())


  def OnUpdatePrevious(self, event):
    root_previous = self._root_frame.toolbar.FindById(wx.ID_BACKWARD)
    event.Enable(root_previous.IsEnabled())


  def OnUpdateText(self, event):
    key = self._root_frame.GetTitle()
    if key in _scores:
      event.SetText("Previous score: %d" % _scores[key])
    else:
      event.SetText("Not previously scored")

    # Call self.Layout() to recenter the updated text.
    self.Layout()


 *******************************************************************************


 *******************************************************************************
rstbx/slip_viewer/slip_display.py
#!/usr/bin/env python
# -*- coding= utf-8 -*-

"""pySlip demonstration program."""
from __future__ import absolute_import, division, print_function
# Copyright (c) 2010, Ross Wilson (rzzzwilson@gmail.com). All rights reserved.
#
# Redistribution and use in source and binary forms, with or
# without modification, are permitted provided that the following conditions
# are met:
#  * Redistributions of source code must retain the above copyright notice,
#    this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
#  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

import sys
import wx

from . import pyslip
from . import tile_generation
from six.moves import range
pyslip._Tiles = tile_generation._Tiles

######
# Various demo constants
######

# demo name/version
DemoName = 'pySlip %s - Demonstration' % pyslip.__version__
DemoVersion = '1.6'

# tiles info
TileDirectory = 'tiles'
MinTileLevel = 0

# initial view level and position
InitViewLevel = -2
#InitViewPosition = (103.770, 1.335)
InitViewPosition = (-100,100)

# levels on which various layers show
MRPointShowLevels = [3, 4]
MRImageShowLevels = [3, 4]
MRTextShowLevels = [3, 4]
MRPolyShowLevels = [3, 4]

# the number of decimal places in a lon/lat display
LonLatPrecision = 3

# startup size of the application
DefaultAppSize = (800, 665)

# how close click has to be before point is selected
# the value is distance squared (degrees^2)
PointSelectDelta = 0.025

# unselected point colour (rgb) and size
PointsColour = '#ff0000'
PointsSize = 3

# Selected point colour (rgb) and size
SelectColour = '#0000ff'
SelectSize = 5

# Polygon point colour (rgba) and size
PolygonColour = '#0000ff'
PolygonSize = 4

# Polygon2 point colour (rgba) and size
Polygon2Colour = '#000000'
Polygon2Size = 4

# image used for shipwrecks, glassy buttons, etc
ShipImg = 'graphics/shipwreck.png'

GlassyImg2 = 'graphics/glassy_button_2.png'
SelGlassyImg2 = 'graphics/selected_glassy_button_2.png'
GlassyImg3 = 'graphics/glassy_button_3.png'
SelGlassyImg3 = 'graphics/selected_glassy_button_3.png'
GlassyImg4 = 'graphics/glassy_button_4.png'
SelGlassyImg4 = 'graphics/selected_glassy_button_4.png'
GlassyImg5 = 'graphics/glassy_button_5.png'
SelGlassyImg5 = 'graphics/selected_glassy_button_5.png'
GlassyImg6 = 'graphics/glassy_button_6.png'
SelGlassyImg6 = 'graphics/selected_glassy_button_6.png'

# image used for shipwrecks
CompassRoseGraphic = 'graphics/compass_rose.png'

######
# Various GUI layout constants
######

# sizes of various spacers
HSpacerSize = (3,1)         # horizontal in application screen
VSpacerSize = (1,5)         # vertical in control pane

# border width when packing GUI elements
PackBorder = 1


################################################################################
# Override the wx.TextCtrl class to add read-only style and background colour
################################################################################

# background colour for the 'read-only' text field
ControlReadonlyColour = '#ffffcc'

class ROTextCtrl(wx.TextCtrl):
    """Override the wx.TextCtrl widget to get read-only text control which
    has a distinctive background colour."""

    def __init__(self, parent, value, tooltip='', *args, **kwargs):
        wx.TextCtrl.__init__(self, parent, wx.ID_ANY, value=value,
                             style=wx.TE_READONLY, *args, **kwargs)
        self.SetBackgroundColour(ControlReadonlyColour)
        self.SetToolTip(wx.ToolTip(tooltip))

################################################################################
# Override the wx.StaticBox class to show our style
################################################################################

class AppStaticBox(wx.StaticBox):

    def __init__(self, parent, label, *args, **kwargs):
        if label:
            label = '  ' + label + '  '
        wx.StaticBox.__init__(self, parent, wx.ID_ANY, label, *args, **kwargs)

################################################################################
# Class for a LayerControl widget.
################################################################################

myEVT_ONOFF = wx.NewEventType()
myEVT_SHOWONOFF = wx.NewEventType()
myEVT_SELECTONOFF = wx.NewEventType()

EVT_ONOFF = wx.PyEventBinder(myEVT_ONOFF, 1)
EVT_SHOWONOFF = wx.PyEventBinder(myEVT_SHOWONOFF, 1)
EVT_SELECTONOFF = wx.PyEventBinder(myEVT_SELECTONOFF, 1)

class LayerControlEvent(wx.PyCommandEvent):
    """Event sent when a LayerControl is changed."""

    def __init__(self, eventType, id):
        wx.PyCommandEvent.__init__(self, eventType, id)

class LayerControl(wx.Panel):

    def __init__(self, parent, title, selectable=False, editable=False,
                 **kwargs):
        """Initialise a LayerControl instance.

        parent      reference to parent object
        title       text to ahow in static box outline
        selectable  True if 'selectable' checkbox is to be displayed
        editable    True if layer can be edited
        **kwargs    keyword args for Panel
        """

        # create and initialise the base panel
        wx.Panel.__init__(self, parent=parent, id=wx.ID_ANY, **kwargs)
        self.SetBackgroundColour(wx.WHITE)

        self.selectable = selectable
        self.editable = editable

        box = AppStaticBox(self, title)
        sbs = wx.StaticBoxSizer(box, orient=wx.VERTICAL)
        gbs = wx.GridBagSizer()

        self.cbx_onoff = wx.CheckBox(self, wx.ID_ANY, label='Add layer')
        gbs.Add(self.cbx_onoff, (0,0), span=(1,4))

        self.cbx_show = wx.CheckBox(self, wx.ID_ANY, label='Show')
        gbs.Add(self.cbx_show, (1,1))
        self.cbx_show.Disable()

        if selectable:
            self.cbx_select = wx.CheckBox(self, wx.ID_ANY, label='Select')
            gbs.Add(self.cbx_select, (1,2))
            self.cbx_select.Disable()

        if editable:
            self.cbx_edit = wx.CheckBox(self, wx.ID_ANY, label='Edit')
            gbs.Add(self.cbx_edit, (1,3))
            self.cbx_edit.Disable()

        sbs.Add(gbs)
        self.SetSizer(sbs)
        sbs.Fit(self)

        # tie handlers to change events
        self.cbx_onoff.Bind(wx.EVT_CHECKBOX, self.onChangeOnOff)
        self.cbx_show.Bind(wx.EVT_CHECKBOX, self.onChangeShowOnOff)
        if selectable:
            self.cbx_select.Bind(wx.EVT_CHECKBOX, self.onChangeSelectOnOff)
#        if editable:
#            self.cbx_edit.Bind(wx.EVT_CHECKBOX, self.onChangeEditOnOff)

    def onChangeOnOff(self, event):
        """Main checkbox changed."""

        event = LayerControlEvent(myEVT_ONOFF, self.GetId())
        event.state = self.cbx_onoff.IsChecked()
        self.GetEventHandler().ProcessEvent(event)

        if self.cbx_onoff.IsChecked():
            self.cbx_show.Enable()
            self.cbx_show.SetValue(True)
            if self.selectable:
                self.cbx_select.Enable()
                self.cbx_select.SetValue(False)
            if self.editable:
                self.cbx_edit.Enable()
                self.cbx_edit.SetValue(False)
        else:
            self.cbx_show.Disable()
            if self.selectable:
                self.cbx_select.Disable()
            if self.editable:
                self.cbx_edit.Disable()

    def onChangeShowOnOff(self, event):
        """Show checkbox changed."""

        event = LayerControlEvent(myEVT_SHOWONOFF, self.GetId())
        event.state = self.cbx_show.IsChecked()
        self.GetEventHandler().ProcessEvent(event)

    def onChangeSelectOnOff(self, event):
        """Select checkbox changed."""

        event = LayerControlEvent(myEVT_SELECTONOFF, self.GetId())
        if self.selectable:
            event.state = self.cbx_select.IsChecked()
        else:
            event_state = False
        self.GetEventHandler().ProcessEvent(event)

################################################################################
# The main application frame
################################################################################

class AppFrame(wx.Frame):
    def __init__(self, tile_dir=TileDirectory):
        wx.Frame.__init__(self, None, size=DefaultAppSize,
                          title='%s %s' % (DemoName, DemoVersion))
        self.SetMinSize(DefaultAppSize)
        self.panel = wx.Panel(self, wx.ID_ANY)
        self.panel.SetBackgroundColour(wx.WHITE)
        self.panel.ClearBackground()

        self.tile_directory = tile_dir

        # build the GUI
        self.pyslip = None
        self.make_gui(self.panel)

        # do initialisation stuff - all the application stuff
        self.init()

        # finally, set up application window position
        self.Centre()

        # create select event dispatch directory
        self.demo_select_dispatch = {}

        # finally, bind events to handlers
        self.pyslip.Bind(pyslip.EVT_PYSLIP_SELECT, self.handle_select_event)
        self.pyslip.Bind(pyslip.EVT_PYSLIP_POSITION, self.handle_position_event)
        self.pyslip.Bind(pyslip.EVT_PYSLIP_LEVEL, self.handle_level_change)

#####
# Build the GUI
#####

    def set_pyslip(self, parent):
        self.pyslip = pyslip.PySlip(parent, tile_dir=None, # dummy file name value
                                    min_level=MinTileLevel)

    def make_gui(self, parent):
        """Create application GUI."""

        # start application layout
        all_display = wx.BoxSizer(wx.HORIZONTAL)
        parent.SetSizer(all_display)

        # put map view in left of horizontal box
        sl_box = self.make_gui_view(parent)
        all_display.Add(sl_box, proportion=1, border=1, flag=wx.EXPAND)

        # small spacer here - separate view and controls
        #all_display.AddSpacer(HSpacerSize)

        # add controls to right of spacer
        #controls = self.make_gui_controls(parent)
        #all_display.Add(controls, proportion=0, border=1)

        parent.SetSizerAndFit(all_display)

    def make_gui_view(self, parent):
        """Build the map view widget

        parent  reference to the widget parent

        Returns the static box sizer.
        """

        # create gui objects
        sb = AppStaticBox(parent, '')

        # lay out objects
        box = wx.StaticBoxSizer(sb, orient=wx.HORIZONTAL)
        if (self.pyslip is None):
            self.set_pyslip(parent)
        box.Add(self.pyslip, proportion=1, border=1, flag=wx.EXPAND)

        return box

    def make_gui_controls(self, parent):
        """Build the 'controls' part of the GUI

        parent  reference to parent

        Returns reference to containing sizer object.
        """

        # all controls in vertical box sizer
        controls = wx.BoxSizer(wx.VERTICAL)

        # add the map level in use widget
        level = self.make_gui_level(parent)
        controls.Add(level, proportion=0, flag=wx.EXPAND|wx.ALL)

        # vertical spacer
        controls.AddSpacer(VSpacerSize)

        # add the mouse position feedback stuff
        mouse = self.make_gui_mouse(parent)
        controls.Add(mouse, proportion=0, flag=wx.EXPAND|wx.ALL)

        # vertical spacer
        controls.AddSpacer(VSpacerSize)

        # controls for map-relative points layer
        point = self.make_gui_point(parent)
        controls.Add(point, proportion=0, flag=wx.EXPAND|wx.ALL)

        # vertical spacer
        controls.AddSpacer(VSpacerSize)

        # controls for view-relative points layer
        point_view = self.make_gui_point_view(parent)
        controls.Add(point_view, proportion=0, flag=wx.EXPAND|wx.ALL)

        # vertical spacer
        controls.AddSpacer(VSpacerSize)

        # controls for map-relative image layer
        image = self.make_gui_image(parent)
        controls.Add(image, proportion=0, flag=wx.EXPAND|wx.ALL)

        # vertical spacer
        controls.AddSpacer(VSpacerSize)

        # controls for map-relative image layer
        image_view = self.make_gui_image_view(parent)
        controls.Add(image_view, proportion=0, flag=wx.EXPAND|wx.ALL)

        # vertical spacer
        controls.AddSpacer(VSpacerSize)

        # controls for map-relative text layer
        text = self.make_gui_text(parent)
        controls.Add(text, proportion=0, flag=wx.EXPAND|wx.ALL)

        # vertical spacer
        controls.AddSpacer(VSpacerSize)

        # controls for view-relative text layer
        text_view = self.make_gui_text_view(parent)
        controls.Add(text_view, proportion=0, flag=wx.EXPAND|wx.ALL)

        # vertical spacer
        controls.AddSpacer(VSpacerSize)

        # controls for map-relative polygon layer
        poly = self.make_gui_poly(parent)
        controls.Add(poly, proportion=0, flag=wx.EXPAND|wx.ALL)

        # vertical spacer
        controls.AddSpacer(VSpacerSize)

        # controls for view-relative polygon layer
        poly_view = self.make_gui_poly_view(parent)
        controls.Add(poly_view, proportion=0, flag=wx.EXPAND|wx.ALL)

        return controls

    def make_gui_level(self, parent):
        """Build the control that shows the level.

        parent  reference to parent

        Returns reference to containing sizer object.
        """

        # create objects
        txt = wx.StaticText(parent, wx.ID_ANY, 'Level: ')
        self.map_level = wx.StaticText(parent, wx.ID_ANY, ' ')

        # lay out the controls
        sb = AppStaticBox(parent, 'Map level')
        box = wx.StaticBoxSizer(sb, orient=wx.HORIZONTAL)
        box.Add(txt, border=PackBorder, flag=(wx.ALIGN_CENTER_VERTICAL
                                     |wx.ALIGN_RIGHT|wx.LEFT))
        box.Add(self.map_level, proportion=0, border=PackBorder,
                flag=wx.RIGHT|wx.TOP)

        return box

    def make_gui_mouse(self, parent):
        """Build the mouse part of the controls part of GUI.

        parent  reference to parent

        Returns reference to containing sizer object.
        """

        # create objects
        txt = wx.StaticText(parent, wx.ID_ANY, 'Lon/Lat: ')
        self.mouse_position = ROTextCtrl(parent, '', size=(150,-1),
                                         tooltip=('Shows the mouse '
                                                  'longitude and latitude '
                                                  'on the map'))

        # lay out the controls
        sb = AppStaticBox(parent, 'Mouse position')
        box = wx.StaticBoxSizer(sb, orient=wx.HORIZONTAL)
        box.Add(txt, border=PackBorder, flag=(wx.ALIGN_CENTER_VERTICAL
                                     |wx.ALIGN_RIGHT|wx.LEFT))
        box.Add(self.mouse_position, proportion=1, border=PackBorder,
                flag=wx.RIGHT|wx.TOP|wx.BOTTOM)

        return box

    def make_gui_point(self, parent):
        """Build the points part of the controls part of GUI.

        parent  reference to parent

        Returns reference to containing sizer object.
        """

        # create widgets
        point_obj = LayerControl(parent, 'Points, map relative %s'
                                         % str(MRPointShowLevels),
                                 selectable=True)

        # tie to event handler(s)
        point_obj.Bind(EVT_ONOFF, self.pointOnOff)
        point_obj.Bind(EVT_SHOWONOFF, self.pointShowOnOff)
        point_obj.Bind(EVT_SELECTONOFF, self.pointSelectOnOff)

        return point_obj

    def make_gui_point_view(self, parent):
        """Build the view-relative points part of the GUI.

        parent  reference to parent

        Returns reference to containing sizer object.
        """

        # create widgets
        point_obj = LayerControl(parent, 'Points, view relative',
                                 selectable=True)

        # tie to event handler(s)
        point_obj.Bind(EVT_ONOFF, self.pointViewOnOff)
        point_obj.Bind(EVT_SHOWONOFF, self.pointViewShowOnOff)
        point_obj.Bind(EVT_SELECTONOFF, self.pointViewSelectOnOff)

        return point_obj

    def make_gui_image(self, parent):
        """Build the image part of the controls part of GUI.

        parent  reference to parent

        Returns reference to containing sizer object.
        """

        # create widgets
        image_obj = LayerControl(parent, 'Images, map relative %s'
                                         % str(MRImageShowLevels),
                                 selectable=True)

        # tie to event handler(s)
        image_obj.Bind(EVT_ONOFF, self.imageOnOff)
        image_obj.Bind(EVT_SHOWONOFF, self.imageShowOnOff)
        image_obj.Bind(EVT_SELECTONOFF, self.imageSelectOnOff)

        return image_obj

    def make_gui_image_view(self, parent):
        """Build the view-relative image part of the controls part of GUI.

        parent  reference to parent

        Returns reference to containing sizer object.
        """

        # create widgets
        image_obj = LayerControl(parent, 'Images, view relative')

        # tie to event handler(s)
        image_obj.Bind(EVT_ONOFF, self.imageViewOnOff)
        image_obj.Bind(EVT_SHOWONOFF, self.imageViewShowOnOff)
        image_obj.Bind(EVT_SELECTONOFF, self.imageViewSelectOnOff)

        return image_obj

    def make_gui_text(self, parent):
        """Build the map-relative text part of the controls part of GUI.

        parent  reference to parent

        Returns reference to containing sizer object.
        """

        # create widgets
        text_obj = LayerControl(parent, 'Text, map relative %s'
                                        % str(MRTextShowLevels),
                                selectable=True, editable=True)

        # tie to event handler(s)
        text_obj.Bind(EVT_ONOFF, self.textOnOff)
        text_obj.Bind(EVT_SHOWONOFF, self.textShowOnOff)
        text_obj.Bind(EVT_SELECTONOFF, self.textSelectOnOff)

        return text_obj

    def make_gui_text_view(self, parent):
        """Build the view-relative text part of the controls part of GUI.

        parent  reference to parent

        Returns reference to containing sizer object.
        """

        # create widgets
        text_view_obj = LayerControl(parent, 'Text, view relative',
                                     selectable=True)

        # tie to event handler(s)
        text_view_obj.Bind(EVT_ONOFF, self.textViewOnOff)
        text_view_obj.Bind(EVT_SHOWONOFF, self.textViewShowOnOff)
        text_view_obj.Bind(EVT_SELECTONOFF, self.textViewSelectOnOff)

        return text_view_obj

    def make_gui_poly(self, parent):
        """Build the map-relative polygon part of the controls part of GUI.

        parent  reference to parent

        Returns reference to containing sizer object.
        """

        # create widgets
        poly_obj = LayerControl(parent,
                                'Polygon, map relative %s'
                                     % str(MRPolyShowLevels),
                                selectable=True)

        # tie to event handler(s)
        poly_obj.Bind(EVT_ONOFF, self.polyOnOff)
        poly_obj.Bind(EVT_SHOWONOFF, self.polyShowOnOff)
        poly_obj.Bind(EVT_SELECTONOFF, self.polySelectOnOff)

        return poly_obj

    def make_gui_poly_view(self, parent):
        """Build the view-relative polygon part of the controls part of GUI.

        parent  reference to parent

        Returns reference to containing sizer object.
        """

        # create widgets
        poly_view_obj = LayerControl(parent, 'Polygon, view relative',
                                     selectable=True)

        # tie to event handler(s)
        poly_view_obj.Bind(EVT_ONOFF, self.polyViewOnOff)
        poly_view_obj.Bind(EVT_SHOWONOFF, self.polyViewShowOnOff)
        poly_view_obj.Bind(EVT_SELECTONOFF, self.polyViewSelectOnOff)

        return poly_view_obj

    ######
    # pySlip demo control event handlers
    ######

##### map-relative point layer

    def pointOnOff(self, event):
        """Handle OnOff event for point layer control."""

        if event.state:
            self.point_layer = \
                self.pyslip.AddPointLayer(PointData, map_rel=True,
                                          color=PointDataColour, radius=3,
                                          offset_x=0, offset_y=0, visible=True,
                                          show_levels=MRPointShowLevels,
                                          name='<pt_layer>')
        else:
            self.pyslip.DeleteLayer(self.point_layer)
            self.point_layer = None
            if self.sel_point_layer:
                self.pyslip.DeleteLayer(self.sel_point_layer)
                self.sel_point_layer = None
                self.sel_point = None

    def pointShowOnOff(self, event):
        """Handle ShowOnOff event for point layer control."""

        if event.state:
            self.pyslip.ShowLayer(self.point_layer)
            if self.sel_point_layer:
                self.pyslip.ShowLayer(self.sel_point_layer)
        else:
            self.pyslip.HideLayer(self.point_layer)
            if self.sel_point_layer:
                self.pyslip.HideLayer(self.sel_point_layer)

    def pointSelectOnOff(self, event):
        """Handle SelectOnOff event for point layer control."""

        layer = self.point_layer
        if event.state:
            self.add_select_handler(layer, self.pointSelect)
            self.pyslip.SetLayerSelectable(layer, True)
        else:
            self.del_select_handler(layer)
            self.pyslip.SetLayerSelectable(layer, False)

    def pointSelect(self, event):
        """Handle point select exception from pyslip.

        event  the event that contains these attributes:
                   layer_id  ID of the layer the select is for
                   sel_type  type of select event
                   point     selected point(s) geo coords+data
                                 ((x,y), data)
                             (if None then no point(s) selected)

        The point select is designed to be click for on,
        then click again for off.
        """

        if event.evtype == pyslip.EventPointSelect:
            if event.point:
                (point, data) = event.point
            if event.point is None or point == self.sel_point:
                # select again, turn point off
                self.sel_point = None
                self.pyslip.DeleteLayer(self.sel_point_layer)
                self.sel_point_layer = None
            elif point:
                if self.sel_point_layer:
                    self.pyslip.DeleteLayer(self.sel_point_layer)
                self.sel_point = point
                self.sel_point_layer = \
                    self.pyslip.AddPointLayer((point,), map_rel=True,
                                              color='#0000ff',
                                              radius=5, visible=True,
                                              show_levels=MRPointShowLevels,
                                              name='<sel_pt_layer>')
        if event.evtype == pyslip.EventBoxSelect: # left box select
            # remove any previous selection
            if self.sel_point_layer:
                self.pyslip.DeleteLayer(self.sel_point_layer)
                self.sel_point_layer = None

            if event.point:
                pts = [pt for (pt,d) in event.point]
                self.sel_point_layer = \
                    self.pyslip.AddPointLayer(pts, map_rel=True,
                                              color='#00ffff',
                                              radius=5, visible=True,
                                              show_levels=[3,4],
                                              name='<boxsel_pt_layer>')
                self.pyslip.PlaceLayerBelowLayer(self.sel_point_layer,
                                                 self.point_layer)

        return True

##### view-relative point layer

    def pointViewOnOff(self, event):
        """Handle OnOff event for point view layer control."""

        if event.state:
            self.point_view_layer = \
                self.pyslip.AddPointLayer(PointViewData, map_rel=False,
                                          placement='se',
                                          color=PointViewDataColour, radius=1,
                                          visible=True,
                                          name='<point_view_layer>')
        else:
            self.pyslip.DeleteLayer(self.point_view_layer)
            self.point_view_layer = None
            if self.sel_point_view_layer:
                self.pyslip.DeleteLayer(self.sel_point_view_layer)
                self.sel_point_view_layer = None
                self.sel_point_view = None

    def pointViewShowOnOff(self, event):
        """Handle ShowOnOff event for point view layer control."""

        if event.state:
            self.pyslip.ShowLayer(self.point_view_layer)
            if self.sel_point_view_layer:
                self.pyslip.ShowLayer(self.sel_point_view_layer)
        else:
            self.pyslip.HideLayer(self.point_view_layer)
            if self.sel_point_view_layer:
                self.pyslip.HideLayer(self.sel_point_view_layer)

    def pointViewSelectOnOff(self, event):
        """Handle SelectOnOff event for point view layer control."""

        layer = self.point_view_layer
        if event.state:
            self.add_select_handler(layer, self.pointViewSelect)
            self.pyslip.SetLayerSelectable(layer, True)
        else:
            self.del_select_handler(layer)
            self.pyslip.SetLayerSelectable(layer, False)

    def pointViewSelect(self, event):
        """Handle view-relative point select event from pyslip.

        event  the event that contains these attributes:
                   layer_id  ID of the layer the select is for
                   sel_type  type of select event
                   point     selected point(s) geo coordinates
                             (if None then no point(s) was selected)

        The point select is designed to be click for on,
        then click again for off.
        """


        if event.evtype == pyslip.EventPointSelect:
            if event.point:
                (point, data) = event.point
            if event.point is None or point == self.sel_point_view:
                # select again, turn point off
                self.sel_point_view = None
                self.pyslip.DeleteLayer(self.sel_point_view_layer)
                self.sel_point_view_layer = None
            elif event.point:
                if self.sel_point_view_layer:
                    self.pyslip.DeleteLayer(self.sel_point_view_layer)
                self.sel_point_view = point
                self.sel_point_view_layer = \
                    self.pyslip.AddPointLayer((point,), map_rel=False,
                                              color='#0000ff',
                                              radius=3, visible=True,
                                              name='<sel_pt_view_layer>')
        elif event.evtype == pyslip.EventBoxSelect:
            # remove any previous selection
            if self.sel_point_view_layer:
                self.pyslip.DeleteLayer(self.sel_point_view_layer)
                self.sel_point_view_layer = None

            if event.point:
                pts = [pt for (pt,d) in event.point]
                self.sel_point_view_layer = \
                    self.pyslip.AddPointLayer(pts, map_rel=False,
                                              color='#00ffff',
                                              radius=3, visible=True,
                                              name='<boxsel_pt_view_layer>')
                self.pyslip.PlaceLayerBelowLayer(self.sel_point_view_layer,
                                                 self.point_view_layer)

        return True

##### map-relative image layer

    def imageOnOff(self, event):
        """Handle OnOff event for map-relative image layer control."""

        if event.state:
            self.image_layer = \
                self.pyslip.AddImageLayer(ImageData, map_rel=True,
                                          visible=True,
                                          show_levels=MRImageShowLevels,
                                          name='<image_layer>')
        else:
            self.pyslip.DeleteLayer(self.image_layer)
            self.image_layer = None
            if self.sel_image_layer:
                self.pyslip.DeleteLayer(self.sel_image_layer)
                self.sel_image_layer = None
                self.sel_image = None

    def imageShowOnOff(self, event):
        """Handle ShowOnOff event for image layer control."""

        if event.state:
            self.pyslip.ShowLayer(self.image_layer)
            if self.sel_image_layer:
                self.pyslip.ShowLayer(self.sel_image_layer)
        else:
            self.pyslip.HideLayer(self.image_layer)
            if self.sel_image_layer:
                self.pyslip.HideLayer(self.sel_image_layer)

    def imageSelectOnOff(self, event):
        """Handle SelectOnOff event for image layer control."""

        layer = self.image_layer
        if event.state:
            self.add_select_handler(layer, self.imageSelect)
            self.pyslip.SetLayerSelectable(layer, True)
        else:
            self.del_select_handler(layer)
            self.pyslip.SetLayerSelectable(layer, False)

    def imageSelect(self, event):
        """Select event from pyslip."""

        point = event.point

        if event.evtype == pyslip.EventPointSelect:
            if point == self.sel_image:
                # select again, turn point off
                self.sel_image = None
                self.pyslip.DeleteLayer(self.sel_image_layer)
                self.sel_image_layer = None
            elif point:
                if self.sel_image_layer:
                    self.pyslip.DeleteLayer(self.sel_image_layer)
                self.sel_image = point
                self.sel_image_layer = \
                    self.pyslip.AddPointLayer((point,), map_rel=True,
                                              color='#0000ff',
                                              radius=5, visible=True,
                                              show_levels=[3,4],
                                              name='<sel_pt_layer>')
        elif event.evtype == pyslip.EventBoxSelect:
            # remove any previous selection
            if self.sel_image_layer:
                self.pyslip.DeleteLayer(self.sel_image_layer)
                self.sel_image_layer = None

            if point:
                self.sel_image_layer = \
                    self.pyslip.AddPointLayer(point, map_rel=True,
                                              color='#00ffff',
                                              radius=5, visible=True,
                                              show_levels=[3,4],
                                              name='<boxsel_pt_layer>')
                self.pyslip.PlaceLayerBelowLayer(self.sel_image_layer,
                                                 self.image_layer)

        return True

    def imageBSelect(self, id, points=None):
        """Select event from pyslip."""

        # remove any previous selection
        if self.sel_image_layer:
            self.pyslip.DeleteLayer(self.sel_image_layer)
            self.sel_image_layer = None

        if points:
            self.sel_image_layer = \
                self.pyslip.AddPointLayer(points, map_rel=True,
                                          color='#e0e0e0',
                                          radius=13, visible=True,
                                          show_levels=[3,4],
                                          name='<boxsel_img_layer>')
            self.pyslip.PlaceLayerBelowLayer(self.sel_image_layer,
                                             self.image_layer)

        return True

##### view-relative image layer

    def imageViewOnOff(self, event):
        """Handle OnOff event for view-relative image layer control."""

        if event.state:
            self.image_view_layer = \
                self.pyslip.AddImageLayer(ImageViewData, map_rel=False,
                                          visible=True,
                                          name='<image_view_layer>')
        else:
            self.pyslip.DeleteLayer(self.image_view_layer)
            self.image_view_layer = None
            if self.sel_image_view_layer:
                self.pyslip.DeleteLayer(self.sel_image_view_layer)
                self.sel_image_view_layer = None
                self.sel_image_view_point = None

    def imageViewShowOnOff(self, event):
        """Handle ShowOnOff event for image layer control."""

        if event.state:
            self.pyslip.ShowLayer(self.image_view_layer)
            if self.sel_image_view_layer:
                self.pyslip.ShowLayer(self.sel_image_layer)
        else:
            self.pyslip.HideLayer(self.image_view_layer)
            if self.sel_image_view_layer:
                self.pyslip.HideLayer(self.sel_image_layer)

    def imageViewSelectOnOff(self, event):
        """Handle SelectOnOff event for image layer control."""

        layer = self.image_view_layer
        if event.state:
            self.add_select_handler(layer, self.imageViewSelect)
            self.pyslip.SetLayerSelectable(layer, True)
        else:
            self.del_select_handler(layer)
            self.pyslip.SetLayerSelectable(layer, False)

    def imageViewSelect(self, id, posn=None):
        """View-relative image select event from pyslip."""

        if posn:
            for p in ImageViewData:
                pp = (p[0], p[1])
                if pp == posn:
                    if pp == self.sel_image_view:
                        # select again, turn point off
                        self.sel_image_view = None
                        self.pyslip.DeleteLayer(self.sel_image_view_layer)
                        self.sel_image_view_layer = None
                    else:
                        if self.sel_image_view_layer:
                            self.pyslip.DeleteLayer(self.sel_image_view_layer)
                        self.sel_image_view = pp
                        self.sel_image_view_layer = \
                            self.pyslip.AddPointLayer((pp,), map_rel=False,
                                                      color='#00ffff',
                                                      radius=5, visible=True,
                                                      name='<sel_image_view>')
        return True

##### map-relative text layer

    def textOnOff(self, event):
        """Handle OnOff event for map-relative text layer control."""

        if event.state:
            self.text_layer = \
                self.pyslip.AddTextLayer(TextData, map_rel=True,
                                         name='<text_layer>', visible=True,
                                         show_levels=MRTextShowLevels,
                                         placement='ne')
        else:
            self.pyslip.DeleteLayer(self.text_layer)
            self.text_layer = None
            if self.sel_text_layer:
                self.pyslip.DeleteLayer(self.sel_text_layer)
                self.sel_text_layer = None
                self.sel_text_point = None

    def textShowOnOff(self, event):
        """Handle ShowOnOff event for text layer control."""

        if event.state:
            self.pyslip.ShowLayer(self.text_layer)
            if self.sel_text_layer:
                self.pyslip.ShowLayer(self.sel_text_layer)
        else:
            self.pyslip.HideLayer(self.text_layer)
            if self.sel_text_layer:
                self.pyslip.HideLayer(self.sel_text_layer)

    def textSelectOnOff(self, event):
        """Handle SelectOnOff event for text layer control."""

        layer = self.text_layer
        if event.state:
            self.add_select_handler(layer, self.textSelect)
            self.pyslip.SetLayerSelectable(layer, True)
        else:
            self.del_select_handler(layer)
            self.pyslip.SetLayerSelectable(layer, False)


    def textSelect(self, event):
        """Map-relative text select event from pyslip."""

        if event.evtype == pyslip.EventPointSelect:
            if event.point:
                (point, data) = event.point
            if event.point is None or point == self.sel_text:
                # select again, turn point off
                self.sel_text = None
                self.pyslip.DeleteLayer(self.sel_text_layer)
                self.sel_text_layer = None
            elif point:
                if self.sel_text_layer:
                    self.pyslip.DeleteLayer(self.sel_text_layer)
                self.sel_text = point
                self.sel_text_layer = \
                    self.pyslip.AddPointLayer((point,), map_rel=True,
                                              color='#0000ff',
                                              radius=5, visible=True,
                                              show_levels=MRTextShowLevels,
                                              name='<sel_text_layer>')
                self.pyslip.PlaceLayerBelowLayer(self.sel_text_layer,
                                                 self.text_layer)
        if event.evtype == pyslip.EventBoxSelect: # left box select
            # remove any previous selection
            if self.sel_text_layer:
                self.pyslip.DeleteLayer(self.sel_text_layer)
                self.sel_text_layer = None

            if event.point:
                pts = [pt for (pt,d) in event.point]
                self.sel_text_layer = \
                    self.pyslip.AddPointLayer(pts, map_rel=True,
                                              color='#00ffff',
                                              radius=5, visible=True,
                                              show_levels=[3,4],
                                              name='<boxsel_text_layer>')
                self.pyslip.PlaceLayerBelowLayer(self.sel_text_layer,
                                                 self.text_layer)

        return True

##### view-relative text layer

    def textViewOnOff(self, event):
        """Handle OnOff event for map-relative text layer control."""

        if event.state:
            self.text_view_layer = \
                self.pyslip.AddTextLayer(TextViewData, map_rel=False,
                                         name='<text_view_layer>',
                                         placement='cn', visible=True,
                                         fontsize=24, textcolor='#0000ff')
        else:
            self.pyslip.DeleteLayer(self.text_view_layer)
            self.text_view_layer = None
            if self.sel_text_view_layer:
                self.pyslip.DeleteLayer(self.sel_text_view_layer)
                self.sel_text_view_layer = None
                self.sel_text_view_point = None

    def textViewShowOnOff(self, event):
        """Handle ShowOnOff event for text layer control."""

        if event.state:
            self.pyslip.ShowLayer(self.text_view_layer)
            if self.sel_text_view_layer:
                self.pyslip.ShowLayer(self.sel_text_view_layer)
        else:
            self.pyslip.HideLayer(self.text_view_layer)
            if self.sel_text_view_layer:
                self.pyslip.HideLayer(self.sel_text_view_layer)

    def textViewSelectOnOff(self, event):
        """Handle SelectOnOff event for text layer control."""

        layer = self.text_view_layer
        if event.state:
            self.add_select_handler(layer, self.textViewSelect)
            self.pyslip.SetLayerSelectable(layer, True)
        else:
            self.del_select_handler(layer)
            self.pyslip.SetLayerSelectable(layer, False)

    def textViewSelect(self, event):
        """Map-relative text select event from pyslip."""

#        if posn:
#            for p in TextData:
#                pp = (p[0], p[1])
#                if pp == posn:
#                    if pp == self.sel_view_text:
#                        # select again, turn point off
#                        self.sel_view_text = None
#                        self.pyslip.DeleteLayer(self.sel_text_view_layer)
#                        self.sel_text_view_layer = None
#                    else:
#                        if self.sel_text_view_layer:
#                            self.pyslip.DeleteLayer(self.sel_text_view_layer)
#                        self.sel_view_text = pp
#                        self.sel_text_view_layer = \
#                            self.pyslip.AddPointLayer((pp,), map_rel=True,
#                                                      color='#80ffff',
#                                                      radius=5, visible=True,
#                                                      name='<sel_text>')
#        return True

        if event.evtype == pyslip.EventPointSelect:
            if event.point:
                (point, data) = event.point
            if event.point is None or point == self.sel_text_view:
                # select again, turn point off
                self.sel_text_view = None
                self.pyslip.DeleteLayer(self.sel_text_view_layer)
                self.sel_text_view_layer = None
            elif point:
                if self.sel_text_view_layer:
                    self.pyslip.DeleteLayer(self.sel_text_view_layer)
                self.sel_text_view = point
                self.sel_text_view_layer = \
                    self.pyslip.AddPointLayer((point,), map_rel=True,
                                              color='#80ffff',
                                              radius=5, visible=True,
                                              show_levels=MRTextShowLevels,
                                              name='<sel_text_view_layer>')
        elif event.evtype == pyslip.EventRightPointSelect:    # right point select
            pass
        if event.evtype == pyslip.EventBoxSelect: # left box select
            # remove any previous selection
            if self.sel_text_view_layer:
                self.pyslip.DeleteLayer(self.sel_text_view_layer)
                self.sel_text_view_layer = None

            if event.point:
                pts = [pt for (pt,d) in event.point]
                self.sel_text_view_layer = \
                    self.pyslip.AddPointLayer(pts, map_rel=True,
                                              color='#00ffff',
                                              radius=5, visible=True,
                                              show_levels=[3,4],
                                              name='<boxsel_text_view_layer>')
                self.pyslip.PlaceLayerBelowLayer(self.sel_text_view_layer,
                                                 self.text_view_layer)
        else:   # right box select
            pass

        return True

##### map-relative polygon layer

    def polyOnOff(self, event):
        """Handle OnOff event for map-relative polygon layer control."""

        if event.state:
            self.poly_layer = \
                self.pyslip.AddPolygonLayer(PolyData, map_rel=True,
                                            visible=True,
                                            show_levels=MRPolyShowLevels,
                                            name='<poly_layer>')
        else:
            self.pyslip.DeleteLayer(self.poly_layer)
            self.poly_layer = None
            if self.sel_poly_layer:
                self.pyslip.DeleteLayer(self.sel_poly_layer)
                self.sel_poly_layer = None
                self.sel_poly_point = None

    def polyShowOnOff(self, event):
        """Handle ShowOnOff event for polygon layer control."""

        if event.state:
            self.pyslip.ShowLayer(self.poly_layer)
            if self.sel_poly_layer:
                self.pyslip.ShowLayer(self.sel_poly_layer)
        else:
            self.pyslip.HideLayer(self.poly_layer)
            if self.sel_poly_layer:
                self.pyslip.HideLayer(self.sel_poly_layer)

    def polySelectOnOff(self, event):
        """Handle SelectOnOff event for polygon layer control."""

        layer = self.poly_layer
        if event.state:
            self.add_select_handler(layer, self.polySelect)
            self.pyslip.SetLayerSelectable(layer, True)
        else:
            self.del_select_handler(layer)
            self.pyslip.SetLayerSelectable(layer, False)

    def polySelect(self, event):
        """Map-relative polygon select event from pyslip.

        event  the pyslip event which has attributes:
                   evtype    the event type
                   layer_id  ID of the layer selected
                   point     iterable of poly points, can be None
                   mposn     map-relative position of mouse-click
                   vposn     view-relative position of mouse-click
        """

        poly = event.point

        if event.evtype == pyslip.EventPointSelect:
            if poly:
                if poly == self.sel_poly:
                    # polygon selected again, turn selection off
                    self.sel_poly = None
                    self.pyslip.DeleteLayer(self.sel_poly_layer)
                    self.sel_poly_layer = None
                else:
                    # new selection
                    if self.sel_poly_layer:
                        # deselect previously selected poly
                        self.pyslip.DeleteLayer(self.sel_poly_layer)
                    self.sel_poly = poly
                    self.sel_poly_layer = \
                        self.pyslip.AddPointLayer(poly, map_rel=True,
                                                  color='#ff00ff',
                                                  radius=9, visible=True,
                                                  show_levels=[3,4],
                                                  name='<sel_poly>')
        else:   # box select, not yet implemented
            pass

        return True

##### view-relative polygon layer

    def polyViewOnOff(self, event):
        """Handle OnOff event for map-relative polygon layer control."""

        if event.state:
            self.poly_view_layer = \
                self.pyslip.AddPolygonLayer(PolyViewData, map_rel=False,
                                            name='<poly_view_layer>',
                                            placement='cn', visible=True,
                                            fontsize=24, color='#0000ff')
        else:
            self.pyslip.DeleteLayer(self.poly_view_layer)
            self.poly_view_layer = None
            if self.sel_poly_view_layer:
                self.pyslip.DeleteLayer(self.sel_poly_view_layer)
                self.sel_poly_view_layer = None
                self.sel_poly_view_point = None

    def polyViewShowOnOff(self, event):
        """Handle ShowOnOff event for polygon layer control."""

        if event.state:
            self.pyslip.ShowLayer(self.poly_view_layer)
            if self.sel_poly_view_layer:
                self.pyslip.ShowLayer(self.sel_poly_view_layer)
        else:
            self.pyslip.HideLayer(self.poly_view_layer)
            if self.sel_poly_view_layer:
                self.pyslip.HideLayer(self.sel_poly_view_layer)

    def polyViewSelectOnOff(self, event):
        """Handle SelectOnOff event for polygon layer control."""

        layer = self.poly_view_layer
        if event.state:
            self.add_select_handler(layer, self.polyViewSelect)
            self.pyslip.SetLayerSelectable(layer, True)
        else:
            self.del_select_handler(layer)
            self.pyslip.SetLayerSelectable(layer, False)

    def polyViewSelect(self, id, posn=None):
        """View-relative polygon select event from pyslip."""

        if posn:
            for p in PolyData:
                pp = (p[0], p[1])
                if pp == posn:
                    if pp == self.sel_view_poly:
                        # select again, turn polygon off
                        self.view_sel_poly = None
                        self.pyslip.DeleteLayer(self.sel_poly_view_layer)
                        self.sel_poly_view_layer = None
                    else:
                        if self.sel_poly_view_layer:
                            self.pyslip.DeleteLayer(self.sel_poly_view_layer)
                        self.view_sel_poly = pp
                        self.sel_poly_view_layer = \
                            self.pyslip.AddPointLayer((pp,), map_rel=True,
                                                      color='#80ffff',
                                                      radius=5, visible=True,
                                                      name='<sel_polyv>')
        return True

    ######
    # Finish initialization of data, etc
    ######
    def init_image_viewer(self):
        self.pyslip.GotoLevelAndPosition(InitViewLevel, InitViewPosition)


    def init(self):
        global PointData, PointDataColour
        global PointViewData, PointViewDataColour
        global ImageData
        global ImageViewData
        global TextData # , TextDataColour
        global TextViewData
        global PolyData
        global PolyViewData

        # create PointData
        PointData = []
        count = 0
        for lon in range(-70, 290+1, 5):
            for lat in range(-65, 65+1, 5):
                PointData.append((lon, lat, {'data': count}))
                count += 1
        PointDataColour = '#ff000080'   # semi-transparent

        # create PointViewData - a point-rendition of 'PYSLIP'
        PointViewData = [(-66,-14),(-66,-13),(-66,-12),(-66,-11),(-66,-10),
                         (-66,-9),(-66,-8),(-66,-7),(-66,-6),(-66,-5),(-66,-4),
                         (-66,-3),(-65,-7),(-64,-7),(-63,-7),(-62,-7),(-61,-8),
                         (-60,-9),(-60,-10),(-60,-11),(-60,-12),(-61,-13),
                         (-62,-14),(-63,-14),(-64,-14),(65,-14),            # P
                         (-59,-14),(-58,-13),(-57,-12),(-56,-11),(-55,-10),
                         (-53,-10),(-52,-11),(-51,-12),(-50,-13),(-49,-14),
                         (-54,-9),(-54,-8),(-54,-7),(-54,-6),(-54,-5),
                         (-54,-4),(-54,-3),                                 # Y
                         (-41,-13),(-42,-14),(-43,-14),(-44,-14),(-45,-14),
                         (-46,-14),(-47,-13),(-48,-12),(-48,-11),(-47,-10),
                         (-46,-9),(-45,-9),(-44,-9),(-43,-9),(-42,-8),
                         (-41,-7),(-41,-6),(-41,-5),(-42,-4),(-43,-3),
                         (-44,-3),(-45,-3),(-46,-3),(-47,-3),(-48,-4),       # S
                         (-39,-14),(-39,-13),(-39,-12),(-39,-11),(-39,-10),
                         (-39,-9),(-39,-8),(-39,-7),(-39,-6),(-39,-5),
                         (-39,-4),(-39,-3),(-38,-3),(-37,-3),(-36,-3),
                         (-35,-3),(-34,-3),(-33,-3),(-32,-3),                # L
                         (-29,-14),(-29,-13),(-29,-12),
                         (-29,-11),(-29,-10),(-29,-9),(-29,-8),(-29,-7),
                         (-29,-6),(-29,-5),(-29,-4),(-29,-3),                # I
                         (-26,-14),(-26,-13),(-26,-12),(-26,-11),(-26,-10),
                         (-26,-9),(-26,-8),(-26,-7),(-26,-6),(-26,-5),(-26,-4),
                         (-26,-3),(-25,-7),(-24,-7),(-23,-7),(-22,-7),(-21,-8),
                         (-20,-9),(-20,-10),(-20,-11),(-20,-12),(-21,-13),
                         (-22,-14),(-23,-14),(-24,-14),(25,-14)]             # P
        PointViewDataColour = '#00ff0020'       # very transparent

        # create image data
        ImageData = [# Agnes Napier - 1855
                     (160.0, -30.0, ShipImg, {'placement': 'cc'}),
                     # Venus - 1826
                     (145.0, -11.0, ShipImg, {'placement': 'ne'}),
                     # Wolverine - 1879
                     (156.0, -23.0, ShipImg, {'placement': 'nw'}),
                     # Thomas Day - 1884
                     (150.0, -15.0, ShipImg, {'placement': 'sw'}),
                     # Sybil - 1902
                     (165.0, -19.0, ShipImg, {'placement': 'se'}),
                     # Prince of Denmark - 1863
                     (158.55, -19.98, ShipImg),
                     # Moltke - 1911
                     (146.867525, -19.152185, ShipImg)
                    ]
        ImageData2 = []
        ImageData3 = []
        ImageData4 = []
        ImageData5 = []
        ImageData6 = []
        self.map_level_2_img = {0: ImageData2,
                                1: ImageData3,
                                2: ImageData4,
                                3: ImageData5,
                                4: ImageData6}
        self.map_level_2_selimg = {0: SelGlassyImg2,
                                   1: SelGlassyImg3,
                                   2: SelGlassyImg4,
                                   3: SelGlassyImg5,
                                   4: SelGlassyImg6}
        self.current_layer_img_layer = None
        for x in range(80):
            for y in range(40):
                ImageData.append((-30+x*2, y*2-30, GlassyImg4))

        ImageViewData = [(0, 0, CompassRoseGraphic, {'placement': 'ne'})]

        text_placement = {'placement': 'se'}
        transparent_placement = {'placement': 'se', 'colour': '#00000040'}
        capital = {'placement': 'se', 'fontsize': 14, 'color': 'red',
                   'textcolour': 'red'}
        TextData = [(151.20, -33.85, 'Sydney', text_placement),
                    (144.95, -37.84, 'Melbourne', {'placement': 'ce'}),
                    (153.08, -27.48, 'Brisbane', text_placement),
                    (115.86, -31.96, 'Perth', transparent_placement),
                    (138.30, -35.52, 'Adelaide', text_placement),
                    (130.98, -12.61, 'Darwin', text_placement),
                    (147.31, -42.96, 'Hobart', text_placement),
                    (174.75, -36.80, 'Auckland', text_placement),
                    (174.75, -41.29, 'Wellington', capital),
                    (172.61, -43.51, 'Christchurch', text_placement),
                    (168.74, -45.01, 'Queenstown', text_placement),
                    (147.30, -09.41, 'Port Moresby', capital),
                    (106.822922, -6.185451, 'Jakarta', capital),
                    (110.364444, -7.801389, 'Yogyakarta', text_placement),
                    (120.966667, 14.563333, 'Manila', capital),
                    (271.74, +40.11, 'Champaign', text_placement),
                    (160.0, -30.0, 'Agnes Napier - 1855',
                        {'placement': 'cw', 'offset_x': 20, 'color': 'green'}),
                    (145.0, -11.0, 'Venus - 1826',
                        {'placement': 'sw', 'color': 'green'}),
                    (156.0, -23.0, 'Wolverine - 1879',
                        {'placement': 'ce', 'color': 'green'}),
                    (150.0, -15.0, 'Thomas Day - 1884',
                        {'color': 'green'}),
                    (165.0, -19.0, 'Sybil - 1902',
                        {'placement': 'cw', 'color': 'green'}),
                    (158.55, -19.98, 'Prince of Denmark - 1863',
                        {'placement': 'nw', 'offset_x': 20, 'color': 'green'}),
                    (146.867525, -19.152182, 'Moltke - 1911',
                        {'placement': 'ce', 'offset_x': 20, 'color': 'green'})
                   ]
        if sys.platform != 'win32':
            TextData.extend([
                    (106.36, +10.36, 'M Tho', {'placement': 'ne'}),
                    (105.85, +21.033333, 'H Ni', capital),
                    (106.681944, 10.769444, 'Thnh ph H Ch Minh', {'placement': 'sw'}),
                    (132.47, +34.44, ' (Hiroshima City)', text_placement),
                    (114.158889, +22.278333, ' (Hong Kong)', {'placement': 'nw'}),
                    ( 96.16, +16.80, ' (Yangon)', capital),
                    (104.93, +11.54, '  (Phnom Penh)',
                        {'placement': 'ce', 'fontsize': 12, 'color': 'red'}),
                    (100.49, +13.75, ' (Bangkok)', capital),
                    ( 77.56, +34.09, '(Leh)', text_placement),
                    (84.991275, 24.695102, ' (Bodh Gaya)', text_placement)])
#        TextDataColour = '#ffffff40'

        TextViewData = [(0, 7, '%s %s' % (DemoName, DemoVersion))]

        PolyData = [(((150,10),(160,20),(170,10),(165,0),(155,0)),
                      {'width': 3, 'color': 'blue', 'closed': True}),
                    (((165,-35),(175,-35),(175,-45),(165,-45)),
                      {'width': 10, 'color': '#00ff00c0', 'filled': True,
                       'fillcolor': '#ffff0040'}),
                    (((190,-30),(220,-50),(220,-30),(190,-50)),
                      {'width': 3, 'color': 'green', 'filled': True,
                       'fillcolor': 'yellow'}),
                    (((190,+50),(220,+65),(220,+50),(190,+65)),
                      {'width': 10, 'color': '#00000040'})
                   ]

        PolyViewData = [(((0,0),(230,0),(230,40),(-230,40),(-230,0)),
                        {'width': 3, 'color': '#00ff00ff', 'closed': True,
                         'placement': 'cn', 'offset_y': 1})]

        # set initial view position
        self.pyslip.GotoLevelAndPosition(InitViewLevel, InitViewPosition)
        self.map_level.SetLabel('%d' % InitViewLevel)

        # define layer ID variables & sub-checkbox state variables
        self.point_layer = None
        self.sel_point_layer = None
        self.sel_point = None

        self.point_view_layer = None
        self.sel_point_view_layer = None
        self.sel_point_view = None

        self.image_layer = None
        self.sel_image_layer = None
        self.sel_image = None

        self.image_view_layer = None
        self.sel_image_view_layer = None
        self.sel_image_view = None

        self.text_layer = None
        self.sel_text_layer = None
        self.sel_text = None

        self.text_view_layer = None
        self.sel_text_view_layer = None
        self.sel_view_text = None

        self.poly_layer = None
        self.sel_poly_layer = None
        self.sel_poly = None

        self.poly_view_layer = None
        self.sel_poly_view_layer = None
        self.sel_poly = None

        # force pyslip initialisation
        self.pyslip.OnSize()

    ######
    # Exception handlers
    ######

    def handle_select_event(self, event):
        """Handle a pySlip point/box SELECT event."""

        layer_id = event.layer_id
        #point = event.point

        self.demo_select_dispatch.get(layer_id, self.null_handler)(event)

    def null_handler(self, event):
        """Routine to handle unexpected events."""

        print('ERROR: null_handler!?')

    def handle_position_event(self, event):
        """Handle a pySlip POSITION event."""

        posn_str = ''
        if event.position:
            (lon, lat) = event.position
            posn_str = ('%.*f / %.*f'
                        % (LonLatPrecision, lon, LonLatPrecision, lat))
            fast_picture, slow_picture = \
              self.pyslip.tiles.lon_lat_to_picture_fast_slow(lon,lat)

            posn_str = ("Picture:  slow=%.*f / fast=%.*f pixels."
                        % (LonLatPrecision, slow_picture,
                           LonLatPrecision, fast_picture))
            coords = self.pyslip.tiles.get_flex_pixel_coordinates(lon,lat)
            if (len(coords) >= 2):
                if len(coords) == 3:
                    readout = int(round(coords[2]))
                else:
                    readout = -1

                coords_str = ("slow=%.*f / fast=%.*f pixels"
                              % (LonLatPrecision, coords[0],
                                 LonLatPrecision, coords[1]))
                if (len(coords) == 2):
                    posn_str += " Readout: " + coords_str +"."
                elif (readout >= 0):
                    posn_str += " Readout %d: %s." % (readout, coords_str)

                possible_intensity = None
                fi = self.pyslip.tiles.raw_image
                detector = fi.get_detector()
                ifs = (int(coords[1]), int(coords[0])) # int fast slow
                isf = (int(coords[0]), int(coords[1])) # int slow fast
                raw_data = fi.get_raw_data()
                if not isinstance(raw_data, tuple):
                  raw_data = (raw_data,)
                if len(detector) > 1:
                  if readout >= 0:
                    if detector[readout].is_coord_valid(ifs):
                        possible_intensity = raw_data[readout][isf]
                else:
                  if detector[0].is_coord_valid(ifs):
                      possible_intensity = raw_data[0][isf]

                if possible_intensity is not None:
                    if possible_intensity == 0:
                      format_str = " I=%6.4f"
                    else:
                      import math
                      yaya = int(math.ceil(math.log10(abs(possible_intensity))))
                      format_str = " I=%%6.%df"%(max(0,5-yaya))
                    posn_str += format_str%possible_intensity

                if (len(coords) > 2 and readout >= 0): # indicates it's a tiled image in a valid region
                    reso = self.pyslip.tiles.get_resolution(coords[1], coords[0], readout)
                else:
                    reso = self.pyslip.tiles.get_resolution(coords[1], coords[0])

                if reso is not None:
                    posn_str += " Resolution: %.3f"%(reso)

            self.statusbar.SetStatusText(posn_str)
        else:
            self.statusbar.SetStatusText("Click and drag to pan; "+
        "middle-click and drag to plot intensity profile, right-click to zoom")
            #print "event with no position",event
        return
        self.mouse_position.SetValue(posn_str)

    def handle_level_change(self, event):
        """Handle a pySlip LEVEL event."""
        pass
        return
        self.map_level.SetLabel('%d' % event.level)

    ######
    # Handle adding/removing select handler functions.
    ######

    def add_select_handler(self, id, handler):
        """Add handler for select in layer 'id'."""

        self.demo_select_dispatch[id] = handler

    def del_select_handler(self, id):
        """Remove handler for select in layer 'id'."""

        del self.demo_select_dispatch[id]

################################################################################

def run_demo():

    # start wxPython app
    app = wx.App()
    app_frame = AppFrame(tile_dir =
       "/Users/nksauter/xtalsoft/pyslip/pyslip-read-only/tiles")
    app_frame.Show()

##    import wx.lib.inspection
##    wx.lib.inspection.InspectionTool().Show()

    app.MainLoop()


 *******************************************************************************


 *******************************************************************************
rstbx/slip_viewer/slip_viewer_image_factory.py
from __future__ import absolute_import, division, print_function
import iotbx.detectors

# store default ImageFactory function
defaultImageFactory = iotbx.detectors.ImageFactory

def SlipViewerImageFactory(filename):
  try:
    return NpyImageFactory(filename)
  except Exception as e:
    return defaultImageFactory(filename)

# Use the dxtbx class as it handles all possible variance of NPY images
def NpyImageFactory(filename):
  from dxtbx.format.FormatPYunspecified import FormatPYunspecified
  img = FormatPYunspecified(filename)
  return img.get_detectorbase()


 *******************************************************************************


 *******************************************************************************
rstbx/slip_viewer/tile_generation.py
# -*- mode: python; coding: utf-8; indent-tabs-mode: nil; python-indent: 2 -*-
#
# $Id$

from __future__ import absolute_import, division, print_function
from six.moves import range

import math
import wx

######
# Base class for a tile object - handles access to tiles.
######
'''Jan '12 ... make it so the rstbx widget actually zooms in DONE
           ... draggable area large enough for whole image DONE
           ... remove the dependency on map tile library geological DONE
           ... provide cache  DONE
           ... put in negative zoom levels  DONE
           ... tighten up the flex image  -- refactor  DONE
           ... connect the open filename command line option to the tile generator DONE
           ... check in the code so far.  Put most of it in cxi xdr xes DONE
           ... provide cache invalidation DONE
           ... give mechanism to change brightness; color scheme
'''

def _get_flex_image(
    data, vendortype, binning=1, brightness=1.0, saturation=65535.0,
    show_untrusted=False, color_scheme=0):
  # This is a combination of the get_data_type() and get_flex_image()
  # functions from iotbx.detectors.detectorbase.  XXX This may turn
  # out to be generally useful (see
  # e.g. rstbx.viewer.create_flex_image()), but where to place it?
  # dxtbx Format class?
  typehash = str(data.__class__)
  if typehash.find('int') >= 0:
    from iotbx.detectors import FlexImage
  elif typehash.find('double') >= 0:
    from iotbx.detectors import FlexImage_d as FlexImage

  return FlexImage(
    binning=binning,
    brightness=brightness,
    rawdata=data,
    saturation=int(round(saturation)),
    vendortype=vendortype,
    show_untrusted=show_untrusted,
    color_scheme=color_scheme
  )


def _get_flex_image_multipanel(panels, raw_data, beam, brightness=1.0,
                               binning=1, show_untrusted=False, color_scheme=0):
  # From serialtbx.detector.legacy_metrology.cspad_detector.readHeader() and
  # serialtbx.detector.legacy_metrology.cspad_detector.get_flex_image().  XXX Is it possible to
  # merge this with _get_flex_image() above?  XXX Move to dxtbx Format
  # class (or a superclass for multipanel images)?

  from math import ceil

  from iotbx.detectors import generic_flex_image
  from libtbx.test_utils import approx_equal
  from scitbx.array_family import flex
  from scitbx.matrix import col, rec, sqr
  from serialtbx.detector.legacy_metrology.metrology import get_projection_matrix

  assert len(panels) == len(raw_data), (len(panels), len(raw_data))

  # Determine next multiple of eight of the largest panel size.
  data_max_focus = None
  for data in raw_data:
      if data_max_focus is None:
          data_max_focus = data.focus()
      else:
          data_max_focus = (
              max(data_max_focus[0], data.focus()[0]),
              max(data_max_focus[1], data.focus()[1]),
          )
  data_padded = (
      8 * int(ceil(data_max_focus[0] / 8)),
      8 * int(ceil(data_max_focus[1] / 8)),
  )

  # Assert that all saturated values are equal and not None.  While
  # dxtbx records a separated trusted_range for each panel,
  # generic_flex_image supports only accepts a single common value for
  # the saturation.
  saturation = None
  for panel in panels:
      if saturation is None:
          saturation = panel.get_trusted_range()[1]
      else:
          assert approx_equal(saturation, panel.get_trusted_range()[1])
  assert saturation is not None

  # Create rawdata and my_flex_image before populating it.
  rawdata = flex.double(
    flex.grid(len(panels) * data_padded[0], data_padded[1]))
  my_flex_image = generic_flex_image(
    rawdata=rawdata,
    binning=binning,
    size1_readout=data_max_focus[0],
    size2_readout=data_max_focus[1],
    brightness=brightness,
    saturation=saturation,
    show_untrusted=show_untrusted,
    color_scheme=color_scheme
  )

  # Calculate the average beam center across all panels, in meters
  # not sure this makes sense for detector which is not on a plane?
  beam_center = col((0, 0, 0))
  npanels = 0
  for panel in panels:
    try:
      beam_center += col(panel.get_beam_centre_lab(beam.get_s0()))
      npanels += 1
    except RuntimeError as e: # catch DXTBX_ASSERT for no intersection
      pass
  beam_center /= (npanels / 1e-3)

  # XXX If a point is contained in two panels simultaneously, it will
  # be assigned to the panel defined first.  XXX Use a Z-buffer
  # instead?
  for i in range(len(panels)):
    # Determine the pixel size for the panel (in meters), as pixel
    # sizes need not be identical.
    data = raw_data[i]
    panel = panels[i]
    pixel_size = (panel.get_pixel_size()[0] * 1e-3,
                  panel.get_pixel_size()[1] * 1e-3)

    if len(panels) == 24 and panels[0].get_image_size() == (2463,195):
      rawdata.matrix_paste_block_in_place(
        block=data.as_double(),
        i_row=i * data_padded[0],
        i_column=0)
      # XXX hardcoded panel height and row gap
      my_flex_image.add_transformation_and_translation((1,0,0,1),
                                                       (-i*(195+17),0))

      continue

    elif len(panels) == 120 and panels[0].get_image_size() == (487,195):
      i_row = i // 5
      i_col = i % 5
      rawdata.matrix_paste_block_in_place(
        block=data.as_double(),
        i_row=i * data_padded[0],
        i_column=0)
      # XXX hardcoded panel height and row gap
      my_flex_image.add_transformation_and_translation(
        (1,0,0,1), (-i_row*(195+17),-i_col*(487+7)))

      continue

    # Get unit vectors in the fast and slow directions, as well as the
    # the locations of the origin and the center of the panel, in
    # meters. The origin is taken w.r.t. to average beam center of all
    # panels. This avoids excessive translations that can result from
    # rotations around the laboratory origin. Related to beam centre above
    # and dials#380 not sure this is right for detectors which are not
    # coplanar since system derived from first panel...
    fast = col(panel.get_fast_axis())
    slow = col(panel.get_slow_axis())
    origin = col(panel.get_origin()) * 1e-3  - beam_center

    center = origin \
             + (data.focus()[0] - 1) / 2 * pixel_size[1] * slow \
             + (data.focus()[1] - 1) / 2 * pixel_size[0] * fast
    normal = slow.cross(fast).normalize()

    # Determine rotational and translational components of the
    # homogeneous transformation that maps the readout indices to the
    # three-dimensional laboratory frame.
    Rf = sqr((  fast(0, 0),   fast(1, 0),   fast(2, 0),
               -slow(0, 0),  -slow(1, 0),  -slow(2, 0),
              normal(0, 0), normal(1, 0), normal(2, 0)))
    tf = -Rf * center
    Tf = sqr((Rf(0, 0), Rf(0, 1), Rf(0, 2), tf(0, 0),
              Rf(1, 0), Rf(1, 1), Rf(1, 2), tf(1, 0),
              Rf(2, 0), Rf(2, 1), Rf(2, 2), tf(2, 0),
              0,        0,        0,        1))

    # E maps picture coordinates onto metric Cartesian coordinates,
    # i.e. [row, column, 1 ] -> [x, y, z, 1].  Both frames share the
    # same origin, but the first coordinate of the screen coordinate
    # system increases downwards, while the second increases towards
    # the right.  XXX Is this orthographic projection the only one
    # that makes any sense?
    E = rec(elems=[0, +pixel_size[1], 0,
                   -pixel_size[0], 0, 0,
                   0, 0, 0,
                   0, 0, 1],
            n=[4, 3])

    # P: [x, y, z, 1] -> [row, column, 1].  Note that data.focus()
    # needs to be flipped to give (horizontal, vertical) size,
    # i.e. (width, height).
    Pf = get_projection_matrix(
      pixel_size, (data.focus()[1], data.focus()[0]))[0]

    rawdata.matrix_paste_block_in_place(
      block=data.as_double(),
      i_row=i * data_padded[0],
      i_column=0)

    # Last row of T is always [0, 0, 0, 1].
    T = Pf * Tf * E
    R = sqr((T(0, 0), T(0, 1),
             T(1, 0), T(1, 1)))
    t = col((T(0, 2), T(1, 2)))
    my_flex_image.add_transformation_and_translation(R, t)
  my_flex_image.followup_brightness_scale()
  return my_flex_image


class _Tiles(object):
    # maximum number of tiles held in each level cache
    MaxTileList = 512

    def __init__(self, filename):
        (self.tile_size_x, self.tile_size_y) = (256,256)
        self.levels = [-3,-2,-1,0,1,2,3,4,5]

        # set min and max tile levels
        self.min_level = -3
        self.max_level = 5
        self.extent = (-180.0, 180., -166.66 , 166.66) #longitude & latitude limits
        self.set_image(filename)
        self.current_brightness = 1.0
        self.current_color_scheme = 0
        self.user_requests_antialiasing = False

        self.show_untrusted = False

    def set_image(self, file_name_or_data, metrology_matrices=None, get_raw_data=None):

        self.reset_the_cache()
        if file_name_or_data is None:
          self.raw_image = None
          return
        if type(file_name_or_data) is type(""):
          from iotbx.detectors import ImageFactory
          self.raw_image = ImageFactory(file_name_or_data)
          self.raw_image.read()
        else:
          try:
            self.raw_image = file_name_or_data._raw
          except AttributeError:
            self.raw_image = file_name_or_data
        #print "SETTING NEW IMAGE",self.raw_image.filename

        # XXX Since there doesn't seem to be a good way to refresh the
        # image (yet), the metrology has to be applied here, and not
        # in frame.py.

        detector = self.raw_image.get_detector()

        if len(detector) > 1 and metrology_matrices is not None:
          self.raw_image.apply_metrology_from_matrices(metrology_matrices)

        if get_raw_data is not None:
          self.raw_image.set_raw_data(get_raw_data(self.raw_image))
        raw_data = self.raw_image.get_raw_data()
        if not isinstance(raw_data, tuple):
          raw_data = (raw_data,)

        if len(detector) > 1:
          self.flex_image = _get_flex_image_multipanel(
            brightness=self.current_brightness / 100,
            panels=detector,
            show_untrusted=self.show_untrusted,
            raw_data=raw_data,
            beam = self.raw_image.get_beam(),
            color_scheme=self.current_color_scheme)
        else:
          self.flex_image = _get_flex_image(
            brightness=self.current_brightness / 100,
            data=raw_data[0],
            saturation=self.raw_image.get_detector()[0].get_trusted_range()[1],
            vendortype=self.raw_image.get_vendortype(),
            show_untrusted=self.show_untrusted,
            color_scheme=self.current_color_scheme
          )

        if self.zoom_level >= 0:
          self.flex_image.adjust(color_scheme=self.current_color_scheme)

    def set_image_data(self, raw_image_data):
      self.reset_the_cache()
      # XXX Since there doesn't seem to be a good way to refresh the
      # image (yet), the metrology has to be applied here, and not
      # in frame.py.

      detector = self.raw_image.get_detector()
      self.raw_image.set_raw_data(raw_image_data)
      if len(detector) == 1 and len(raw_image_data) == 1:
        raw_image_data = raw_image_data[0]

      if len(detector) > 1:
        self.flex_image = _get_flex_image_multipanel(
          brightness=self.current_brightness / 100,
          panels=detector,
          raw_data=raw_image_data,
          beam = self.raw_image.get_beam())
      else:
        self.flex_image = _get_flex_image(
          brightness=self.current_brightness / 100,
          data=raw_image_data,
          saturation=self.raw_image.get_detector()[0].get_trusted_range()[1],
          vendortype=self.raw_image.get_vendortype(),
          show_untrusted=self.show_untrusted
        )

      self.flex_image.adjust(color_scheme=self.current_color_scheme)

    def update_brightness(self,b,color_scheme=0):
        raw_data = self.raw_image.get_raw_data()
        if not isinstance(raw_data, tuple):
          raw_data = (raw_data,)

        if len(self.raw_image.get_detector()) > 1:
          # XXX Special-case read of new-style images until multitile
          # images are fully supported in dxtbx.
          self.flex_image = _get_flex_image_multipanel(
            brightness=b / 100,
            panels=self.raw_image.get_detector(),
            show_untrusted=self.show_untrusted,
            raw_data=raw_data,
            beam=self.raw_image.get_beam(),
            color_scheme=color_scheme)
        else:
          self.flex_image = _get_flex_image(
            brightness=b / 100,
            data=raw_data[0],
            saturation=self.raw_image.get_detector()[0].get_trusted_range()[1],
            vendortype=self.raw_image.get_vendortype(),
            show_untrusted=self.show_untrusted,
            color_scheme=color_scheme
          )

        self.reset_the_cache()
        self.UseLevel(self.zoom_level)
        self.current_color_scheme = color_scheme
        self.current_brightness = b
        self.flex_image.adjust(color_scheme)

    def update_color_scheme(self,color_scheme=0):
        self.flex_image.adjust(color_scheme)
        self.reset_the_cache()
        self.UseLevel(self.zoom_level)
        self.current_color_scheme = color_scheme

    def reset_the_cache(self):

        # setup the tile caches and Least Recently Used lists
        self.cache = {}
        self.lru = {}
        for l in self.levels:
            self.cache[l] = {}
            self.lru[l] = []

    def flex_image_get_tile(self,x,y):
      # The supports_rotated_tiles_antialiasing_recommended flag in
      # the C++ FlexImage class indicates whether the underlying image
      # instance supports tilted readouts.  Anti-aliasing only makes
      # sense if it does.
      if self.raw_image is not None and \
        self.zoom_level >=2 and \
        self.flex_image.supports_rotated_tiles_antialiasing_recommended and \
        self.user_requests_antialiasing:
        # much more computationally intensive to prepare nice-looking pictures of tilted readout
        self.flex_image.setZoom(self.zoom_level+1)
        fraction = 512./self.flex_image.size1()/(2**(self.zoom_level+1))
        self.flex_image.setWindowCart(  y, x, fraction )
        self.flex_image.prep_string()
        w,h = self.flex_image.ex_size2(), self.flex_image.ex_size1()
        assert w==512
        assert h==512
        wx_image = wx.EmptyImage(w/2,h/2)
        try:
          import PIL.Image as Image
        except ImportError:
          import Image
        try:
          I = Image.fromstring("RGB",(512,512),self.flex_image.export_string)
        except NotImplementedError:
          I = Image.frombytes("RGB",(512,512),self.flex_image.export_string)
        J = I.resize((256,256),Image.ANTIALIAS)
        wx_image.SetData(J.tostring())
        return wx_image.ConvertToBitmap()
      elif self.raw_image is not None:
        self.flex_image.setZoom(self.zoom_level)
        fraction = 256./self.flex_image.size1()/(2**self.zoom_level)
        self.flex_image.setWindowCart(  y, x, fraction )
        self.flex_image.prep_string()
        w,h = self.flex_image.ex_size2(), self.flex_image.ex_size1()
        assert w==256
        assert h==256
        wx_image = wx.EmptyImage(w,h)
        wx_image.SetData(self.flex_image.export_string)
        return wx_image.ConvertToBitmap()
      else:
        wx_image = wx.EmptyImage(256,256)
        return wx_image.ConvertToBitmap()

    def get_binning(self):
      if self.zoom_level>=0: return 1.
      return 2.**-self.zoom_level

    def UseLevel(self, n):
        """Prepare to serve tiles from the required level.

        n  The required level

        Returns a tuple (map_width, map_height, ppd_x, ppd_y) if successful,
        else None.  The width/height values are pixels.  The ppd_? values are
        pixels-per-degree values for X and Y direction.
        """
        # try to get cache for this level, no cache means no level
        #print "IN USE LEVEL",n
        try:
            self.tile_cache = self.cache[n]
            self.tile_list = self.lru[n]
        except KeyError:
            return None
        self.zoom_level = n
        if self.raw_image is None: #dummy values if there is no image
          self.center_x_lon = self.center_y_lat = 500.
          return (1024,1024,1.,1.)
        self.num_tiles_x = int(math.ceil((self.flex_image.size1()*(2**self.zoom_level))/256.))
        self.num_tiles_y = int(math.ceil((self.flex_image.size2()*(2**self.zoom_level))/256.))
        self.ppd_x = 2.**self.zoom_level
        self.ppd_y = 2.**self.zoom_level
        #print "USELEVEL %d # tiles: %d %d"%(n,self.num_tiles_x,self.num_tiles_y)
        #print "USELEVEL %d returning"%n,(self.tile_size_x * self.num_tiles_x,
        #        self.tile_size_y * self.num_tiles_y,
        #        self.ppd_x, self.ppd_y)
        # The longitude & latitude coordinates at the image center:
        self.center_x_lon = self.extent[0] + (1./self.ppd_x) * (0 +
          self.flex_image.size2() * (2**self.zoom_level) / 2.
          )
        self.center_y_lat = self.extent[3] - (1./self.ppd_y) * (0 +
          self.flex_image.size1() * (2**self.zoom_level) / 2.
          )
        # The 2+num_tiles is just a trick to get PySlip to think the map is
        # slightly larger, allowing zoom level -3 to be properly framed:
        # ....for larger display sizes it is necessary to increase this...
        # ....can tile_generator get the display size & figure it out?
        return (self.tile_size_x * (2+self.num_tiles_x),
                self.tile_size_y * (2+self.num_tiles_y),
                self.ppd_x, self.ppd_y)

    def get_initial_instrument_centering_within_picture_as_lon_lat(self):
      import sys
      detector = self.raw_image.get_detector()
      if sys.platform.lower().find("linux") >= 0:
        if len(detector) > 1:
          return 0.,0.
        else:
          return self.center_x_lon-self.extent[0], self.center_y_lat-self.extent[3]
      else:
        if len(detector) > 1:
          return self.extent[0], self.extent[3]
        else:
          return self.center_x_lon, self.center_y_lat

    def GetTile(self, x, y):
        #from libtbx.development.timers import Timer
        #T = Timer("get tile")
        """Get bitmap for tile at tile coords (x, y).

        x  X coord of tile required (tile coordinates)
        y  Y coord of tile required (tile coordinates)

        Returns bitmap object containing the tile image.
        Tile coordinates are measured from map top-left.
        """
        try:
            # if tile in cache, return it from there
            pic = self.tile_cache[(x, y)]
            index = self.tile_list.index((x, y))
            del self.tile_list[index]
        except KeyError:
            pic = self.flex_image_get_tile(x,y)
            self.tile_cache[(x, y)] = pic

        self.tile_list.insert(0, (x, y))
        if len(self.tile_cache)>=self.MaxTileList:
          del self.tile_cache[self.tile_list[-1]]
          del self.tile_list[-1]
        return pic

    def get_flex_pixel_coordinates(self, lon, lat):
      fast_picture_coord_pixel_scale, slow_picture_coord_pixel_scale = \
        self.lon_lat_to_picture_fast_slow(lon,lat)
      if self.flex_image.supports_rotated_tiles_antialiasing_recommended: # for generic_flex_image
        tilted = self.flex_image.picture_to_readout(
          slow_picture_coord_pixel_scale,fast_picture_coord_pixel_scale)
        return tilted
      else: # standard flex_image
        return slow_picture_coord_pixel_scale,fast_picture_coord_pixel_scale

    def lon_lat_to_picture_fast_slow(self,longitude,latitude):
      # input latitude and longitude in degrees (conceptually)
      # output fast and slow picture coordinates in units of detector pixels
      # slow is pointing down (x).  fast is pointing right (y).

      detector = self.raw_image.get_detector()
      if len(detector) == 1:
        (size2, size1) = detector[0].get_image_size()
      else:
        # XXX Special-case until multitile detectors fully supported.
        (size1, size2) = (self.flex_image.size1(), self.flex_image.size2())

      return \
        (size2/2.) - (self.center_x_lon - longitude),  \
        (size1/2.) - (latitude - self.center_y_lat)

    def picture_fast_slow_to_lon_lat(self,pic_fast_pixel,pic_slow_pixel):
      # inverse of the preceding function

      detector = self.raw_image.get_detector()
      if detector.num_panels() == 1:
        (size1, size2) = detector.get_image_size()
      else:
        # XXX Special-case until multitile detectors fully supported.
        (size1, size2) = (self.flex_image.size1(), self.flex_image.size2())

      return \
        (size2/2.) - self.center_x_lon - pic_fast_pixel, \
        (size1/2.) + self.center_y_lat - pic_slow_pixel

    def picture_fast_slow_to_map_relative(self,pic_fast_pixel,pic_slow_pixel):
      #return up/down, left/right map relative coords for pyslip layers
      return pic_fast_pixel+self.extent[0],-pic_slow_pixel+self.extent[3]

    def map_relative_to_picture_fast_slow(self, map_rel_vert, map_rel_horiz):
      # return fast, slow picture coords
      return map_rel_vert-self.extent[0],-map_rel_horiz+self.extent[3]

    def vec_picture_fast_slow_to_map_relative(self,vector):
      value = []
      for vec in vector:
        value.append(self.picture_fast_slow_to_map_relative(vec[0],vec[1]))
      return value

    def get_spotfinder_data(self, params):

      pointdata = []
      test_pattern = False
      if test_pattern is True and self.raw_image.__class__.__name__.find("CSPadDetector") >= 0:
        key_count = -1
        for key, asic in self.raw_image._tiles.iteritems():
          key_count += 1
          focus = asic.focus()
          for slow in range(0,focus[0],20):
            for fast in range(0,focus[1],20):
              slowpic,fastpic = self.flex_image.tile_readout_to_picture(key_count,slow,fast)
              mr1,mr2 = self.picture_fast_slow_to_map_relative(fastpic,slowpic)
              pointdata.append((mr1,mr2,{"data":key}))

      elif (self.raw_image.__class__.__name__.find("CSPadDetector") >= 0):
        from cxi_xdr_xes.cftbx.spotfinder.speckfinder import spotfind_readout

        key_count = -1
        for key, asic in self.raw_image._tiles.iteritems():
          key_count += 1
          indexing = spotfind_readout(
              readout=asic,
              peripheral_margin=params.spotfinder.peripheral_margin)

          for spot in indexing:
            slow = int(round(spot[0]))
            fast = int(round(spot[1]))

            slowpic,fastpic = self.flex_image.tile_readout_to_picture(key_count,slow,fast)
            mr1,mr2 = self.picture_fast_slow_to_map_relative(fastpic,slowpic)
            pointdata.append((mr1,mr2,{"data":key}))

      else:
        from spotfinder.command_line.signal_strength import master_params
        working_params = master_params.fetch(sources = []) #placeholder for runtime mods
        working_params.show(expert_level=1)
        distl_params = working_params.extract()

        spotfinder,frameno = self.raw_image.get_spotfinder(distl_params)
        spots = spotfinder.images[frameno]["spots_total"]
        for spot in spots:
          mr = self.picture_fast_slow_to_map_relative(
              spot.max_pxl_y() + 0.5, spot.max_pxl_x() + 0.5)
#             spot.ctr_mass_y() + 0.5, spot.ctr_mass_x() + 0.5)
          pointdata.append(mr)
      return pointdata

    def get_effective_tiling_data(self, params):
      box_data = []
      text_data = []
      if hasattr(self.raw_image, 'get_tile_manager'):
        IT = self.raw_image.get_tile_manager(params).effective_tiling_as_flex_int()
        for i in range(len(IT) // 4):
          tile = IT[4*i:4*i+4]
          attributes = {'color': '#0000FFA0', 'width': 1, 'closed': False}
          box_data.append(
              ((self.picture_fast_slow_to_map_relative(tile[1], tile[0]),
                self.picture_fast_slow_to_map_relative(tile[1], tile[2])),
               attributes))
          box_data.append(
              ((self.picture_fast_slow_to_map_relative(tile[1], tile[0]),
                self.picture_fast_slow_to_map_relative(tile[3], tile[0])),
               attributes))
          box_data.append(
              ((self.picture_fast_slow_to_map_relative(tile[1], tile[2]),
                self.picture_fast_slow_to_map_relative(tile[3], tile[2])),
               attributes))
          box_data.append(
              ((self.picture_fast_slow_to_map_relative(tile[3], tile[0]),
                self.picture_fast_slow_to_map_relative(tile[3], tile[2])),
               attributes))
          txt_x, txt_y = self.picture_fast_slow_to_map_relative(
              (tile[1]+tile[3])//2, (tile[0]+tile[2])//2)
          text_data.append((txt_x, txt_y, "%i" %i))
      return box_data, text_data

    def get_resolution(self, x, y, readout=None):
        """
        Determine the resolution of a pixel.
        Arguments are in image pixel coordinates (starting from 1,1).
        """

        d_min = None
        detector = self.raw_image.get_detector()
        beam = self.raw_image.get_beam()
        if detector is None or beam is None:
          return None
        beam = beam.get_s0()

        if len(detector) > 1:
          if readout is None:
            return None

          panel = detector[readout]

        else:
          panel = detector[0]

        if abs(panel.get_distance()) > 0:
          return panel.get_resolution_at_pixel(beam, (x, y))
        else:
          return None

    def get_detector_distance(self):
        detector = self.raw_image.get_detector()
        if len(detector) == 1:
          dist = abs(detector[0].get_distance())
        else:
          # XXX Special-case until multitile detectors fully
          # supported.
          dist = self.raw_image.distance
        twotheta = self.get_detector_2theta()
        if (twotheta == 0.0):
            return dist
        else :
            return dist / math.cos(twotheta)

    def get_detector_2theta(self):
        from scitbx.matrix import col

        detector = self.raw_image.get_detector()
        if len(detector) == 1:
          n = col(detector[0].get_normal())
          s0 = col(self.raw_image.get_beam().get_unit_s0())
          two_theta = s0.angle(n, deg=False)
        else:
          # XXX Special-case until multitile detectors fully
          # supported.
          try:
            two_theta = self.raw_image.twotheta * math.pi / 180
          except AttributeError:
            two_theta = 0

        return two_theta


 *******************************************************************************


 *******************************************************************************
rstbx/slip_viewer/uc_frame.py
from __future__ import absolute_import, division, print_function
# -*- Mode: Python; c-basic-offset: 2; indent-tabs-mode: nil; tab-width: 8 -*-
#
# $Id

import wx, math

class UCSettingsFrame(wx.MiniFrame):
  def __init__(self, *args, **kwds):
    super(UCSettingsFrame, self).__init__(*args, **kwds)
    szr = wx.BoxSizer(wx.VERTICAL)
    self.phil_params = args[0].params
    panel = UCSettingsPanel(self)
    self.SetSizer(szr)
    szr.Add(panel, 1, wx.EXPAND)
    szr.Fit(panel)
    self.panel = panel
    self.sizer = szr
    self.Fit()
    self.Bind(wx.EVT_CLOSE, lambda evt : self.Destroy(), self)


class UCSettingsPanel(wx.Panel):
  def __init__(self, *args, **kwds):
    super(UCSettingsPanel, self).__init__(*args, **kwds)

    self.phil_params = args[0].phil_params
    from wx.lib.agw.floatspin import EVT_FLOATSPIN, FloatSpin

    # Needed to draw and delete the rings.  XXX Applies to
    # calibration_frame as well?
    self._pyslip = self.GetParent().GetParent().pyslip

    sizer = wx.BoxSizer(wx.VERTICAL)
    self.SetSizer(sizer)

    # Number of decimal digits for distances.
    self.digits = 2

    # Wavelength control.
    beam = self._pyslip.tiles.raw_image.get_beam()
    self._wavelength = beam.get_wavelength()

    # Unit cell controls.
    if self.phil_params.calibrate_unitcell.unitcell is not None:
      self._cell = list(self.phil_params.calibrate_unitcell.unitcell.parameters())
    else:
      self._cell = [4.18,4.72,58.38,89.44,89.63,75.85]

    if self.phil_params.calibrate_unitcell.spacegroup is not None:
      self._spacegroup = self.phil_params.calibrate_unitcell.spacegroup
    else:
      self._spacegroup = "P1"

    self._cell_control_names = ["uc_a_ctrl","uc_b_ctrl","uc_c_ctrl",
                                "uc_alpha_ctrl","uc_beta_ctrl","uc_gamma_ctrl"]

    box = wx.BoxSizer(wx.HORIZONTAL)

    self.uc_a = FloatSpin(
      self, digits=self.digits, name=self._cell_control_names[0], value=self._cell[0])
    box.Add(self.uc_a,
            0, wx.RIGHT | wx.TOP | wx.BOTTOM | wx.ALIGN_CENTER_VERTICAL, 5)
    box.Add(wx.StaticText(self, label="a"),
            0, wx.ALL | wx.ALIGN_CENTER_VERTICAL, 5)
    self.Bind(EVT_FLOATSPIN, self.OnSpinCell, self.uc_a)

    self.uc_alpha = FloatSpin(
      self, digits=self.digits, name=self._cell_control_names[3], value=self._cell[3])
    box.Add(self.uc_alpha,
            0, wx.RIGHT | wx.TOP | wx.BOTTOM | wx.ALIGN_CENTER_VERTICAL, 5)
    box.Add(wx.StaticText(self, label="alpha"),
            0, wx.ALL | wx.ALIGN_CENTER_VERTICAL, 5)
    self.Bind(EVT_FLOATSPIN, self.OnSpinCell, self.uc_alpha)

    sizer.Add(box)


    box = wx.BoxSizer(wx.HORIZONTAL)

    self.uc_b = FloatSpin(
      self, digits=self.digits, name=self._cell_control_names[1], value=self._cell[1])
    box.Add(self.uc_b,
            0, wx.RIGHT | wx.TOP | wx.BOTTOM | wx.ALIGN_CENTER_VERTICAL, 5)
    box.Add(wx.StaticText(self, label="b"),
            0, wx.ALL | wx.ALIGN_CENTER_VERTICAL, 5)
    self.Bind(EVT_FLOATSPIN, self.OnSpinCell, self.uc_b)

    self.uc_beta = FloatSpin(
      self, digits=self.digits, name=self._cell_control_names[4], value=self._cell[4])
    box.Add(self.uc_beta,
            0, wx.RIGHT | wx.TOP | wx.BOTTOM | wx.ALIGN_CENTER_VERTICAL, 5)
    box.Add(wx.StaticText(self, label="beta"),
            0, wx.ALL | wx.ALIGN_CENTER_VERTICAL, 5)
    self.Bind(EVT_FLOATSPIN, self.OnSpinCell, self.uc_beta)

    sizer.Add(box)


    box = wx.BoxSizer(wx.HORIZONTAL)

    self.uc_c = FloatSpin(
      self, digits=self.digits, name=self._cell_control_names[2], value=self._cell[2])
    box.Add(self.uc_c,
            0, wx.RIGHT | wx.TOP | wx.BOTTOM | wx.ALIGN_CENTER_VERTICAL, 5)
    box.Add(wx.StaticText(self, label="c"),
            0, wx.ALL | wx.ALIGN_CENTER_VERTICAL, 5)
    self.Bind(EVT_FLOATSPIN, self.OnSpinCell, self.uc_c)

    self.uc_gamma = FloatSpin(
      self, digits=self.digits, name=self._cell_control_names[5], value=self._cell[5])
    box.Add(self.uc_gamma,
            0, wx.RIGHT | wx.TOP | wx.BOTTOM | wx.ALIGN_CENTER_VERTICAL, 5)
    box.Add(wx.StaticText(self, label="gamma"),
            0, wx.ALL | wx.ALIGN_CENTER_VERTICAL, 5)
    self.Bind(EVT_FLOATSPIN, self.OnSpinCell, self.uc_gamma)

    sizer.Add(box)

    # Space group control
    box = wx.BoxSizer(wx.HORIZONTAL)

    self.space_group_ctrl =  wx.TextCtrl(
      self, name="space group", value=self._spacegroup)
    box.Add(self.space_group_ctrl,
            0, wx.RIGHT | wx.TOP | wx.BOTTOM | wx.ALIGN_CENTER_VERTICAL, 5)
    box.Add(wx.StaticText(self, label="Space group"),
            0, wx.ALL | wx.ALIGN_CENTER_VERTICAL, 5)
    self.Bind(wx.EVT_TEXT, self.OnSpaceGroup, self.space_group_ctrl)

    sizer.Add(box)


    # Distance control
    img = self.GetParent().GetParent()._img
    box = wx.BoxSizer(wx.HORIZONTAL)
    self.distance_ctrl = FloatSpin(
          self, digits=self.digits, name="Detector Distance", value=img.get_detector_distance())
    self.distance_ctrl.SetIncrement(0.5)
    box.Add(self.distance_ctrl,
            0, wx.RIGHT | wx.TOP | wx.BOTTOM | wx.ALIGN_CENTER_VERTICAL, 5)

    txtd = wx.StaticText(self, label="Detector Distance")
    box.Add(txtd, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
    self.Bind(EVT_FLOATSPIN, self.OnSpin, self.distance_ctrl)
    sizer.Add(box)

    # Wavelength control
    img = self.GetParent().GetParent()._img
    box = wx.BoxSizer(wx.HORIZONTAL)
    self.wavelength_ctrl = FloatSpin(
          self, digits=4, name="Wavelength", value=img.get_wavelength())
    self.wavelength_ctrl.SetIncrement(0.05)
    box.Add(self.wavelength_ctrl,
            0, wx.RIGHT | wx.TOP | wx.BOTTOM | wx.ALIGN_CENTER_VERTICAL, 5)

    txtw = wx.StaticText(self, label="Wavelength")
    box.Add(txtw, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
    self.Bind(EVT_FLOATSPIN, self.OnSpin, self.wavelength_ctrl)
    sizer.Add(box)


    # d_min control
    if self.phil_params.calibrate_unitcell.d_min is not None:
      self.d_min = self.phil_params.calibrate_unitcell.d_min
    else:
      self.d_min = 3.5
    box = wx.BoxSizer(wx.HORIZONTAL)
    self.d_min_ctrl = FloatSpin(
          self, digits=self.digits, name="d_min", value=self.d_min)
    box.Add(self.d_min_ctrl,
            0, wx.RIGHT | wx.TOP | wx.BOTTOM | wx.ALIGN_CENTER_VERTICAL, 5)

    txtd = wx.StaticText(self, label="Highest resolution for ring display")
    box.Add(txtd, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
    self.Bind(EVT_FLOATSPIN, self.OnSpin, self.d_min_ctrl)
    sizer.Add(box)


    # Centering controls.
    self._center = [0, 0]
    box = wx.BoxSizer(wx.HORIZONTAL)

    self.spinner_fast = FloatSpin(
      self, digits=self.digits, name="fast_ctrl", value=self._center[0])
    box.Add(self.spinner_fast,
            0, wx.RIGHT | wx.TOP | wx.BOTTOM | wx.ALIGN_CENTER_VERTICAL, 5)
    box.Add(wx.StaticText(self, label="Center fast"),
            0, wx.ALL | wx.ALIGN_CENTER_VERTICAL, 5)
    self.Bind(EVT_FLOATSPIN, self.OnSpinCenter, self.spinner_fast)

    self.spinner_slow = FloatSpin(
      self, digits=self.digits, name="slow_ctrl", value=self._center[1])
    box.Add(self.spinner_slow,
            0, wx.RIGHT | wx.TOP | wx.BOTTOM | wx.ALIGN_CENTER_VERTICAL, 5)
    box.Add(wx.StaticText(self, label="Center slow"),
            0, wx.ALL | wx.ALIGN_CENTER_VERTICAL, 5)
    self.Bind(EVT_FLOATSPIN, self.OnSpinCenter, self.spinner_slow)

    sizer.Add(box)

    self.DrawRings()


  def __del__(self):
    if (hasattr(self, "_ring_layer") and self._ring_layer is not None):
      self._pyslip.DeleteLayer(self._ring_layer)


  def OnSpinCenter(self, event):
    obj = event.EventObject
    name = obj.GetName()

    if (name == "fast_ctrl"):
      self._center[0] = obj.GetValue()
    elif (name == "slow_ctrl"):
      self._center[1] = obj.GetValue()

    self.DrawRings()


  def OnSpinCell(self, event):
    obj = event.EventObject
    name = obj.GetName()

    self._cell[self._cell_control_names.index(name)] = obj.GetValue()

    self.DrawRings()


  def OnSpin(self, event):
    self.DrawRings()


  def OnSpaceGroup(self, event):
    obj = event.EventObject
    self._spacegroup = obj.GetValue()

    self.DrawRings()


  def _draw_rings_layer(self, dc, data, map_rel):
    """Draw a points layer.

    dc       the device context to draw on
    data     an iterable of point tuples:
             (x, y, place, radius, colour, x_off, y_off, pdata)
    map_rel  points relative to map if True, MUST BE TRUE for lightweight
    Assumes all points are the same colour, saving 100's of ms.
    """

    assert map_rel is True
    if len(data)==0:
      return
    (lon, lat, place, radius, colour, x_off, y_off, pdata) = data[0]

    scale = 2**self._pyslip.tiles.zoom_level

    # Draw points on map/view, using transparency if implemented.
    try:
      dc = wx.GCDC(dc)
    except NotImplementedError:
      pass
    dc.SetPen(wx.Pen(colour))
    dc.SetBrush(wx.Brush(colour, wx.TRANSPARENT))
    for (lon, lat, place, radius, colour, x_off, y_off, pdata) in data:
      (x, y) = self._pyslip.ConvertGeo2View((lon, lat))
      dc.DrawCircle(x, y, radius * scale)


  def DrawRings(self):
    from cctbx.crystal import symmetry
    import cctbx.miller

    frame = self.GetParent().GetParent()

    try:
      uc = symmetry(unit_cell=self._cell, space_group_symbol=str(self._spacegroup))
      hkl_list = cctbx.miller.build_set(uc, False, d_min=self.d_min_ctrl.GetValue())
    except Exception as e:
      frame.update_statusbar(str(e))
      return

    frame.update_statusbar("%d %d %d %d %d %d, "%tuple(self._cell) + "number of indices: %d"%len(hkl_list.indices()))

    spacings = list(hkl_list.d_spacings())
    print("Printing spacings, len: %s"%len(spacings))

    def cmp(a,b):
      if a[1] > b[1]: return 1
      elif a[1] < b[1]: return -1
      return 0

    spacings = sorted(spacings, cmp=cmp, reverse=True)

    for d in spacings:
      print(d)

    detector = self._pyslip.tiles.raw_image.get_detector()
    beam     = self._pyslip.tiles.raw_image.get_beam()

    wavelength = float(self.wavelength_ctrl.GetValue())
    distance = float(self.distance_ctrl.GetValue())
    pixel_size = detector[0].get_pixel_size()[0] # FIXME assumes square pixels, and that all panels use same pixel size

    twotheta = hkl_list.two_theta(wavelength = wavelength)
    L_mm = []
    L_pixels = []
    for tt in twotheta: L_mm.append(distance * math.tan(tt[1]))
    for lmm in L_mm: L_pixels.append(lmm/pixel_size)

    xrayframe = self.GetParent().GetParent()
    panel_id, beam_pixel_fast, beam_pixel_slow = xrayframe.get_beam_center_px()

    if len(detector) > 1:
      beam_pixel_slow, beam_pixel_fast = xrayframe.pyslip.tiles.flex_image.tile_readout_to_picture(
        panel_id, beam_pixel_slow - 0.5, beam_pixel_fast - 0.5)

    center = self._pyslip.tiles.picture_fast_slow_to_map_relative(
      beam_pixel_fast + self._center[0], beam_pixel_slow + self._center[1])

    # XXX Transparency?
    ring_data = [(center[0], center[1], {"colour": "red", "radius": pxl}) for pxl in L_pixels]

    # Remove the old ring layer, and draw a new one.
    if (hasattr(self, "_ring_layer") and self._ring_layer is not None):
      self._pyslip.DeleteLayer(self._ring_layer)
      self._ring_layer = None
    self._ring_layer = self._pyslip.AddPointLayer(
      ring_data,
      map_rel=True,
      visible=True,
      show_levels=[-3, -2, -1, 0, 1, 2, 3, 4, 5],
      renderer=self._draw_rings_layer,
      name="<ring_layer>")


 *******************************************************************************
