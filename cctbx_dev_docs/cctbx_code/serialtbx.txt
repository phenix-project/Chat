

 *******************************************************************************
serialtbx/__init__.py


 *******************************************************************************


 *******************************************************************************
serialtbx/detector/__init__.py
from __future__ import division
from scitbx import matrix

def center(coords):
  """ Returns the average of a list of vectors
  @param coords List of vectors to return the center of
  """
  for c in coords:
    if 'avg' not in locals():
      avg = c
    else:
      avg += c
  return avg / len(coords)

class basis(object):
  """ Bucket for detector element information """
  def __init__(self, orientation = None, translation = None, panelgroup = None, homogenous_transformation = None, name = None):
    """
    Provide only orientation + translation or a panelgroup or a homogenous_transformation.

    @param orientation rotation in the form of a quarternion
    @param translation vector translation in relation to the parent frame
    @param panelgroup dxtbx panelgroup object whose local d matrix will represent the
    basis shift
    @param homogenous_transformation 4x4 matrix.sqr object representing a translation
    and a rotation. Must not also contain a scale as this won't be decomposed properly.
    @param name optional name for this basis shift
    """
    self.include_translation = True
    self.name = name

    if panelgroup is not None:
      d_mat = panelgroup.get_local_d_matrix()
      fast = matrix.col((d_mat[0],d_mat[3],d_mat[6])).normalize()
      slow = matrix.col((d_mat[1],d_mat[4],d_mat[7])).normalize()
      orig = matrix.col((d_mat[2],d_mat[5],d_mat[8]))

      v3 = fast.cross(slow).normalize()

      r3 = matrix.sqr((fast[0],slow[0],v3[0],
                       fast[1],slow[1],v3[1],
                       fast[2],slow[2],v3[2]))

      self.orientation = r3.r3_rotation_matrix_as_unit_quaternion()
      self.translation = orig

      if not self.name:
        self.name = panelgroup.get_name()

    elif orientation is not None or translation is not None:
      assert orientation is not None and translation is not None
      self.orientation = orientation
      self.translation = translation

    else:
      # Decompose the homegenous transformation assuming no scale factors were used
      h = homogenous_transformation
      self.orientation = matrix.sqr((h[0],h[1],h[2],
                                     h[4],h[5],h[6],
                                     h[8],h[9],h[10])).r3_rotation_matrix_as_unit_quaternion()
      self.translation = matrix.col((h[3],
                                     h[7],
                                     h[11]))
      assert h[12] == h[13] == h[14] == 0 and h[15] == 1

  def as_homogenous_transformation(self):
    """ Returns this basis change as a 4x4 transformation matrix in homogenous coordinates"""
    r3 = self.orientation.normalize().unit_quaternion_as_r3_rotation_matrix()
    return matrix.sqr((r3[0],r3[1],r3[2],self.translation[0],
                       r3[3],r3[4],r3[5],self.translation[1],
                       r3[6],r3[7],r3[8],self.translation[2],
                       0,0,0,1))

  def __mul__(self, other):
    """ Use homogenous matrices to multiply bases together """
    if hasattr(other, 'as_homogenous_transformation'):
      return basis(homogenous_transformation = self.as_homogenous_transformation() * other.as_homogenous_transformation())
    elif hasattr(other, 'n'):
      if other.n == (3,1):
        b = matrix.col((other[0], other[1], other[2], 1))
      elif other.n == (4,1):
        b = other
      else:
        raise TypeError(b, "Incompatible matrices")
      p = self.as_homogenous_transformation() * b
      if other.n == (3,1):
        return matrix.col(p[0:3])
      else:
        return p
    else:
      raise TypeError(b)

def iterate_detector_at_level(item, depth = 0, level = 0):
  """
  Iterate through all panel groups or panels of a detector object at a given
  hierarchy level
  @param item panel group or panel. Use detector.hierarchy().
  @param depth current dept for recursion. Should be 0 for initial call.
  @param level iterate groups at this level
  @return next panel or panel group object
  """
  if level == depth:
    yield item
  else:
    for child in item:
      for subitem in iterate_detector_at_level(child, depth+1, level):
        yield subitem

def iterate_panels(panelgroup):
  """
  Find and iterate all panels in the given panel group, regardless of the hierarchly level
  of this panelgroup
  @param panelgroup the panel group of interest
  @return the next panel
  """
  if panelgroup.is_group():
    for child in panelgroup:
      for subitem in iterate_panels(child):
        yield subitem
  else:
    yield panelgroup

def id_from_name(detector, name):
  """ Jiffy function to get the id of a panel using its name
  @param detector detector object
  @param name panel name
  @return index of panel in detector
  """
  return [p.get_name() for p in detector].index(name)

def get_center(pg):
  """ Find the center of a panel group pg, projected on its fast/slow plane """
  if pg.is_group():
    # find the average center of all this group's children
    children_center = matrix.col((0,0,0))
    count = 0
    for p in iterate_panels(pg):
      children_center += get_center(p)
      count += 1
    children_center /= count

    # project the children center onto the plane of the panel group
    pgf = matrix.col(pg.get_fast_axis())
    pgs = matrix.col(pg.get_slow_axis())
    pgn = matrix.col(pg.get_normal())
    pgo = matrix.col(pg.get_origin())

    return (pgf.dot(children_center) * pgf) + (pgs.dot(children_center) * pgs) + (pgn.dot(pgo) * pgn)
  else:
    s = pg.get_image_size()
    return matrix.col(pg.get_pixel_lab_coord((s[0]/2, s[1]/2)))


 *******************************************************************************


 *******************************************************************************
serialtbx/detector/cspad.py
from __future__ import division

from libtbx.utils import Sorry
from scitbx import matrix
from scitbx.array_family import flex
import serialtbx.util.time
import os

# The CAMP and CSpad counters are both 14 bits wide (Strüder et al
# 2010; Philipp et al., 2007), which means the physical limit is 2**14 - 1.
# However, in practice, when the pixels are in the low gain mode, after
# correcting by a gain value of around 6.87, the pixels tend to saturate
# around 90000. See xpp experiment xppe0314, run 184 as evidence.
cspad_saturated_value = 90000

# The dark average for the CSPAD detector is around 1100-1500. A pixel
# histogram of a minimum projection of an uncorrected (raw) light run shows
# a mostly flat tail up to ~800 ADU with a few bumps in the tail which
# represent true underloads. Assume a dark average of 1200 ADU. After dark
# subtraction, 800 - 1200 gives a minimum trusted value of -400. Reject
# pixels less than this.
cspad_min_trusted_value = -400

# The pixel size in mm.  The pixel size is fixed and square, with side
# length of 110 µm (Philipp et al., 2007).  XXX Should really clarify
# this with Sol and Chris.
#
# XXX Andor: 13.5 µm square, CAMP: 75 µm, square (Strüder et al.,
# 2010)
# Apr 14 2023: commenting this out and using the more accurate version below
#pixel_size = 110e-3


# need to define these here since it not defined in SLAC's metrology definitions
asic_dimension = (194,185)
asic_gap = 3
pixel_size = 0.10992

PSANA2_VERSION = 0
try:
  PSANA2_VERSION = os.environ.get('PSANA2_VERSION', 0)
except AttributeError:
  pass

from serialtbx.detector import basis, center
from serialtbx.detector.xtc import basis_from_geo

def read_slac_metrology(path = None, geometry = None, plot=False, include_asic_offset=False):
  if path is None and geometry is None:
    raise Sorry("Need to provide a geometry object or a path to a geometry file")

  if path is not None and geometry is not None:
    raise Sorry("Cannot provide a geometry object and a geometry file. Ambiguous")

  if geometry is None:
    try:
      from PSCalib.GeometryAccess import GeometryAccess
      geometry = GeometryAccess(path)
    except Exception:
      raise Sorry("Can't parse this metrology file")

  metro = {}
  pixel_size = geometry.get_pixel_scale_size()/1000
  null_ori = matrix.col((0,0,1)).axis_and_angle_as_unit_quaternion(0, deg=True)

  # collapse any transformations above those of the quadrants into one X/Y offset,
  # but don't keep Z transformations, as those come from the XTC stream
  root = geometry.get_top_geo()
  root_basis = basis_from_geo(root, use_z=False)
  while len(root.get_list_of_children()) != 4 and len(root.get_list_of_children()) != 32:
    assert len(root.get_list_of_children()) == 1
    root = root.get_list_of_children()[0]
    root_basis *= basis_from_geo(root, use_z=False)

  metro[(0,)] = root_basis



  def add_sensor(quad_id, sensor_id, sensor):
    metro[(0,quad_id,sensor_id)] = basis_from_geo(sensor)

    x, y, z = sensor.get_pixel_coords()
    x/=1000; y/=1000; z/=1000
    assert x.shape == y.shape == z.shape
    sensor_px_slow = x.shape[0]
    sensor_px_fast = x.shape[1]
    assert sensor_px_fast % 2 == 0

    a0ul = sul = matrix.col((x[0,0],y[0,0],z[0,0]))
    a1ur = sur = matrix.col((x[0,sensor_px_fast-1],y[0,sensor_px_fast-1],z[0,sensor_px_fast-1]))
    a1lr = slr = matrix.col((x[sensor_px_slow-1,sensor_px_fast-1],y[sensor_px_slow-1,sensor_px_fast-1],z[sensor_px_slow-1,sensor_px_fast-1]))
    a0ll = sll = matrix.col((x[sensor_px_slow-1,0],y[sensor_px_slow-1,0],z[sensor_px_slow-1,0]))

    a0ur = matrix.col((x[0,sensor_px_fast//2-1],y[0,sensor_px_fast//2-1],z[0,sensor_px_fast//2-1]))
    a0lr = matrix.col((x[sensor_px_slow-1,sensor_px_fast//2-1],y[sensor_px_slow-1,sensor_px_fast//2-1],z[sensor_px_slow-1,sensor_px_fast//2-1]))

    a1ul = matrix.col((x[0,sensor_px_fast//2],y[0,sensor_px_fast//2],z[0,sensor_px_fast//2]))
    a1ll = matrix.col((x[sensor_px_slow-1,sensor_px_fast//2],y[sensor_px_slow-1,sensor_px_fast//2],z[sensor_px_slow-1,sensor_px_fast//2]))

    sensor_center = center([sul,sur,slr,sll])
    asic0_center = center([a0ul,a0ur,a0lr,a0ll])
    asic1_center = center([a1ul,a1ur,a1lr,a1ll])

    asic_trans0 = (asic0_center-sensor_center).length()
    asic_trans1 = (asic1_center-sensor_center).length()

    if include_asic_offset:
      rotated_ori = matrix.col((1,0,0)).axis_and_angle_as_unit_quaternion(180.0, deg=True)
      offset_fast = -pixel_size*((sensor_px_fast) / 4) # 4 because sensor_px_fast is for sensor
      offset_slow = +pixel_size*((sensor_px_slow) / 2) # Sensor is divided into 2 only in fast direction
      metro[(0,quad_id,sensor_id,0)] = basis(orientation=rotated_ori,translation=matrix.col((-asic_trans0,0,0)))
      metro[(0,quad_id,sensor_id,1)] = basis(orientation=rotated_ori,translation=matrix.col((+asic_trans1,0,0)))
      metro[(0,quad_id,sensor_id,0)].translation += matrix.col((offset_fast, offset_slow, 0))
      metro[(0,quad_id,sensor_id,1)].translation += matrix.col((offset_fast, offset_slow, 0))
    else:
      metro[(0,quad_id,sensor_id,0)] = basis(orientation=null_ori,translation=matrix.col((-asic_trans0,0,0)))
      metro[(0,quad_id,sensor_id,1)] = basis(orientation=null_ori,translation=matrix.col((+asic_trans1,0,0)))

  if len(root.get_list_of_children()) == 4:
    for quad_id, quad in enumerate(root.get_list_of_children()):
      metro[(0,quad_id)] = basis_from_geo(quad)
      for sensor_id, sensor in enumerate(quad.get_list_of_children()):
        add_sensor(quad_id, sensor_id, sensor)
  elif len(root.get_list_of_children()) == 32:
    for quad_id in range(4):
      metro[(0,quad_id)] = basis(orientation = null_ori, translation = matrix.col((0,0,0)))
      sensors = root.get_list_of_children()
      for sensor_id in range(8):
        add_sensor(quad_id, sensor_id, sensors[quad_id*4+sensor_id])
  else:
    assert False

  return metro

def get_psana_corrected_data(psana_det, evt, use_default=False, dark=True, common_mode=None, apply_gain_mask=True,
                             gain_mask_value=None, per_pixel_gain=False, gain_mask=None, additional_gain_factor=None):
  """
  Given a psana Detector object, apply corrections as appropriate and return the data from the event
  @param psana_det psana Detector object
  @param evt psana event
  @param use_default If true, apply the default calibration only, using the psana algorithms. Otherise, use the corrections
  specified by the rest of the flags and values passed in.
  @param dark Whether to apply the detector dark, bool or numpy array
  @param common_mode Which common mode algorithm to apply. None: apply no algorithm. Default: use the algorithm specified
  in the calib folder. Otherwise should be a list as specified by the psana documentation for common mode customization
  @param apply_gain_mask Whether to apply the common mode gain mask correction
  @param gain_mask_value Multiplier to apply to the pixels, according to the gain mask
  @param per_pixel_gain If available, use the per pixel gain deployed to the calibration folder
  @param gain_mask gain mask showing which pixels to apply gain mask value
  @param additional_gain_factor Additional gain factor. Pixels counts are divided by this number after all other
  corrections.
  @return Numpy array corrected as specified.
  """
  # order is pedestals, then common mode, then gain mask, then per pixel gain
  import numpy as np

  if PSANA2_VERSION:
      # in psana2, data are stored as raw, fex, etc so the selection
      # has to be given here when the detector interface is used.
      # for now, assumes cctbx uses "raw".
      psana_det = psana_det.raw

  if use_default:
    return psana_det.calib(evt)  # applies psana's complex run-dependent calibrations
  data = psana_det.raw_data(evt)
  if data is None:
    return

  data = data.astype(np.float64)
  if isinstance(dark, bool):
    if dark:
      if PSANA2_VERSION:
        data -= psana_det.pedestals()
      else:
        data -= psana_det.pedestals(evt)
  elif isinstance( dark, np.ndarray ):
    data -= dark

  if common_mode is not None and common_mode != "default":
    if common_mode == 'cspad_default':
      common_mode = (1,25,25,100,1)  # default parameters for CSPAD images
      psana_det.common_mode_apply(data, common_mode)
    elif common_mode == 'unbonded':
      common_mode = (5,0,0,0,0)  # unbonded pixels used for correction
      psana_det.common_mode_apply(data, common_mode)
    else:  # this is how it was before.. Though I think common_mode would need to be a tuple..
      psana_det.common_mode_apply(data, common_mode)
  if apply_gain_mask:
    if gain_mask is None:  # TODO: consider try/except here
      gain_mask = psana_det.gain_mask(evt) == 1
    if gain_mask_value is None:
      try:
        gain_mask_value = psana_det._gain_mask_factor
      except AttributeError:
        print("No gain set for psana detector, using gain value of 1, consider disabling gain in your phil file")
        gain_mask_value = 1
    data[gain_mask] = data[gain_mask]*gain_mask_value
  if per_pixel_gain: # TODO: test this
    data *= psana_det.gain()
  if additional_gain_factor is not None:
    data /= additional_gain_factor
  return data





def dpack(active_areas=None,
          address=None,
          beam_center_x=None,
          beam_center_y=None,
          ccd_image_saturation=None,
          data=None,
          distance=None,
          pixel_size=pixel_size,
          saturated_value=None,
          timestamp=None,
          wavelength=None,
          xtal_target=None,
          min_trusted_value=None):
  """XXX Check completeness.  Should fill in sensible defaults."""

  # Must have data.
  if data is None:
    return None

  # Create a time stamp of the current time if none was supplied.
  if timestamp is None:
    timestamp = serialtbx.util.time.timestamp()

  # For unknown historical reasons, the dictionary must contain both
  # CCD_IMAGE_SATURATION and SATURATED_VALUE items.
  if ccd_image_saturation is None:
    if saturated_value is None:
      ccd_image_saturation = cspad_saturated_value
    else:
      ccd_image_saturation = saturated_value
  if saturated_value is None:
    saturated_value = ccd_image_saturation

  # Use a minimum value if provided for the pixel range
  if min_trusted_value is None:
    min_trusted_value = cspad_min_trusted_value

  # By default, the beam center is the center of the image.  The slow
  # (vertical) and fast (horizontal) axes correspond to x and y,
  # respectively.
  if beam_center_x is None:
    beam_center_x = pixel_size * data.focus()[1] / 2
  if beam_center_y is None:
    beam_center_y = pixel_size * data.focus()[0] / 2

  # By default, the entire detector image is an active area.  There is
  # no sensible default for distance nor wavelength.  XXX But setting
  # wavelength to zero may be disastrous?
  if active_areas is None:
    # XXX Verify order with non-square detector
    active_areas = flex.int((0, 0, data.focus()[0], data.focus()[1]))
  if distance is None:
    distance = 0
  if wavelength is None:
    wavelength = 0

  # The size must match the image dimensions.  The length along the
  # slow (vertical) axis is SIZE1, the length along the fast
  # (horizontal) axis is SIZE2.
  return {'ACTIVE_AREAS': active_areas,
          'BEAM_CENTER_X': beam_center_x,
          'BEAM_CENTER_Y': beam_center_y,
          'CCD_IMAGE_SATURATION': ccd_image_saturation,
          'DATA': data,
          'DETECTOR_ADDRESS': address,
          'DISTANCE': distance,
          'PIXEL_SIZE': pixel_size,
          'SATURATED_VALUE': saturated_value,
          'MIN_TRUSTED_VALUE': min_trusted_value,
          'SIZE1': data.focus()[0],
          'SIZE2': data.focus()[1],
          'TIMESTAMP': timestamp,
          'SEQUENCE_NUMBER': 0, # XXX Deprecated
          'WAVELENGTH': wavelength,
          'xtal_target': xtal_target}


 *******************************************************************************


 *******************************************************************************
serialtbx/detector/jungfrau.py
from __future__ import absolute_import,print_function, division
import numpy as np


def correct_panel(img, copy=True, divide=True):
  """
  Distributes the intensity in the larger Jungfrau pixels into smaller
  inserted pixels
  See: https://doi.org/10.1088/1748-0221/13/11/C11006


  Parameters
  ==========
  img: a 2D numpy of shape 512x1024

  copy: boolean, if True, copy the image, otherwise
  the input image is updated in-place (usually not desired).
  The performance hit for copy=True is negligible in most applications.
  On psana servers this function runs in ~6 ms with copy=False
  and ~7.5 ms with copy=True

  TODO: for raw jungfrau data where gain mode is stored in 2 of the 16 bits,
  # we need to carefully divide the 14-bit data by 2 for the large pixels (if we wish to use them)

  Return
  ======
  2D numpy array of shape 514x1030
  """

  if not isinstance(img, np.ndarray):
    raise TypeError("input image needs to be a numpy array")
  if img.shape != (512, 1024):
    raise ValueError("Input image needs shape 512x1024")

  if copy:
    img = img.copy()

  if divide:
    img[255]/=2
    img[256]/=2
  img2 = np.insert(img, (256, 256), values=(img[255], img[256]), axis=0).T

  if divide:
    img2[255]/=2
    img2[256]/=2
    img2[511]/=2
    img2[512]/=2
    img2[767]/=2
    img2[768]/=2

  img3 = np.insert(img2, (256, 256, 512, 512, 768, 768),
    values=(img2[255], img2[256],
            img2[511], img2[512],
            img2[767], img2[768]),
    axis=0).T
  return img3


def pad_stacked_format(raw, num_panels=32, divide=False, keep_stacked=True):
  """
  pad a raw data array that represents stacks of 512x1024 blocks
  """
  padded = [correct_panel(raw[i * 512: (i + 1) * 512], divide=divide)
                      for i in range(num_panels)]
  if keep_stacked:
    padded = np.vstack(padded)
  return padded


def get_14bit_from_jungfrau(expt):
  iset = expt.imageset
  F = iset.get_format_class()
  if len(iset.paths()) != 1:
    raise ValueError("imageset should have exactly 1 path")
  fclass = F.get_instance(iset.paths()[0])
  return fclass.get_14bit_component(iset.indices()[0])


def get_pedestalRMS_from_jungfrau(expt, gain_modes_too=False):
  iset = expt.imageset
  F = iset.get_format_class()
  if len(iset.paths()) != 1:
    raise ValueError("imageset should have exactly 1 path")
  fclass = F.get_instance(iset.paths()[0])
  return fclass.get_pedestal_rms(iset.indices()[0], return_gain_modes=gain_modes_too)


 *******************************************************************************


 *******************************************************************************
serialtbx/detector/legacy_metrology/__init__.py


 *******************************************************************************


 *******************************************************************************
serialtbx/detector/legacy_metrology/cspad_detector.py
# -*- mode: python; coding: utf-8; indent-tabs-mode: nil; python-indent: 2 -*-
#
# $Id$

from __future__ import absolute_import, division, print_function

import math

from iotbx.detectors import generic_flex_image
from libtbx import easy_pickle
from scitbx.array_family import flex
from scitbx.matrix import col, rec, sqr
from serialtbx.detector.legacy_metrology.generic_detector import GenericDetector
from six.moves import range
import six

class CSPadDetector(GenericDetector):
  def __init__(self, filename):
    self.filename = filename
    self.vendortype = "npy_raw"
    self.beamx = 0.
    self.beamy = 0.

  def __getattr__(self, attr):
    if   attr=='attenuation' : return self._metrology_params.attenuation
    elif attr=='beam_center' : return self._metrology_params.beam_center
    elif attr=='distance' : return self._metrology_params.distance
    elif attr=='pixel_size':
      # Return (square) pixel size in mm.
      assert self._pixel_size[0] == self._pixel_size[1]
      return self._pixel_size[0] * 1e3
    elif attr=='pulse_length' : return self._metrology_params.pulse_length
    elif attr=='sequence_number' : return self._metrology_params.sequence_number
    elif attr=='timestamp' : return self._metrology_params.timestamp
    elif attr=='wavelength' : return self._metrology_params.wavelength
    elif attr=='xtal_target' : return self._metrology_params.xtal_target
    else: raise AttributeError(attr)

  def readHeader(self):
    # XXX The functionality provided by this function has largely been
    # replicated in
    # rstbx.slip_viewer.tile_generation._get_flex_image_multitile().
    # However, several code paths still depend on the member variables
    # created here.

    from serialtbx.detector.legacy_metrology.metrology import metrology_as_transformation_matrices

    d = easy_pickle.load(self.filename)

    # Derive the transformation matrices from the metrology in the
    # image.
    self._metrology_params = d["METROLOGY"].extract()
    self._matrices = metrology_as_transformation_matrices(
      self._metrology_params)

    self._tiles = d["TILES"]
    self._keylist = list(self._tiles.keys()) #for later use by get_pixel_intensity()

    # Assert that all ASIC:s are the same size, and that there are
    # transformation matrices for each ASIC.
    for (key, asic) in six.iteritems(self._tiles):
      if not hasattr(self, "_asic_focus"):
        self._asic_focus = asic.focus()
      else:
        assert asic.focus() == self._asic_focus
      assert key in self._matrices

    # Assert that all specified pixel sizes and saturated values are
    # equal and not None.
    for p in self._metrology_params.detector.panel:
      for s in p.sensor:
        for a in s.asic:
          if not hasattr(self, "_pixel_size"):
            self._pixel_size = a.pixel_size
          else:
            assert self._pixel_size == a.pixel_size

          if not hasattr(self, "_saturation"):
            self._saturation = a.saturation
          else:
            # XXX real-valued equality!  See
            # cctbx_project/scitbx/math/approx_equal.h
            assert self._saturation == a.saturation
    assert hasattr(self, "_pixel_size") and self._pixel_size is not None
    assert hasattr(self, "_saturation") and self._saturation is not None

    # Determine next multiple of eight.  Set size1 and size2 to the
    # focus of the padded rawdata.
    self._asic_padded = (8 * int(math.ceil(self._asic_focus[0] / 8)),
                         8 * int(math.ceil(self._asic_focus[1] / 8)))
    self.size1 = len(self._tiles) * self._asic_padded[0]
    self.size2 = self._asic_padded[1]


  def show_header(self):
    return "CSPad detector with nothing in it"


  def read(self):
    pass


  def apply_metrology_from_matrices(self, matrices):
    """The apply_metrology_from_matrices() function replaces the
    current set of transformation matrices with that given in the
    dictionary @p matrices.

    XXX Could implement metrology "adjustment" as opposed metrology
    "replacement".
    """

    self._matrices = matrices


  def get_flex_image(self, brightness, **kwargs):
    # This functionality has migrated to
    # rstbx.slip_viewer.tile_generation._get_flex_image_multitile().
    # XXX Still used by iotbx/command_line/detector_image_as_png.py
    #raise DeprecationWarning(
    #  "serialtbx.detector.legacy_metrology.cspad_detector.get_flex_image() is deprecated")

    # no kwargs supported at present

    from serialtbx.detector.legacy_metrology.metrology import get_projection_matrix

    # E maps picture coordinates onto metric Cartesian coordinates,
    # i.e. [row, column, 1 ] -> [x, y, z, 1].  Both frames share the
    # same origin, but the first coordinate of the screen coordinate
    # system increases downwards, while the second increases towards
    # the right.  XXX Is this orthographic projection the only one
    # that makes any sense?
    E = rec(elems=[0, +self._pixel_size[1], 0,
                   -self._pixel_size[0], 0, 0,
                   0, 0, 0,
                   0, 0, 1],
            n=[4, 3])

    # P: [x, y, z, 1] -> [row, column, 1].  Note that self._asic_focus
    # needs to be flipped.
    Pf = get_projection_matrix(self._pixel_size,
                               (self._asic_focus[1], self._asic_focus[0]))[0]

    # XXX Add ASIC:s in order?  If a point is contained in two ASIC:s
    # simultaneously, it will be assigned to the ASIC defined first.
    # XXX Use a Z-buffer instead?
    nmemb = 0
    for key, asic in six.iteritems(self._tiles):
      # Create my_flex_image and rawdata on the first iteration.
      if ("rawdata" not in locals()):
        rawdata = flex.double(flex.grid(self.size1, self.size2))
        my_flex_image = generic_flex_image(
          rawdata=rawdata,
          binning=1,
          size1_readout=self._asic_focus[0],
          size2_readout=self._asic_focus[1],
          brightness=brightness,
          saturation=self._saturation)

      rawdata.matrix_paste_block_in_place(
        block=asic,
        i_row=nmemb * self._asic_padded[0],
        i_column=0)
      nmemb += 1

      # key is guaranteed to exist in self._matrices as per
      # readHeader().  Last row of self._matrices[key][0] is always
      # [0, 0, 0, 1].
      T = Pf * self._matrices[key][0] * E
      R = sqr([T(0, 0), T(0, 1),
               T(1, 0), T(1, 1)])
      t = col([T(0, 2), T(1, 2)])

      my_flex_image.add_transformation_and_translation(R, t)
    my_flex_image.followup_brightness_scale()
    return my_flex_image


  def get_panel_fast_slow(self, serial):
    """Get the average x- and y-coordinates of all the ASIC:s in the
    panel with serial @p serial.  This is done by back-transforming
    the centre's of each ASIC to the screen (sort of) coordinate
    system.  This is more robust than getting the panel positions
    directly.
    """

    from serialtbx.detector.legacy_metrology.metrology import get_projection_matrix

    center = col([self._asic_focus[0] / 2, self._asic_focus[1] / 2, 1])
    fast, nmemb, slow = 0, 0, 0

    # Use the pixel size for the ASIC to construct the final
    # projection matrix.
    for p in self._metrology_params.detector.panel:
      if (p.serial != serial):
        continue
      for s in p.sensor:
        for a in s.asic:
          E = rec(elems=[+1 / a.pixel_size[0], 0, 0, 0,
                         0, -1 / a.pixel_size[1], 0, 0],
                  n=[2, 4])

          Pb = get_projection_matrix(a.pixel_size, a.dimension)[1]
          Tb = self._matrices[(0, p.serial, s.serial, a.serial)][1]

          t = E * Tb * Pb * center
          fast += t(0, 0)
          slow += t(1, 0)
          nmemb += 1
    if (nmemb == 0):
      return (0, 0)
    return (fast / nmemb, slow / nmemb)


  def displace_panel_fast_slow(self, serial, fast, slow):
    """Displace all ASICS:s in the panel with serial @p serial such
    that their new average position becomes @p fast, @p slow.  The
    function returns the updated transformation matrices.
    """

    # XXX Should use per-ASIC pixel size from the phil object.
    dx, dy = fast * self._pixel_size[0], -slow * self._pixel_size[1]

    for key, (Tf, Tb) in six.iteritems(self._matrices):
      if (len(key) == 4 and key[1] == serial):
        Tb_new = sqr(
          [Tb(0, 0), Tb(0, 1), Tb(0, 2), Tb(0, 3) + dx,
           Tb(1, 0), Tb(1, 1), Tb(1, 2), Tb(1, 3) + dy,
           Tb(2, 0), Tb(2, 1), Tb(2, 2), Tb(2, 3) + 0,
           Tb(3, 0), Tb(3, 1), Tb(3, 2), Tb(3, 3) + 0])

        # XXX Math worked out elsewhere.
        Tf_new = sqr(
          [Tf(0, 0), Tf(0, 1), Tf(0, 2), Tf(0, 3) - Tf(0, 0) * dx - Tf(0, 1) * dy,
           Tf(1, 0), Tf(1, 1), Tf(1, 2), Tf(1, 3) - Tf(1, 0) * dx - Tf(1, 1) * dy,
           Tf(2, 0), Tf(2, 1), Tf(2, 2), Tf(2, 3) - Tf(2, 0) * dx - Tf(2, 1) * dy,
           Tf(3, 0), Tf(3, 1), Tf(3, 2), Tf(3, 3) - Tf(3, 0) * dx - Tf(3, 1) * dy])

        self._matrices[key] = (Tf_new, Tb_new)
    return self._matrices


  def get_pixel_intensity(self,coords):
    tileno = int(coords[2])
    if tileno < 0: return None
    try:
      return self._tiles[self._keylist[tileno]][
        (int(round(coords[0],0)), (int(round(coords[1],0))))]
    except IndexError:
      return None


  def _matrix_as_string(self, T):
    """XXX other uses?"""

    R = sqr([T(0, 0), T(0, 1), T(0, 2),
             T(1, 0), T(1, 1), T(1, 2),
             T(2, 0), T(2, 1), T(2, 2)])
    o = R.r3_rotation_matrix_as_unit_quaternion()
    t = col([T(0, 3), T(1, 3), T(2, 3)])

    return ("orientation = %s, %s, %s, %s\n" % tuple(repr(c) for c in o)) + \
        ("translation = %s, %s, %s\n" % tuple(repr(c) for c in t))


  def transformation_matrices_as_metrology(self):
    """The transformation_matrices_as_metrology() function regularizes
    the the transformation matrices and converts them to a phil
    object.
    """

    from libtbx import phil
    from serialtbx.detector.legacy_metrology.metrology import \
      master_phil, regularize_transformation_matrices

    # XXX Experimental!
    regularize_transformation_matrices(self._matrices)

    (Tf_d, Tb_d) = self._matrices[(0,)]
    metrology_str = "detector {\n"
    metrology_str += "serial = %d\n" % 0
    metrology_str += self._matrix_as_string(Tb_d)

    for p in [k[1] for k in self._matrices.keys()
              if (len(k) == 2 and k[0:1] == (0,))]:
      (Tf_p, Tb_p) = self._matrices[(0, p)]
      metrology_str += "panel {\n"
      metrology_str += "serial = %d\n" % p
      metrology_str += self._matrix_as_string(Tf_d * Tb_p)

      for s in[k[2] for k in self._matrices.keys()
               if (len(k) == 3 and k[0:2] == (0, p))]:
        (Tf_s, Tb_s) = self._matrices[(0, p, s)]
        metrology_str += "sensor {\n"
        metrology_str += "serial = %d\n" % s
        metrology_str += self._matrix_as_string(Tf_p * Tb_s)

        for a in [k[3] for k in self._matrices.keys()
                  if (len(k) == 4 and k[0:3] == (0, p, s))]:
          (Tf_a, Tb_a) = self._matrices[(0, p, s, a)]
          metrology_str += "asic {\n"
          metrology_str += "serial = %d\n" % a
          metrology_str += self._matrix_as_string(Tf_s * Tb_a)

          metrology_str += "}\n"
        metrology_str += "}\n"
      metrology_str += "}\n"
    metrology_str += "}\n"

    return master_phil.fetch(sources=[phil.parse(metrology_str)])


  def readout_coords_as_detector_coords(self, coords):
    """
    Convert a 3 tuple coordinates from readout space (x, y, tile number)
    to detector space in meters, relative to the detector center
    """
    tileno = int(coords[2])
    if tileno < 0: return None
    try:
      T_f, T_b = self._matrices[self._keylist[tileno]]
    except IndexError:
      return None
    assert self._pixel_size is not None
    assert self._asic_focus is not None

    from serialtbx.detector.legacy_metrology.metrology import get_projection_matrix

    P_f, P_b = get_projection_matrix(self._pixel_size, self._asic_focus)

    return T_b * P_b * col([int(coords[0]), int(coords[1]), 1])

  def image_coords_as_detector_coords (self, x, y, readout=None) :
      """
      Convert image pixel coordinates to absolute position on the detector
      (in mm).
      """
      if readout is None:
        return super(CSPadDetector,self).image_coords_as_detector_coords(x, y)

      c = self.readout_coords_as_detector_coords([x, y, readout])
      return c[0] * 1000, c[1] * 1000

  def bounding_box_mm (self) :
      """
      Calculate the extent of this tiled detector image in mm.
      Returns x , y, width, height, where x and y are the upper left coordinates of the detector
      (which may or may not actually have a pixel if the nearest asic is tilted)
      """
      left = top = float("inf")
      right = bottom = -float("inf")
      for tileno in range(0,len(self._tiles)):
          coords = self.readout_coords_as_detector_coords((0,0,tileno))
          if(coords[0] < left): left = coords[0]
          elif(coords[0] > right): right = coords[0]
          if(coords[1] < top): top = coords[1]
          elif(coords[1] > bottom): bottom = coords[1]

          coords = self.readout_coords_as_detector_coords((self._asic_focus[0]-1,0,tileno))
          if(coords[0] < left): left = coords[0]
          elif(coords[0] > right): right = coords[0]
          if(coords[1] < top): top = coords[1]
          elif(coords[1] > bottom): bottom = coords[1]

          coords = self.readout_coords_as_detector_coords((0,self._asic_focus[1]-1,tileno))
          if(coords[0] < left): left = coords[0]
          elif(coords[0] > right): right = coords[0]
          if(coords[1] < top): top = coords[1]
          elif(coords[1] > bottom): bottom = coords[1]

          coords = self.readout_coords_as_detector_coords((self._asic_focus[0]-1,self._asic_focus[1]-1,tileno))
          if(coords[0] < left): left = coords[0]
          elif(coords[0] > right): right = coords[0]
          if(coords[1] < top): top = coords[1]
          elif(coords[1] > bottom): bottom = coords[1]

      return (left*1000, top*1000, (right-left)*1000, (bottom-top)*1000)

  def detector_coords_as_image_coords_float (self, x, y) :
    """
    Convert absolute detector position (in mm) to floating-value image pixel coordinates.
    """
    if self._pixel_size is None or type(self._pixel_size) is float:
      return super(CSPadDetector,self).detector_coords_as_image_coords_float(x, y)

    return x / self._pixel_size[0] / 1000, \
           y / self._pixel_size[1] / 1000

  def get_raw_data(self):
    # Not intended for production; simply a means to marshall all same-size tile
    # data together to report it out as a single array; used for testing dxtbx.
    keys = list(self._tiles.keys())
    keys.sort()
    raw = flex.double(flex.grid(len(keys)*self._tiles[keys[0]].focus()[0],
                                          self._tiles[keys[0]].focus()[1]))
    slowstride = self._tiles[keys[0]].focus()[0]
    for ik,k in enumerate(keys):
      raw.matrix_paste_block_in_place(
        block = self._tiles[k],
        i_row = slowstride * ik,
        i_column = 0)
    return raw


 *******************************************************************************


 *******************************************************************************
serialtbx/detector/legacy_metrology/generic_detector.py
from __future__ import absolute_import, division, print_function

from scitbx.array_family import flex
from iotbx.detectors import generic_flex_image

GenericFlexImage = generic_flex_image

class GenericDetector(object):
  def __init__(self,filename):
    self.filename = filename
    self.size2 = 200
    self.size1 = 250
    self.pixel_size = 0.1
    self.vendortype = "npy_raw"
    self.beamx = 0.
    self.beamy = 0.

  def readHeader(self):
    return
    from six.moves import cPickle as pickle
    G = open(self.filename,"rb")
    phil_stuff=pickle.load(G)
    data_stuff=pickle.load(G)

  def show_header(self):
    return "Generic detector with nothing in it"

  def read(self): pass

  def get_flex_image(self,brightness,**kwargs):
    # no kwargs supported at present
    rawdata = flex.random_double(200*250)
    rawdata.reshape(flex.grid(250,200))
    self.data = rawdata
    return GenericFlexImage(
      rawdata=rawdata,
      size1_readout=250,
      size2_readout=200,
      brightness=brightness,
      saturation=256.0)

  def initialize_viewer_properties(self,dummy_params):
    self.image_size_fast = self.size2
    self.image_size_slow = self.size1
    self.pixel_resolution = self.pixel_size

  def detector_coords_as_image_coords_float (self, x, y) :
    """
    Convert absolute detector position (in mm) to floating-value image pixel coordinates.
    """
    return x * self.pixel_resolution, \
           y * self.pixel_resolution

  def detector_coords_as_image_coords (self, x, y) :
    """
    Convert absolute detector position (in mm) to integer-value image pixel coordinates.
    """
    x_point,y_point = self.detector_coords_as_image_coords_float(x,y)
    return (int(x_point), int(y_point))

  def image_coords_as_detector_coords (self, x, y, readout=None) :
    """
    Convert image pixel coordinates to absolute position on the detector
    (in mm).
    """
    x_detector = x / self.pixel_resolution
    y_detector = y / self.pixel_resolution
    return x_detector, y_detector

  def get_beam_center_mm (self) :
    center_x = self.beamx
    center_y = self.beamy
    return center_x, center_y

  def get_beam_center_pixels_fast_slow(self):
    center_x, center_y = self.get_beam_center_mm()
    return self.detector_coords_as_image_coords_float(center_x, center_y)

  def get_pixel_intensity(self,coords):
    try:
      return self.data[(int(round(coords[0],0)), (int(round(coords[1],0))))]
    except IndexError:
      return None


 *******************************************************************************


 *******************************************************************************
serialtbx/detector/legacy_metrology/metrology.py
# -*- mode: python; coding: utf-8; indent-tabs-mode: nil; python-indent: 2 -*-
#
# $Id$

"""The metrology module does conversion of this and that.  XXX Need to
describe the keys of the dictionaries here.  XXX Just like in OpenGL,
all matrices are to be pre-multiplied (with column vectors)?
"""
from __future__ import absolute_import, division, print_function

from libtbx import phil
from scitbx import matrix


# XXX None of these names are settled yet.  XXX separate out the
# un-scoped bits into a new master_phil called... what?  XXX detector
# should have .multiple = True to allow for multiple detectors, and
# the distance should be account for in their translation (which fixes
# the origin to that of the laboratory frame)--no, maybe it's better
# for it to be with respect to give the back of the detector stage
# instead).
master_phil = phil.parse("""
attenuation = None
  .type = float
  .optional = False
  .help = mm of Si-foil used to attenuate the shot
beam_center = None
  .type = floats(size=2)
  .optional = False
  .help = "Location of the beam center in mm (XXX this is broken,
           fixed at 0, 0)"
distance = None
  .type = float
  .optional = False
  .help = Sample-detector distance, in mm
pulse_length = None
  .type = float
  .optional = False
  .help = Pulse length of the shot, in fs
sequence_number = None
  .type = int
  .optional = True
  .help = Sequence number, probably useless for CSPad XXX
timestamp = None
  .type = str
  .optional = False
  .help = "ISO 8601 timestamp to ms precision.  XXX Would have been
           better as a two-tuple of seconds and nanoseconds since
           midnight, 1 January 1970 (Unix time), like in the XTC
           streams."
wavelength = None
  .type = float
  .optional = False
  .help = Wavelength of the shot, in Aangstroem
xtal_target = None
  .type = str
  .optional = True
  .help = Processing target for shot
detector {
  serial = None
    .type = int
    .optional = False
  label = None
    .type = str
    .optional = True
  translation = None
    .type = floats(size=3)
  orientation = None
    .type = floats(size=4)
    .help = "Unit quaternion, (w, x, y, z) relating child coordinate
             frame to parent XXX Optional or mandatory?"
  panel
    .multiple = True
    .optional = True
  {
    serial = None
      .type = int
      .optional = False
    label = None
      .type = str
      .optional = True
    translation = None
      .type = floats(size=3)
      .optional = False
    orientation = None
      .type = floats(size=4)
      .optional = False
    sensor
      .multiple = True
      .optional = True
    {
      serial = None
        .type = int
        .optional = False
      label = None
        .type = str
        .optional = True
      translation = None
        .type = floats(size=3)
        .optional = False
      orientation = None
        .type = floats(size=4)
        .optional = False
      asic
        .multiple = True
        .optional = True
      {
        serial = None
          .type = int
          .optional = False
        label = None
          .type = str
          .optional = True
        translation = None
          .type = floats(size=3)
          .optional = False
        orientation = None
          .type = floats(size=4)
          .optional = False
        pixel_size = None
          .type = floats(size=2)
          .optional = False
          .help = "Size of a pixel along a horizontal row (width), and
                   a vertical column (height), in meters."
        saturation = None
          .type = float
          .optional = False
          .help = Saturated pixel value XXX float or int?
        dimension = None
          .type = ints(size=2)
          .optional = False
          .help = "Number of pixels in a horizontal row (width), and a
                   vertical column (height) of the ASIC."
      }
    }
  }
}
""")


def _average_transformation(matrices, keys):
  """The _average_transformation() function determines the average
  rotation and translation from the transformation matrices in @p
  matrices with keys matching @p keys.  The function returns a
  two-tuple of the average rotation in quaternion representation and
  the average translation.

  XXX Alternative: use average of normals, weighted by element size,
  to determine average orientation.
  """

  from scitbx.array_family import flex
  from tntbx import svd

  # Sum all rotation matrices and translation vectors.
  sum_R = flex.double(flex.grid(3, 3))
  sum_t = flex.double(flex.grid(3, 1))
  nmemb = 0
  for key in keys:
    T = matrices[key][1]
    sum_R += flex.double((T(0, 0), T(0, 1), T(0, 2),
                          T(1, 0), T(1, 1), T(1, 2),
                          T(2, 0), T(2, 1), T(2, 2)))
    sum_t += flex.double((T(0, 3), T(1, 3), T(2, 3)))
    nmemb += 1
  if nmemb == 0:
    # Return zero-rotation and zero-translation.
    return (matrix.col((1, 0, 0, 0)), matrix.zeros((3, 1)))

  # Calculate average rotation matrix as U * V^T where sum_R = U * S *
  # V^T and S diagonal (Curtis et al. (1993) 377-385 XXX proper
  # citation, repeat search), and convert to quaternion.
  svd = svd(sum_R)
  R_avg = matrix.sqr(list(svd.u().matrix_multiply_transpose(svd.v())))
  o_avg = R_avg.r3_rotation_matrix_as_unit_quaternion()
  t_avg = matrix.col(list(sum_t / nmemb))

  return (o_avg, t_avg)


def _transform(o, t):
  """The _transform() function returns the transformation matrices in
  homogeneous coordinates between the parent and child frames.  The
  forward transform maps coordinates in the parent frame to the child
  frame, and the backward transform provides the inverse.  The last
  row of the product of any two homogeneous transformation matrices is
  always (0, 0, 0, 1).

  @param o Orientation of child w.r.t. parent, as a unit quaternion
  @param t Translation of child w.r.t. parent
  @return  Two-tuple of the forward and backward transformation
           matrices
  """

  Rb = o.unit_quaternion_as_r3_rotation_matrix()
  tb = t
  Tb = matrix.sqr((Rb(0, 0), Rb(0, 1), Rb(0, 2), tb(0, 0),
                   Rb(1, 0), Rb(1, 1), Rb(1, 2), tb(1, 0),
                   Rb(2, 0), Rb(2, 1), Rb(2, 2), tb(2, 0),
                   0,        0,        0,        1))
  Rf = Rb.transpose()
  tf = -Rf * t
  Tf = matrix.sqr((Rf(0, 0), Rf(0, 1), Rf(0, 2), tf(0, 0),
                   Rf(1, 0), Rf(1, 1), Rf(1, 2), tf(1, 0),
                   Rf(2, 0), Rf(2, 1), Rf(2, 2), tf(2, 0),
                   0,        0,        0,        1))
  return (Tf, Tb)


def get_projection_matrix(dim_pixel, dim_readout):
  """The get_projection_matrix() function returns the projection
  matrices in homogeneous coordinates between readout frame and
  fractional row and column indices.  The forward transform maps
  coordinates in the readout frame, i.e. [x, y, z, 1], to readout
  indices, i.e. [i, j, 1], where i and j are the row and column
  indices, respectively.  The backward transform provides the inverse.
  The get_projection_matrix() function assumes that coordinates in the
  readout frame are pixel centers.  XXX Bad name!  Better
  readout2metric(), readout_projection_matrices()?

  @note If coordinates in the readout frame are the top, left corner
        of the pixel, pass dim_readout=(readout_width_in_pixels + 1,
        readout_height_in_pixels + 1).

  @param dim_pixel   Two-tuple of pixel width and height, in meters
  @param dim_readout Two-tuple of readout width and height, in pixels
  @return            Two-tuple of the forward and backward projection
                     matrices
  """

  Pb = matrix.rec(
    elems=(0, +dim_pixel[0], dim_pixel[0] * (1 - dim_readout[0]) / 2,
           -dim_pixel[1], 0, dim_pixel[1] * (dim_readout[1] - 1) / 2,
           0, 0, 0,
           0, 0, 1),
    n=(4, 3))
  Pf = matrix.rec(
    elems=(0, -1 / dim_pixel[1], 0, (dim_readout[1] - 1) / 2,
           +1 / dim_pixel[0], 0, 0, (dim_readout[0] - 1) / 2,
           0, 0, 0, 1),
    n=(3, 4))
  return (Pf, Pb)


def metrology_as_transformation_matrices(params):
  """XXX What if the child is invisible from the parent (pointing away
  from the parent)?  XXX What if two elements are overlapping?
  Implement bounding boxes (only needed for transformation/projection
  from eye to ASIC).  XXX Projections implemented elsewhere.

  XXX Should probably be something like "phil_to_matrix_dict" and put
  the metrology2phil() function here, too!

  XXX It was not such a great idea to include the final projection
  here--it made it impossible to recover z!

  XXX Normalisation of orientation may be necessary to guarantee that
  rotation matrices are orthogonal if the serialisation truncated the
  numbers.

  @param params Pure Python object, extracted from a metrology Phil
                object
  @return       Dictionary of homogeneous transformation matrices
  """

  d = params.detector
  T_d = _transform(matrix.col(d.orientation).normalize(),
                   matrix.col(d.translation))

  matrices = {(0,): T_d}
  for p in d.panel:
    T_p = _transform(matrix.col(p.orientation).normalize(),
                     matrix.col(p.translation))
    T_p = (T_p[0] * T_d[0], T_d[1] * T_p[1])

    matrices[(d.serial, p.serial)] = T_p

    for s in p.sensor:
      T_s = _transform(matrix.col(s.orientation).normalize(),
                       matrix.col(s.translation))
      T_s = (T_s[0] * T_p[0], T_p[1] * T_s[1])

      matrices[(d.serial, p.serial, s.serial)] = T_s

      for a in s.asic:
        T_a = _transform(matrix.col(a.orientation).normalize(),
                         matrix.col(a.translation))
        T_a = (T_a[0] * T_s[0], T_s[1] * T_a[1])

        matrices[(d.serial, p.serial, s.serial, a.serial)] = (T_a[0], T_a[1])

  return matrices


def regularize_transformation_matrices(matrices, key=(0,)):
  """The _regularize_transformation_matrices() function recursively sets
  the transformation of each element to the average transformation of
  its children.  XXX Round average orientations to multiples of 90
  degrees?  XXX Should they maybe return matrices instead?.
  """

  # The length of the key tuple identifies the current recursion
  # depth.
  next_depth = len(key) + 1

  # Base case: return if at the maximum depth.
  keys = [k for k in matrices.keys()
          if (len(k) == next_depth and k[0:next_depth - 1] == key)]
  if (len(keys) == 0):
    return

  # Recursion: regularize at next depth, and get the average.
  for k in keys:
    regularize_transformation_matrices(matrices, k)
  o, t = _average_transformation(matrices, keys)
  matrices[key] = _transform(o, t)


 *******************************************************************************


 *******************************************************************************
serialtbx/detector/rayonix.py
from __future__ import division

# given value of rayonix detector saturation xppi6115
rayonix_saturated_value = 2**16 -1

# minimum value for rayonix data
rayonix_min_trusted_value = 0
rayonix_max_trusted_value = rayonix_saturated_value - 1

def get_rayonix_pixel_size(bin_size):
  ''' Given a bin size determine a pixel size.

Michael Blum from Rayonix said The pixel size is recorded in the header,
but can be derived trivially from the overall dimension of the corrected imaging
area (170mm) and the number of pixels. (3840 unbinned). The corrected image is
forced to this size.

unbinned 170/3840  = 0.04427

I believe the accuracy of the MEAN pixel size to be at least as good as 0.1%
which is the limit to which I can measure our calibration plate and exceeds the
 parallax error in our calibration station.

Note, the Rayonix MX340 has the same pixel size as the MX170:

unbinned 340/7680  = 0.04427

  @param bin_size rayonix bin size as an integer
  '''
  pixel_size=bin_size*170/3840
  return pixel_size

def get_rayonix_detector_dimensions(env):
  ''' Given a psana env object, find the detector dimensions
      @param env psana environment object
  '''
  import psana
  cfgs = env.configStore()
  rayonix_cfg = cfgs.get(psana.Rayonix.ConfigV2, psana.Source('Rayonix'))
  if not rayonix_cfg: return None, None
  return rayonix_cfg.width(), rayonix_cfg.height()

def get_data_from_psana_event(evt, address):
  """ Read the pixel data for a Rayonix image from an event
  @param psana event object
  @param address old style psana detector address
  @return numpy array with raw data"""
  from psana import Source, Camera
  from serialtbx.detector import xtc
  import numpy as np
  address = xtc.old_address_to_new_address(address)
  src=Source(address)
  data = evt.get(Camera.FrameV1,src)
  if data is not None:
    data = data.data16().astype(np.float64)
  return data


 *******************************************************************************


 *******************************************************************************
serialtbx/detector/xtc.py
from __future__ import division

from scitbx import matrix
from serialtbx.detector import basis

def basis_from_geo(geo, use_z = True):
  """ Given a psana GeometryObject, construct a basis object """
  rotx = matrix.col((1,0,0)).axis_and_angle_as_r3_rotation_matrix(
    geo.rot_x + geo.tilt_x, deg=True)
  roty = matrix.col((0,1,0)).axis_and_angle_as_r3_rotation_matrix(
    geo.rot_y + geo.tilt_y, deg=True)
  rotz = matrix.col((0,0,1)).axis_and_angle_as_r3_rotation_matrix(
    geo.rot_z + geo.tilt_z, deg=True)

  rot = (rotx*roty*rotz).r3_rotation_matrix_as_unit_quaternion()

  if use_z:
    trans = matrix.col((geo.x0/1000, geo.y0/1000, geo.z0/1000))
  else:
    trans = matrix.col((geo.x0/1000, geo.y0/1000, 0))

  return basis(orientation = rot, translation = trans)

def old_address_to_new_address(address):
  """ Change between old and new style detector addresses.
  I.E. CxiDs1-0|Cspad-0 becomes CxiDs1.0:Cspad.0
  @param address detector address to convert
  """
  return address.replace('-','.').replace('|',':')

def address_split(address, env=None):
  """The address_split() function splits an address into its four
  components.  Address strings are on the form
  detector-detectorID|device-deviceID, where the detectors must be in
  dir(xtc.DetInfo.Detector) and device must be in
  (xtc.DetInfo.Device).
  @param address Full data source address of the DAQ device
  @param env     Optional env to dereference an alias into an address
  @return        Four-tuple of detector name, detector ID, device, and
                 device ID
  """

  import re

  # pyana
  m = re.match(
    r"^(?P<det>\S+)\-(?P<det_id>\d+)\|(?P<dev>\S+)\-(?P<dev_id>\d+)$", address)
  if m is not None:
    return (m.group('det'), m.group('det_id'), m.group('dev'), m.group('dev_id'))

  # psana
  m = re.match(
    r"^(?P<det>\S+)\.(?P<det_id>\d+)\:(?P<dev>\S+)\.(?P<dev_id>\d+)$", address)
  if m is not None:
    return (m.group('det'), m.group('det_id'), m.group('dev'), m.group('dev_id'))

  # psana DetInfo string
  m = re.match(
    r"^DetInfo\((?P<det>\S+)\.(?P<det_id>\d+)\:(?P<dev>\S+)\.(?P<dev_id>\d+)\)$", address)
  if m is not None:
    return (m.group('det'), m.group('det_id'), m.group('dev'), m.group('dev_id'))

  if env is not None:
    # Try to see if this is a detector alias, and if so, dereference it. Code from psana's Detector/PyDetector.py
    amap = env.aliasMap()
    alias_src = amap.src(address) # string --> DAQ-style psana.Src

    # if it is an alias, look up the full name
    if amap.alias(alias_src) != '':         # alias found
      address = str(alias_src)
      return address_split(address)

  return (None, None, None, None)

def get_ebeam(evt):
  try:
    # pyana
    ebeam = evt.getEBeam()
  except AttributeError:
    from psana import Source, Bld
    src = Source('BldInfo(EBeam)')
    ebeam = evt.get(Bld.BldDataEBeamV6, src)
    if ebeam is None:
      ebeam = evt.get(Bld.BldDataEBeamV5, src)
    if ebeam is None:
      ebeam = evt.get(Bld.BldDataEBeamV4, src)
    if ebeam is None:
      ebeam = evt.get(Bld.BldDataEBeamV3, src)
    if ebeam is None:
      ebeam = evt.get(Bld.BldDataEBeamV2, src)
    if ebeam is None:
      ebeam = evt.get(Bld.BldDataEBeamV1, src)
    if ebeam is None:
      ebeam = evt.get(Bld.BldDataEBeamV0, src)
    if ebeam is None:
      ebeam = evt.get(Bld.BldDataEBeam, src) # recent version of psana will return a V7 event or higher if this type is asked for

  return ebeam

def evt_wavelength(evt, delta_k=0):
  """The evt_wavelength() function returns the wavelength in Ångström
  of the event pointed to by @p evt.  From Margaritondo & Rebernik
  Ribic (2011): the dimensionless relativistic γ-factor is derived
  from beam energy in MeV and the electron rest mass, K is a
  dimensionless "undulator parameter", and L is the macroscopic
  undulator period in Ångström.  See also
  https://people.eecs.berkeley.edu/~attwood/srms/2007/Lec10.pdf

  @param evt     Event data object, a configure object
  @param delta_k Optional K-value correction
  @return        Wavelength, in Ångström
  """

  if evt is not None:
    ebeam = get_ebeam(evt)

    if hasattr(ebeam, 'fEbeamPhotonEnergy') and ebeam.fEbeamPhotonEnergy > 0:
      # pyana
      return 12398.4187 / ebeam.fEbeamPhotonEnergy
    if hasattr(ebeam, 'ebeamPhotonEnergy') and ebeam.ebeamPhotonEnergy() > 0:
      # psana
      return 12398.4187 / ebeam.ebeamPhotonEnergy()

    if hasattr(ebeam, 'fEbeamL3Energy') and ebeam.fEbeamL3Energy > 0:
      # pyana
      gamma = ebeam.fEbeamL3Energy / 0.510998910
    elif hasattr(ebeam, 'ebeamL3Energy') and ebeam.ebeamL3Energy() > 0:
      # psana
      gamma = ebeam.ebeamL3Energy() / 0.510998910
    else:
      return None
    K = 3.5 + delta_k
    L = 3.0e8
    return L / (2 * gamma**2) * (1 + K**2 / 2)
  return None

def env_detz(address, env):
  """The env_detz() function returns the position of the detector with
  the given address string on the z-axis in mm.  The zero-point is as
  far away as possible from the sample, and values decrease as the
  detector is moved towards the sample.
  @param address Full data source address of the DAQ device
  @param env     Environment object
  @return        Detector z-position, in mm
  """

  if env is not None:
    detector = address_split(address, env)[0]
    if detector is None:
      return None
    elif detector == 'CxiDs1':
      pv = env.epicsStore().value('CXI:DS1:MMS:06.RBV')
      if pv is None:
        # Even though potentially unsafe, fall back on the commanded
        # value if the corresponding read-back value cannot be read.
        # According to Sébastien Boutet, this particular motor has not
        # caused any problem in the past.
        pv = env.epicsStore().value('CXI:DS1:MMS:06')
      if pv is None:
        # Try the other detector. These are sometimes inconsistent
        pv = env.epicsStore().value('CXI:DS2:MMS:06.RBV')
    elif detector == 'CxiDsd' or detector == 'CxiDs2':
      # XXX Note inconsistency in naming: Dsd vs Ds2!
      pv = env.epicsStore().value('CXI:DS2:MMS:06.RBV')
      if pv is None:
        # Try the other detector. These are sometimes inconsistent
        pv = env.epicsStore().value('CXI:DS1:MMS:06.RBV')
    elif detector == 'XppGon':
      # There is no distance recorded for the XPP's CSPAD on the robot
      # arm.  Always return zero to allow the distance to be set using
      # the offset.
      return 0
    elif detector == 'XppEndstation' or \
         detector == 'MfxEndstation':
      # There is no distance recorded for the XPP's or MFX's Rayonix
      # on the robot arm.  Always return zero to allow the distance to
      # be set using the offset.
      return 0
    else:
      return None

    if pv is None:
      return None

    if hasattr(pv, "values"):
      if len(pv.values) == 1:
        return pv.values[0]
      else:
        return None
    return pv

  return None

def env_distance(address, env, offset):
  """The env_distance() function returns the distance between the
  sample and the detector with the given address string in mm.  The
  distance between the sample and the the detector's zero-point can
  vary by an inch or more between different LCLS runs.  According to
  Sébastien Boutet the offset should be stable to within ±0.5 mm
  during a normal experiment.

  @param address Full data source address of the DAQ device
  @param env     Environment object
  @param offset  Detector-sample offset in mm, corresponding to
                 longest detector-sample distance
  @return        Detector-sample distance, in mm
  """

  detz = env_detz(address, env)
  if detz is not None:
    return detz + offset
  return None


 *******************************************************************************


 *******************************************************************************
serialtbx/mono_simulation/__init__.py


 *******************************************************************************


 *******************************************************************************
serialtbx/mono_simulation/max_like.py
from __future__ import absolute_import, division, print_function

import math
from math import exp,pi,log,pow
import sys
import copy

from scitbx.array_family import flex
from scitbx.lbfgs import run,termination_parameters,exception_handling_parameters,core_parameters
from six.moves import cPickle as pickle
from six.moves import range

class minimizer:
  def __init__(self, d_i, psi_i, eta_rad, Deff):
    self.safelog = -1. + math.log(sys.float_info.max)
    self.S = pickle.dumps([d_i, psi_i, eta_rad, Deff], 0)
    assert len(d_i) == len(psi_i)
    self.d_i = d_i
    self.psi_i = psi_i
    self.Nobs = len(d_i)
    self.escalate = 10. # 10 is a soft switch; 50-100 a hard switch
    self.x = flex.double([log(2./Deff), log(eta_rad)]) # parameters alpha, eta
    self.minimizer = run(
      target_evaluator=self,
      core_params=core_parameters(
        gtol=0.1
        # increasing the accuracy of the line search technique (default=0.9)
        # as suggested by source code.  Otherwise Deff is set unreasonably high
        # and the exponential blows up.
      ),
      termination_params = termination_parameters(
        traditional_convergence_test=False,
        drop_convergence_test_max_drop_eps=1.e-5,
        min_iterations=0,
        max_iterations = 100,
        max_calls=200),
      exception_handling_params=exception_handling_parameters(
         ignore_line_search_failed_rounding_errors=True,
         ignore_line_search_failed_step_at_lower_bound=True,#the only change from default
         ignore_line_search_failed_step_at_upper_bound=False,
         ignore_line_search_failed_maxfev=False,
         ignore_line_search_failed_xtol=False,
         ignore_search_direction_not_descent=False)
      )

    self.x=flex.exp(self.x)


  def functional_only(self,alpha,eta):

    #print "Deff_ang",1./alpha,"FWmos_deg",eta*180./pi
    allobs = range(self.Nobs)
    f = 0.
    if False:
      from matplotlib import pyplot as plt
      psi_model = (self.d_i*alpha + eta)/2.
      plt.plot(1./self.d_i,self.psi_i,"r.")
      plt.plot(1./self.d_i,psi_model,"g.")
      plt.plot(1./self.d_i,-psi_model,"g.")
      plt.show()

    for i in allobs:
      psi_model = (self.d_i[i]*alpha + eta)/2.
      psi_i = self.psi_i[i]
      B = self.escalate / psi_model
      expBarg = B*(psi_i+psi_model)
      expBnegarg = -B*(psi_i-psi_model)

      if abs(expBarg) > self.safelog or abs(expBnegarg) > self.safelog:

        print("XXescalate",self.escalate)
        print("XXpsi_model",psi_model)
        print("XXexp",B,expBarg)
        print("XXeta",eta)
        print("XXDeff",1./alpha)
        print(self.S)
        raise ValueError("max likelihood exp argument outside of math domain %f %f"%(expBarg,expBnegarg))

      fx = (0.5/psi_model)/(1+exp(expBarg ) ) * (1+exp(self.escalate))
      gx = 1./(1+exp(expBnegarg ) ) * (1+exp(self.escalate))
      prob = fx * gx
      f -= math.log(prob)
    return f


  def compute_functional_and_gradients(self):
    """The compute_functional_and_gradients() function

    @return Two-tuple of the value of the functional, and an
            <code>n</code>-long vector with the values of the
            gradients at the current position
    """
    if self.x[0] > self.safelog or self.x[1] > self.safelog:
      raise ValueError("max likelihood current parameters outside of math domain %f %f"%(self.x))
    alpha = exp(self.x[0])
    eta = exp(self.x[1])
    #print "alpha",alpha, "eta",eta
    allobs = range(self.Nobs)
    f = 0.
    partf_partP0 = 0.
    partf_partP1 = 0.

    f = self.functional_only(alpha,eta)

    for i in allobs:
      psi_model = (self.d_i[i]*alpha + eta)/2.
      part_psi_model_partP0 = 0.5 * self.d_i[i] * alpha
      part_psi_model_partP1 = 0.5 * eta

      psi_i = self.psi_i[i]
      B = self.escalate / psi_model

      if psi_model > 1e100 or part_psi_model_partP0 > 1e100:
        from libtbx.utils import Sorry
        raise Sorry("Model has diverged, cannot continue")

      expB = exp( B * (psi_i + psi_model) )
      expBneg = exp( -B * (psi_i - psi_model) )

      if expB > 1e100 or expBneg < -1e100 or expBneg > 1e100:
        from libtbx.utils import Sorry
        raise Sorry("Model has diverged, cannot continue")

      Spos = 1. + expB
      Sneg = 1. + expBneg
      expnu = 1. + exp(self.escalate)

      sign_error_27Feb2014_through_15Feb2017 = True
      if sign_error_27Feb2014_through_15Feb2017:
        partB_partP0 = (-self.escalate/(psi_model*psi_model))*part_psi_model_partP0
        partB_partP1 = (-self.escalate/(psi_model*psi_model))*part_psi_model_partP1

        partSpos_partP0 = expB * ((psi_i+psi_model)*partB_partP0 + B*part_psi_model_partP0)
        partSpos_partP1 = expB * ((psi_i+psi_model)*partB_partP1 + B*part_psi_model_partP1)

        partSneg_partP0 = expBneg * ((-psi_i+psi_model)*partB_partP0 + B*part_psi_model_partP0)
        partSneg_partP1 = expBneg * ((-psi_i+psi_model)*partB_partP1 + B*part_psi_model_partP1)

        partG_partP0 = -expnu*pow(Sneg,-2)*partSneg_partP0
        partG_partP1 = -expnu*pow(Sneg,-2)*partSneg_partP1

        Sfac = 2.*psi_model*Spos
        partF_partP0 = -expnu*pow(Sfac,-2)*2*(psi_model*partSpos_partP0 + Spos*part_psi_model_partP0)
        partF_partP1 = -expnu*pow(Sfac,-2)*2*(psi_model*partSpos_partP1 + Spos*part_psi_model_partP1)

        fx = (0.5/psi_model)/(Spos) * expnu
        gx = (1./Sneg) * expnu
        prob = fx * gx
        part_prob_partP0 = fx*partG_partP0 + gx*partF_partP0
        part_prob_partP1 = fx*partG_partP1 + gx*partF_partP1
      else:
        # AD14 eqn B.7 (AD14 = Sauter et al (2014) Acta Cryst D70: 3299-3309)
        temp = (psi_i/(psi_model*psi_model))
        part_zed_partP0 = temp * part_psi_model_partP0
        part_zed_partP1 = temp * part_psi_model_partP1

        # AD14 eqn B.8
        fx = expnu / Sneg
        part_f_partP0 = self.escalate * fx * (expBneg / Sneg) * part_zed_partP0
        part_f_partP1 = self.escalate * fx * (expBneg / Sneg) * part_zed_partP1

        # AD14 eqn B.9
        gx = expnu / Spos
        part_g_partP0 = -self.escalate * gx * (expB / Spos) * part_zed_partP0
        part_g_partP1 = -self.escalate * gx * (expB / Spos) * part_zed_partP1

        # AD14 eqn B.10
        part_fg_partP0 = fx * part_g_partP0 + gx * part_f_partP0
        part_fg_partP1 = fx * part_g_partP1 + gx * part_f_partP1

        # AD14 eqn B.11
        prefactor = 0.5/psi_model
        prob = prefactor * fx * gx
        temp = 0.5 / (psi_model*psi_model)
        part_prob_partP0 = temp * (part_fg_partP0 * psi_model - fx * gx * part_psi_model_partP0)
        part_prob_partP1 = temp * (part_fg_partP1 * psi_model - fx * gx * part_psi_model_partP1)


      partf_partP0 -= (1./prob) * part_prob_partP0
      partf_partP1 -= (1./prob) * part_prob_partP1


    #print f, [partf_partP0,partf_partP1],"analytical"
    #self.fd_compute_functional_and_gradients()


    return (f, flex.double([partf_partP0,partf_partP1]))


  def fd_compute_functional_and_gradients(self):
    """The compute_functional_and_gradients() function

    @return Two-tuple of the value of the functional, and an
            <code>n</code>-long vector with the values of the
            gradients at the current position
    """
    EPSILON = 0.000001

    alpha = exp(self.x[0])
    eta = exp(self.x[1])
    aplus = exp(self.x[0]+EPSILON)
    aminu = exp(self.x[0]-EPSILON)
    eplus = exp(self.x[1]+EPSILON)
    eminu = exp(self.x[1]-EPSILON)

    allobs = range(self.Nobs)
    f = 0.
    partf_partalpha = 0.
    partf_parteta = 0.
    partf_partnu = 0.

    f = self.functional_only(alpha,eta)

    fd_partf_partalpha = (self.functional_only(aplus,eta) -
                          self.functional_only(aminu,eta)) / (2.*EPSILON)

    fd_partf_parteta = (self.functional_only(alpha,eplus) -
                          self.functional_only(alpha,eminu)) / (2.*EPSILON)

    print(f, [fd_partf_partalpha,fd_partf_parteta],"finite diff")
    print()


    return (f, flex.double([fd_partf_partalpha,fd_partf_parteta]))

class block_size_simplex(minimizer):
  def __init__(self, d_i, psi_i, eta_rad, Deff, max_cycles=30):
    self.safelog = -1. + math.log(sys.float_info.max)
    self.S = pickle.dumps([d_i, psi_i, eta_rad, Deff], 0)
    assert len(d_i) == len(psi_i)
    self.d_i = d_i
    self.psi_i = psi_i
    self.Nobs = len(d_i)
    self.escalate = 5. # 10 is a soft switch; 50-100 a hard switch
    self.eta_param = log(eta_rad) # parameter eta
    self.x = flex.double([log(2./Deff)]) # parameter alpha

    from scitbx.simplex import simplex_opt
    self.max_cycles = max_cycles
    self.n = 1 # the full number of parameters
    self.iteration = 0
    initial_values = flex.double([self.x[0]])
    self.starting_simplex = [ initial_values ]
    bounding_values = 0.9 * initial_values

    for ii in range(self.n):
      vertex = copy.deepcopy(initial_values)
      vertex[ii] = bounding_values[ii]
      self.starting_simplex.append(vertex)
    self.optimizer = simplex_opt( dimension=self.n,
                                        matrix  = self.starting_simplex,
                                        evaluator = self,
                                        monitor_cycle=10,
                                        max_iter=max_cycles-1,
                                        tolerance=1e-7)
    self.x = self.optimizer.get_solution()
    self.x=flex.exp(flex.double([self.x[0], self.eta_param]))

  def target(self,vector):
    alpha = exp(vector[0])
    eta = exp(self.eta_param)

    #print "Deff_ang",1./alpha,"FWmos_deg",eta*180./pi
    allobs = range(self.Nobs)
    f = 0.

    for i in allobs:
      psi_model = (self.d_i[i]*alpha + eta)/2.
      psi_i = self.psi_i[i]
      B = self.escalate / psi_model
      expBarg = B*(psi_i+psi_model)
      expBnegarg = -B*(psi_i-psi_model)

      if abs(expBarg) > self.safelog or abs(expBnegarg) > self.safelog:

        print("XXescalate",self.escalate)
        print("XXpsi_model",psi_model)
        print("XXexp",B,expBarg)
        print("XXeta",eta)
        print("XXDeff",1./alpha)
        print(self.S)
        raise ValueError("max likelihood exp argument outside of math domain %f %f"%(expBarg,expBnegarg))

      fx = (0.5/psi_model)/(1+exp(expBarg ) ) * (1+exp(self.escalate))
      gx = 1./(1+exp(expBnegarg ) ) * (1+exp(self.escalate))
      prob = fx * gx
      f -= math.log(prob)
    return f

if __name__=="__main__":
  Deff=3031.86582722
  eta_rad = 0.000466410948822
  psi_i = flex.double([0.0006334354051280837, -0.0002374482102549014, -0.0002904909028471741, 0.0011826729893182895, 0.000410928438641641, -0.00124596265535444, -0.00021073006263523284, 2.093758396869777e-05, 0.00013926185459742, 4.1804791078049327e-07, 0.0005488235136727886, -9.193766688284655e-05, 8.44164318416186e-05, 0.00017546468776326354, 8.556690954803574e-05, -0.0003036138955810559, -0.000641357099097601, -0.0002244689650400115, 0.0024344760117975877, 0.00014360518608511725, 0.0004629662852427153, 0.0010858564953247383, -0.0001894719504276195, -0.0004220364347353991, -0.00016480563546219582, -7.844441933222163e-05, 0.0003252131531280895, -0.0005136803614743484, 4.5978946903056804e-05, 0.0010255392857963421, 0.0006644982357545689, -0.0007174042461201835, 0.0009742587761427171, 0.0024434586226267443, 0.00045561395760178476, 8.915319478679247e-05, 0.0005236885101564813, 0.0002856271291591659, -0.0026734526609776222, 0.00033306436288244306, -0.00022754281024372315, 0.00023817253689034415, -0.0002520749898691968, -0.0020537511660755365, 0.00020729453680532877, -2.354914713029257e-05, 0.0002876895854414163, 0.001716027465036208, 0.00030875292516916055, 0.00028734095022527615, 0.000690293382372606, 9.792237509768104e-05, 0.0007307128060078471, 0.00019444481369464814, 0.0005980270995420993, 0.0009460483933354358, 0.0005870499944482794, -0.00011039230639688934, -0.0004808531781895475, 0.0018870161528584625, -0.0003639091021999277, 0.0005519908037482245, 0.0004329619246624209, -0.00015085445344515053, 0.0006282538001626667, -0.0007732943616816869, -0.00032749371035270856, 0.000654930282155595, -0.00023549605807420977, -0.0005891241811741804, -0.001015592507240478, 9.246491356739758e-05, -0.0003231223275328174, 0.0004315647971386343, 0.0006499518590635939, 0.000400054650432406, -0.0004822487654504704, 0.00027532639996442285, -0.000978602851334643, -0.0006213760059380183, 0.0003760896353606164, 0.0005196509460713409, 0.00046415390276214013, -0.00015462263783441285, 0.00027762919906122496, 0.0018081142933046867, 0.00037768318649323456, -0.00024789833570362747, 0.00023662192723274434, 0.00016966215728721011, -0.00033361760550367045, 0.0019367119474373712, 0.0005384334393999256, 0.0007318635462986153, 0.00017086715430940608, 7.859867939243422e-05, -0.00020751446869054133, 4.994364572469607e-05, -0.0003824554400449278, -0.00026521631430174915, 0.00014213714869980813, 0.00032378952104965194, 0.00043881016031337784, -5.463509415655856e-05, -6.045567179850129e-05, 0.00016833309698749229, -0.0009034322958119932, 0.0003272749274387823, 0.0001278213552360918, 6.918587207431909e-05, -0.00018906814027630796, 0.0005493447463055587, -0.0003473573489120576, -0.0005756446264375274, -0.0005810317073863452, 0.00016823626895044565, -0.0007121302419254515, -0.0006446641830389517, 0.00021457706495682201, -0.001412815997421152, 0.0008049965900551816, 0.0006739688433907676, -0.000678084916577125, 0.0030964461975499288, 0.0004752110867421634, -0.0016101620722278956, 0.00021391028011932275, 0.0002860580859305863, 0.0006361019143261609, -0.00018401253708537975, -5.504805202934844e-06, -0.0003182879168637159, 0.000346408756262901, -0.00017056597173038918, -0.00044799476065611975, -0.0028675925127297436, -0.0006978869592003578, 4.2832889980511555e-05, 0.00089016728168247, 0.0003420927123675246, -0.0003982221462937286, 0.00044318297487696727, -0.0005969711504537665, 0.0009111071547058384, -0.0002038300440046238, 0.00011222789250645929, 0.0004948503818038209, 0.000573759835322318, 0.001717392937439531, -0.002467551854588084, 0.0005062520631107385, 5.553236213844266e-05, 0.00022044850244526192, -0.0018649150377643446, 3.936315541818528e-05, 0.0014308829990956617, -0.0011578832483421064, -0.0016054935013721523, -0.0008640481845045424, -8.971217742970833e-06, -0.0004958325004491824, 0.00011426889745855636, 0.000292717376135336, 0.001017079613404912, -0.00012882548748991722, 0.0005809114055173677, -0.0001951028012238056, -0.0027759773250265914, -3.0209564912715713e-06, 0.00154305151450003, 0.00018446039254867836, -3.925711690358909e-05, -0.0004924523623733561, 0.0005333718539225543, -0.00025765087226601, -0.00014519511157405664, 0.00024576785641819003, 0.001987392470563443, -0.0015908076085160842, -0.0007568934908868987, 8.855355118073257e-05, -0.0019037301453423694, -0.0021770063469934817, 7.461655325738224e-05, 0.000462175497743351, 0.0005210146349210425, 0.0003568038603044771, 0.0004241373873707148, -8.741021895009534e-05, 0.000772174239832898, 0.00017911252172103442, -0.000829847159513602, 0.0004203673237735533, 0.0003133743498532781, 0.000593575431918884, 0.0003135947687543809, -0.0003645869544373544, 0.0006683068563840346, -0.00020235259595415136, 0.001349220965705753, -0.0020340670591110946, -0.00041769434735829526, -0.0004981501214739162, 0.0006561989502845671, 0.000669760559782651, 0.0003326533779073069, -0.00010200669939649307, -3.2386995946181664e-05, 0.0003588285620225712, -0.0011167815661772362, -0.00011310316823843577, -0.0005182390526102326, 0.0003693433943514537, 0.002024436428121275, 6.0997105182865915e-06, -0.0007129132283254319, 0.0001501522318223662, 7.891047353648714e-05, -0.0004697314657214998, -0.000254897406114653, -0.0011103794670150483, 0.0005577120453981939, 0.00018114685966135773, 0.0005649927159838467, 0.00010925773866533162, 0.0013098308064900127, 0.00023154969051534776, -0.0004285451549980843, -0.0019214804443266583, 0.00010493961393166586, 0.0005837263906034756, 1.6543113254048606e-05, 0.0007172526298240186, -0.0005886852065927795, -0.00041255570143160653, -1.9459509347031384e-05, 0.000291402983547018, 0.0023631139065301253, -0.0003622504630621428, 0.0005492262697211277, 0.0003626606834520612, -0.00011725487830694665, 0.0006326408323113677, -0.0004532188740792162, -4.913443894179339e-05, -0.0008856524048359493, 0.00039130561315146005, -0.0010554441938547467, 0.0015911591768067678, 0.000296077168203888, 0.0008531550437984701, -0.0012470707492369434, -0.000368735092190866, -0.00048243265489017283, -0.00023880076540505645, -0.00016790348150706597, -0.00043873361796145714, -0.0002913480105513663, -0.0014296564172633214, 0.0007144624338873749, 0.0008088391432223697, -0.0011814675472588269, 0.0005638966756702765, -0.0002339603888997489, -0.0003776586914134988, -0.00037553793891285383, 0.0003748364378593961, 0.00023082270999786524, -1.3543625332733382e-05, 0.000566545676492891, -0.0009057346890978281, -0.00017866687749221904, -0.001526913004987003, -0.0006720993529390468, 0.0002823459570464341, -0.0004450740135123615, 0.00047640791508281007, -0.0005958240895908187, -0.00017715665612174923, -0.00010080123864633324, 0.0004917574222360578, 0.0001138285229133618, 0.002465914169858405, 0.0005670600537261423, 0.00045625687103809787, -0.0007840586889616584, 0.00046319556626305263, -0.0010976838525113457, 0.0010725441033398978, -0.0016254531068346048, 0.0004917971699042798, 0.00013902751830996868, -0.00043005402852254687, -0.0011106718487453404, 0.00029494742812678375, 0.0009486028938960881, 0.0001670867459708942, -8.840799842513007e-05, 0.0006746453911334185, -0.00017727808190206177, 0.00010086513848317247, 0.00046922516881331053, 0.0004774571484740222, -1.0290901111203135e-05, 9.520162344092303e-05, 0.0003648541536849967, 0.00033538690108845924, -0.000960327363637412, 0.00013873546600079437, -0.0010232619266481232, -0.0020280638581877384, 0.0001567455390613696, 0.0014669352199031922, 6.782005972102013e-05, 0.0002352303451780971, -0.001821343288153858, -0.0001712081861449313, 0.00031081395506616337, 0.0009544698011518178, 0.0005112243747540542, 0.0002887346396428908, 0.00043685134241168444, 0.00042168939876234974, -0.0005880744341518443, 0.0003798195971433711, -0.0007184547018713771, 0.0003951313087168337, 9.562387290242932e-05, 0.0004981695413882228, -0.0005385273212058099, 0.000296764200450422, 0.00018748698401748, 0.00041741041859787474, 0.0008462363197504522, 0.0008791662395954949, 0.00019411531039167294, 0.0003920548724702504, -9.015497541533188e-05, 0.0004629664422454387, -0.0002590798902835395, 0.000619215728770989, -0.0006211483528622371, -8.748231255274872e-05, 0.0006053661413481926, 4.5199125752450315e-05, -0.00023116139793226005, -0.0013307036436834081, -0.0005217065577529301, 0.00020006978081617486, -0.0001372390219034168, 0.00018060544092251136, 0.0005113312361672036, 0.0002546040087449535, -0.0010117507630612913, 0.0002952656134773918, 3.685950063999722e-05, -0.002747881898223466, 4.469499790684989e-05, -8.64748135254941e-05, 0.0005410004348519962, 0.0002314964958088268, 0.0006949176380301295, 0.000481122335409309, -2.122607107855415e-06, 0.00033344339389782934, -0.00024176241352626937, 0.0003918579268656973, 0.0002879429302788722, 0.0002304104299996654, -0.0002932895815460491, 0.000270787659132965, -0.00022084427101548627, 0.0006743541201956554, -0.0007728670561707907, 0.00030135299603558974, -0.0006349737943818644, 0.0014365359029781866, -0.00046582802376684716, 1.5076197293738287e-05, 0.0003060496436397627, -0.00041029524968308923, -0.00015788139131724642, -0.0006897275444536018, 0.0004277381531197532, 0.00018702754553908004, 8.135788411259676e-05, -6.500751918266024e-06, -2.6289169547485133e-05, -0.0003809997311837905, 0.0008348293597586775, 0.0016111498319801166, -0.00035119055433390195, -0.001966510648060297, -0.001854197411075898, 9.623351486095679e-05, -0.0008975372710879016, 0.0002706853163176684, 0.00036832523220991164, 0.00027188591827131633, 0.0006172510979453672, 0.0010293698245156036, 0.0009252472588028924, -0.0002246569735282741, -0.000748439743863933, -0.00012681198711444338, -0.00024567151469336875, 0.000656837442748095, -0.0005604178701421391, 0.0007551552199390202, -0.0003587364527235524, -0.0003827050223400733, 0.00044335143140818774, 0.000845681099730772, -0.0004030859844640091, -0.0003294503463532275, 8.43833530135475e-06, 7.077903698494563e-05, 0.0015367722976354224, 0.0007166888660092409, 0.00031153766141145807, -0.000740150523125915, -0.0004208589331863031, 0.0010652399740192213, -0.0023318701940420986, 0.0011310873173778011, -0.0006987673480852243, 0.00028439181687007163, 0.00017189112510128236, 0.00012854852934878624, -0.0006356655893574796, -0.00017936708576597155, -5.1008730145817176e-05, -0.0006359047693557081, -0.00022095414634034296, 0.00043389480769891615, -0.00019156693945777045, -0.002034224252790802, 0.0005512118898921187, -0.00024372352518081702, 0.000500004620145614, 0.00046175745498500706, -0.0007875543712366582, 0.00011863247056773087, 0.00021952671299415615, 0.0026756915014432016, 0.002441093552811954, 0.00022963195358635362, -0.0009702125771836496, 8.240836326731117e-05, 0.0008214496531351811, 0.0003961329180581964, -0.0005430279556713573, 0.0004192266490019224, -0.0005862721448841857, 0.00020754331836952812, -0.000995228733370721, -0.0018821621462388287, 0.0030356300703595364, 0.0009888778436200859, 0.00026823687672701405, 0.0017078286119160963, -0.0006692785161963609, 0.0013962584972315815, 0.0010006047458768325, 0.00133878266456956, 0.00018680364364215193, -0.003126239803787991, 0.0008611476990846082, 0.0018530185046467208, -0.00038825335064714833, -0.0031494901010388422])
  d_i = flex.double([12.496125481007214, 5.37052061631852, 6.372901019116141, 12.254605390492443, 3.910692511204004, 15.364205358835587, 3.533629764565976, 5.304086248169242, 4.295690946012782, 4.810330279569616, 5.942651381509386, 6.732743795247132, 5.380219179235266, 5.176393854534195, 5.811451588887256, 9.86073770314327, 11.267954583147361, 8.051455824084014, 13.489749140504834, 4.262394408511081, 3.818664410371657, 9.146082465149595, 8.242144162922713, 6.998491803231956, 4.894566521635404, 10.538589954935542, 6.382100027448593, 6.739630640642708, 5.5720909369083795, 15.054184635104907, 5.602889558297534, 13.730239811504623, 8.834441325322528, 9.492459547512885, 4.4983049201266, 3.9472171964825526, 3.328081815517008, 6.102028074353887, 16.407749108432828, 7.4156834217017344, 12.33350632786428, 6.03929885968487, 10.112507267237426, 14.650970980703876, 4.354227890485642, 4.695835417519907, 5.308106305362877, 8.453074986016325, 4.610608490414736, 4.722677452030006, 4.522801150866567, 3.82988191020755, 17.303874026661116, 4.03098593858027, 6.645656252928453, 8.056889155395, 4.321350649642642, 4.470668902320949, 14.343022592219818, 11.634007634359032, 4.890912761964096, 7.745481157022565, 5.839804656396404, 3.81075724021023, 4.47599713621185, 8.88761560270757, 11.685191865651504, 4.99961976234618, 10.699399034308513, 5.789359755492081, 13.863427026668797, 8.957101840984425, 4.6411803580998985, 6.899566496421001, 8.568480519904112, 6.094202875387393, 10.26981985311339, 5.419346749424954, 12.131292783154962, 6.99657332957382, 2.928495136106975, 4.181326552706507, 4.328388215172019, 60.82350852196105, 3.7435046369156937, 8.214856764357352, 3.663624280559579, 5.15606066981975, 4.022474727761948, 3.460724085695112, 11.631629286533432, 9.485493288700827, 5.77452327854987, 6.067476499231714, 6.0541293208259095, 4.071762384305521, 6.812339742428627, 7.522097048418081, 16.179850215756723, 7.276357407186171, 5.304236279678581, 5.385333251169153, 4.720812443721588, 4.56105729909986, 13.093266557650766, 3.775383246849266, 7.820027063004571, 3.5168797740851456, 4.194967692763481, 25.204969624981516, 4.313206024194667, 7.574946313210257, 4.349272617183872, 15.24300821066979, 7.471511020269636, 5.90314382112432, 9.292926744985913, 14.219976039433982, 3.765569124064841, 9.62393299818646, 6.285899198025237, 5.089897013758276, 5.2501393830119865, 10.148226023325186, 5.034012631526682, 17.123810028063566, 3.839074892262106, 4.244233433501858, 4.57307566332094, 4.441108740950086, 5.644192425382879, 8.60282145831157, 5.060826474178333, 4.2739585775683935, 5.651692721633443, 48.65880681756884, 6.012416513212133, 21.21395651030999, 7.450329833462853, 4.417173963910764, 14.003924960571423, 4.564377591020246, 11.552659629181875, 7.492673234859181, 8.916318001238407, 4.612941352080246, 5.4872279141852225, 5.164663993158436, 19.920912918974874, 13.982863812203536, 7.597573158666213, 4.195756645048118, 6.204916116630871, 11.325085069834348, 3.712961032648373, 11.892005739297405, 10.51076480540115, 16.9565805497686, 15.142523290046086, 5.367351351195613, 4.2955657222016805, 5.03260891119849, 3.303967314482843, 7.841211790446599, 6.207961728665808, 7.492695529508777, 5.213933005710513, 15.1559302852355, 4.48129831940034, 13.070222041640184, 6.823222818766578, 4.106187481834676, 8.9441638850514, 3.871495075440654, 5.57343676231097, 4.094305666316854, 4.781151892971771, 13.489359644149292, 8.084700528360443, 9.050703383562649, 4.951089307222705, 14.418462557615156, 8.719472459583852, 6.392619555642581, 3.815692392843197, 42.24456424522369, 4.014854115378061, 3.1634932005038094, 5.732006234347408, 19.498633707649024, 3.6416727204379358, 9.5995718586154, 4.01408849076983, 4.122409679813531, 7.233480195110401, 5.139197297633144, 4.259370913647693, 3.9617898922070265, 7.196191950919739, 23.667578941975965, 9.249512180234662, 10.105711440619709, 7.16380030366351, 8.004553767574249, 7.027696766568184, 3.8779607714021993, 5.635875360232505, 11.510964885873696, 4.583928064240949, 14.052921618937866, 11.05100183058865, 6.12845593198528, 4.389050372448064, 11.01396313119337, 5.472063684012923, 13.818586876714331, 3.6729155613357247, 4.362528418640924, 4.906130925602242, 19.109307885207294, 14.443823945219787, 4.199486023147086, 4.012415775813075, 4.103568073708873, 9.419368652051263, 5.816915703079742, 5.680206147132252, 6.438077455875232, 13.693940569847175, 4.16937689551419, 4.933177894685913, 4.202502749203123, 4.205417716885984, 10.126403214726263, 7.473309968863036, 4.41112528911597, 8.121906312155456, 16.84742672297724, 4.912004822233266, 7.422518170511507, 29.607749061198362, 8.49851077266509, 6.700728072829796, 4.844292208906807, 4.762622701277455, 6.88968915462277, 5.904376987583908, 13.105330027735533, 9.802149798776435, 4.346689095666191, 5.211576597375097, 14.896116135402433, 5.238860650917186, 9.214013514566533, 5.315942359494999, 4.948910899444225, 9.050477090354756, 4.7714573134350795, 7.049819056592982, 5.125504244246154, 4.569039536035176, 9.123189618130095, 4.720570837577256, 4.659282741214248, 4.9115987368151055, 4.138631188117357, 4.09008938951596, 16.06930651273918, 5.070524208800141, 4.955528855250392, 8.636520586444291, 4.0236231198615755, 8.319115913550725, 7.637760226263567, 3.752374640232403, 5.8891498037736, 4.586144634471143, 5.407991465753737, 6.5447043084982885, 4.810548959988931, 4.226637781218769, 5.514553740920427, 8.721537473813992, 6.089475955698423, 4.0498662455841075, 8.469248378460339, 6.493004212326931, 11.71228607093485, 7.485554733525809, 13.863471534357938, 4.149813946121394, 7.76369241569881, 7.829665530857823, 11.449833160270478, 3.461150815247223, 5.586519230216418, 3.912160675664224, 5.4130519143910485, 7.309340988429196, 6.39772855344777, 7.196352963841612, 4.321892379055801, 4.180002755791975, 9.79925845308538, 4.437595161067206, 4.077163490716227, 3.518824922481227, 8.243859021989627, 4.293829981070743, 13.600860937908754, 15.818869148716827, 8.038342769166135, 27.9676802031808, 3.7954597635657636, 3.7681576916794, 11.21841997593632, 4.50519185363571, 4.248583197565239, 5.441423873628011, 6.582236136875411, 4.269009859165721, 4.006609217094649, 3.4499824689304246, 10.152538170367176, 4.853563986741619, 8.757816910560292, 4.685099084301029, 5.182771502238263, 6.175011439990506, 4.813893046318137, 5.245315060313983, 4.687759629878175, 4.027458256210232, 8.299170224121836, 7.258302751624717, 5.726666001978309, 3.5387581154953653, 3.732783931626053, 11.785021499785902, 4.260359845754977, 7.920285943017924, 9.921151247826097, 4.895282408700041, 6.3809201856609095, 7.388193009298489, 4.998942479288759, 7.864085768997293, 12.385608096963919, 4.340213295084278, 7.13225437905609, 6.870945078665965, 3.917568785581144, 4.007201686146074, 8.289551628970083, 10.678050225656552, 7.692900331546507, 17.209386824187273, 5.617022330577095, 5.096631830883907, 5.755584905102438, 5.815557660784512, 5.545857004980865, 6.363880567661076, 4.787428496579198, 3.817998379533764, 4.265808507121314, 6.694116933427199, 3.603656593455515, 6.399892861988105, 5.010452461299101, 3.167737577353923, 6.2733786513655305, 4.218896251710065, 7.560516452704808, 6.218962837118315, 14.418411789191287, 8.541553111988163, 6.348210353381056, 4.582088955770606, 4.7048798816712845, 8.979717270590134, 5.3840194549175875, 6.971525003589123, 3.8518734917684405, 4.519782744719283, 11.534278859319143, 4.886627903066536, 6.614765070369275, 5.550772592782202, 4.588578037352825, 10.055803374100478, 5.80703853874472, 16.71470174654123, 12.999475697363897, 4.172609416700113, 7.035850618852968, 6.313718680533122, 5.883730067159367, 3.9383882241309722, 4.152771317888124, 7.153086494495075, 6.108742919516945, 5.857862683330688, 15.09554146963721, 4.413477865264932, 4.833890795031411, 6.0365419977395005, 6.505972426698061, 4.465033292442182, 7.118929701084873, 6.739195966546418, 4.828646422818781, 6.449496429887082, 17.151082456014, 4.534905663341792, 3.8980523879878612, 4.2493847050360465, 8.569680382520453, 5.155830635721968, 5.1890171932141245, 15.333610147764423, 5.1504739777243715, 7.4714004918334815, 20.82257529950839, 7.870922932054178, 7.985936256728403, 3.636833419154957, 4.036675709894154, 10.047967668433717, 6.097540748846113, 4.614977881717082, 3.372262012615576, 8.11522512148733, 3.574993651140074, 8.04455663085853, 4.220409035691168, 9.63952269295869, 4.487317468055194, 5.382934232506098, 4.424911477840285, 4.332049432938316, 8.834308455656553, 5.838738943774013, 3.633765397287114, 18.787047900267638, 16.905764556687412, 3.467193680800522, 8.040273269281153, 3.6415070338608033, 7.046866166525815, 3.7988391750080437, 10.563461621911275, 6.917636324477366, 10.248950369608416, 5.016357547529524, 9.707940282836985, 13.846550734260434, 19.79263595985994, 7.525693533823855, 3.909750772351232, 14.695435562625814, 7.826561485909148, 9.46004259845192, 6.877868747512286, 12.434327938231078, 3.087677172795908, 11.57943133769928, 4.304608777648071, 14.758942891036405, 4.595167128766594, 9.767325535313098])
  minimizer(d_i, psi_i, eta_rad, Deff)


 *******************************************************************************


 *******************************************************************************
serialtbx/mono_simulation/util.py
from __future__ import absolute_import, division, print_function
from six.moves import range
from scitbx.array_family import flex
import math

def green_curve_area(twotheta, deltaphi):
  # the area under the green curve, in AD14 Figure 7.
  # some caveats:
  #   changing the cell parameters and wavelength will change two theta slightly
  #   changing the spot selection will change the area, since the area
  #   is sampled by the spotfinder spots that are actually used for the fit.
  #   So this is approximate only!

  order = flex.sort_permutation(twotheta)

  ordered_two_theta = twotheta.select(order)
  ordered_deltaphi = deltaphi.select(order)

  area = 0.
  for idx in range(len(ordered_deltaphi)-1):
    deltaX = ordered_two_theta[idx+1] - ordered_two_theta[idx]

    averageY = ordered_deltaphi[idx+1] + ordered_deltaphi[idx]

    area_of_trapezoid = deltaX * averageY
    area += area_of_trapezoid
  return area

def ewald_proximal_volume(wavelength_ang,resolution_cutoff_ang,domain_size_ang,full_mosaicity_rad):
    """computes the volume of reciprocal space (actually, half the volume, in this implementation) in which
    reciprocal lattice centroids will fall under the green curve.  In other words, this is proportional to the
    number of predicted reflections."""

    R_L = 1./wavelength_ang # radius of Ewald sphere

    # TT is the outermost two-theta angle to perform the volume integration (hi-resolution cutoff)
    TT = 2. * math.asin( wavelength_ang /
                         (2. * resolution_cutoff_ang) )

    part_vol = math.pi * (2./3.) * (1. - math.cos(TT))
    Ewald_sphere_volume = part_vol * math.pow(R_L, 3.) # base volume of Ewald sphere segment
    R_prime = R_L + 1./domain_size_ang
    domain_size_volume = part_vol * math.pow(R_prime, 3.) # expanded volume accomodating spot size

    # compicated integral for mosaic spread volume, must be calculated numerically
    summation = 0.
    N_terms = 100
    for x in range(N_terms):
      phi = (x/N_terms) * TT
      # inner integral over radius r
      integral = math.pow( R_prime + (full_mosaicity_rad * R_L * math.sin(phi)/2.), 3.) - \
                 math.pow( R_prime, 3. )
      summation += (integral * math.sin(phi)) * (TT/N_terms)
    mosaicity_volume = (2./3.) * math.pi * summation

    return (domain_size_volume - Ewald_sphere_volume) + mosaicity_volume


 *******************************************************************************


 *******************************************************************************
serialtbx/util/__init__.py


 *******************************************************************************


 *******************************************************************************
serialtbx/util/construct_frame.py
from __future__ import absolute_import, division, print_function
from six.moves import range

from scitbx.array_family import flex
from cctbx import crystal, miller
from cctbx.crystal_orientation import crystal_orientation
import cctbx

class ConstructFrame(object):
  def get_template_pickle(self):
    return {
                       'beam_s0': 0,
                       'beam_polarization_normal': 0,
                       'current_cb_op_to_primitive': 0,
                       'current_orientation':0,
                       'distance':0,
                       'effective_tiling':0,
                       'identified_isoform':None,
                       'mapped_predictions':[[]],
                       'max_signal':0,
                       'ML_domain_size_ang':[0],
                       'ML_half_mosaicity_deg':[0],
                       'mosaicity':0,
                       'model_partialities':[None],
                       'observations':[0],
                       'pointgroup':0,
                       'residual':0,
                       'sa_parameters':['None'],
                       's1_vec':[0],
                       'wavelength':0,
                       'xbeam':0,
                       'ybeam':0}

  def __init__(self, reflections, experiment):
    # assemble template and unpack files
    self.frame = self.get_template_pickle()
    self.pixel_size = experiment.detector[0].get_pixel_size()[0]

    if 'intensity.prf.value' in reflections:
      self.method = 'prf' # integration by profile fitting
    elif 'intensity.sum.value' in reflections:
      self.method = 'sum' # integration by simple summation
    self.reflections = reflections.select(reflections['intensity.' + self.method + '.variance'] > 0) # keep only spots with sigmas above zero

    self.xtal = experiment.crystal
    self.beam_obj = experiment.beam
    self.det = experiment.detector
    self.gonio = experiment.goniometer
    self.scan = experiment.scan
    self.img_sweep = experiment.imageset

  # experiment-dependent components ---------------------------------------------------------------------------

  # get wavelength
  def populate_wavelength(self):
    assert self.beam_obj.get_wavelength() is not None, "no wavelength"
    self.frame['wavelength'] = self.beam_obj.get_wavelength()
    self.frame['beam_s0'] = self.beam_obj.get_s0()
    self.frame['beam_polarization_normal'] = self.beam_obj.get_polarization_normal()

  # get detector distance in mm
  def populate_distance(self):
    assert self.det[0].get_distance() is not None, "no detector distance"
    self.frame['distance'] = self.det[0].get_distance()

  # get xbeam and ybeam in mm
  def populate_beam_dir(self):
    assert self.beam_obj.get_s0() is not None, "no beam direction"
    self.frame['xbeam'], self.frame['ybeam'] = self.det[0].get_beam_centre(self.beam_obj.get_s0())

  # get isoform
  def populate_isoform(self):
    if hasattr(self.xtal, "identified_isoform"):
      self.frame['identified_isoform'] = self.xtal.identified_isoform

  # get max signal
  def populate_max_signal(self):
    pass

  # get effective tiling
  def populate_effective_tiling(self):
    pass

  # indicate simulated annealing parameters, if present
  def populate_sa_params(self):
    pass

  # crystal-dependent components ------------------------------------------------------------------------------

  # generate a crystal orientation object from the A* matrix
  def populate_orientation(self):
    assert self.xtal.get_A() is not None, "no crystal orientation matrix"
    self.frame['current_orientation'] = [crystal_orientation(self.xtal.get_A(), True)]

  # generate change-of-basis operation for current to primitive cell
  def populate_op_to_primitive(self):
    assert self.xtal.get_space_group() is not None, "no space group"
    self.frame['current_cb_op_to_primitive'] = [self.xtal.get_space_group().z2p_op()]

  # fetch the point group associated with the crystal
  def populate_point_group(self):
    assert self.xtal.get_space_group() is not None, "no space group"
    self.frame['pointgroup'] = str(self.xtal.get_space_group().build_derived_point_group().info())

  # get mosaicity
  def populate_mosaicity(self):
    try:
      assert self.xtal.get_mosaicity() is not None, "no mosaicity"
      self.frame['mosaicity'] = self.xtal.get_mosaicity()
    except Exception:
      pass

  # get any available ML values
  def populate_ML_values(self):
    try:
      self.frame['ML_half_mosaicity_deg'] = [self.xtal.get_half_mosaicity_deg()]
    except AttributeError:
      pass
    try:
      self.frame['ML_domain_size_ang'] = [self.xtal.get_domain_size_ang()]
    except AttributeError:
      pass

  # observations-dependent components -------------------------------------------------------------------------

  # generate a miller array containing the Miller indices, intensities and variances for one frame
  def populate_observations(self):
    intensities = self.reflections['intensity.' + self.method + '.value']
    variances = self.reflections['intensity.' + self.method + '.variance']
    space_group = crystal.symmetry(self.xtal.get_unit_cell(), str(self.xtal.get_space_group().info()))
    miller_set = miller.set(space_group, self.reflections['miller_index'])
    self.frame['observations'][0] = cctbx.miller.array(miller_set, intensities, flex.sqrt(variances)).set_observation_type_xray_intensity()
    self.frame['s1_vec'][0] = self.reflections['s1']

  # collect predicted spot positions
  def populate_pixel_positions(self):
    assert 'xyzcal.px' in self.reflections, "no calculated spot positions"
    self.frame['mapped_predictions'][0] = flex.vec2_double()
    for i in range(len(self.reflections['xyzcal.px'])):
      self.frame['mapped_predictions'][0].append(tuple(self.reflections['xyzcal.px'][i][1::-1])) # 1::-1 reverses the order taking only the first two elements first.

  # generate a list of dictionaries containing a series of corrections for each predicted reflection
  def populate_corrections(self):
    assert 'xyzobs.px.value' in self.reflections and 'xyzcal.px' in self.reflections, "no calculated or observed spot positions"
    assert self.frame['xbeam'] != 0 and self.frame['ybeam'] != 0, "invalid beam center"
    self.frame['correction_vectors'] = [[]]
    for idx in range(len(self.reflections['xyzobs.px.value'])):
      if self.reflections['xyzcal.px'][idx][0:2] != self.reflections['xyzobs.px.value'][idx][0:2]:
        theoret_center = 1765/2, 1765/2
        refined_center = self.frame['xbeam']/self.pixel_size, self.frame['ybeam']/self.pixel_size # px to mm conversion
        hkl = self.reflections['miller_index'][idx]
        obsspot = tuple(self.reflections['xyzobs.px.value'][idx][0:2])
        predspot = tuple(self.reflections['xyzcal.px'][idx][0:2])
        self.frame['correction_vectors'][0].append({'refinedcenter':refined_center, 'hkl':hkl, 'setting_id':0, 'azimuthal':0, 'radial':0,
          'obsspot':obsspot, 'obscenter':theoret_center, 'predspot':predspot})

  # get partialities
  def populate_partialities(self):
    pass

  # produce residuals
  def populate_residuals(self):
    pass

  # collect kapton corrections if present
  def populate_kapton_corrections(self):
    if 'kapton_absorption_correction' in self.reflections:
      self.frame['fuller_kapton_absorption_correction'] = [self.reflections['kapton_absorption_correction']]
      if 'kapton_absorption_correction_sigmas' in self.reflections:
        self.frame['fuller_kapton_absorption_correction_sigmas'] = [self.reflections['kapton_absorption_correction_sigmas']]

  # combine all of the above
  def make_frame(self):
    self.populate_wavelength()
    self.populate_distance()
    self.populate_beam_dir()
    self.populate_isoform()
    self.populate_max_signal()
    self.populate_effective_tiling()
    self.populate_sa_params()
    self.populate_orientation()
    self.populate_op_to_primitive()
    self.populate_point_group()
    self.populate_mosaicity()
    self.populate_ML_values()
    self.populate_observations()
    self.populate_pixel_positions()
    # self.populate_corrections() # works, but unnecessary
    self.populate_partialities()
    self.populate_residuals()
    self.populate_kapton_corrections()
    return self.frame


 *******************************************************************************


 *******************************************************************************
serialtbx/util/energy_scan_notch_finder.py
from __future__ import division

from matplotlib import pyplot as plt
import numpy as np
from numpy.polynomial import Polynomial as Poly

"""When an energy scan is conducted at LCLS, we acquire FEE spectra of the incident beam with a varying, known, narrow energy band removed -- the "notch". Energy calibration is the process of identifying the notch in each scan and using the known pixel-energy pairs to generate a function (linear fit) returning the energy for any given pixel position on the spectrometer (reported FEE energy in xtc streams). This file supplies functions necessary for automating this process. Functionality custom to LCLS (calling the psana api to read xtc streams) and the end-to-end automated process are provided in cctbx_project/xfel/command_line."""

notch_phil_string = """
fit_half_range = 3
  .type = int
  .help = how many steps (pixels) above and below the notch do we use to fit the notch shape
kernel_size = 30
  .type = int
  .help = how many steps (pixels) do we incorporate into the moving average smoothing kernel
baseline_cutoff = 0.01
  .type = float
  .help = consider this fraction of the beam profile maximum to be the baseline, and when we inflate values to account for the curved shape of the profile, don't inflate (divide) by any smaller fractions than this
reference_spectrum = None
  .type = path
  .help = if we have a notch-free FEE spectrum to use as a reference, subtract this directly instead of a smoothed spectrum to convert the notch to an absolute minimum
per_run_plots = False
  .type = bool
  .help = for each run, additionally plot original pixel data, smoothed or reference data, and scaled flattened data from which notch position is finally determined
"""

def find_notch(data_x, data_y, kernel_size, fit_half_range, baseline_cutoff, ref_spectrum=None, minima=False):
  """Given a series that smoothly increases and then decreases, with a notch cut out somewhere,
     find the position in data_x that we expect (via interpolation) corresponds to the true
     minimum or maximum of the notch in data_y. This is empirically a good way to find the notches of known
     energies in the FEE spectra."""
  if ref_spectrum is not None: # subtract baseline from data_y
    flattened_y = data_y - ref_spectrum
  else: # subtract smoothed data_y from data_y
    # smooth data_y
    kernel = np.ones(kernel_size)/kernel_size
    smoothed_y = np.convolve(data_y, kernel, mode='same')
    if minima:
      # subtract smoothed shape to isolate notch as an absolute minimum
      flattened_y = data_y - smoothed_y
      # scale to account for scan shape
      minimum = max(smoothed_y)*baseline_cutoff
      scale = np.max([smoothed_y, np.ones(len(smoothed_y))*minimum], axis=0)
      flattened_y /= scale
    else:
      flattened_y = smoothed_y
  # isolate a range where the notch can be approximated by a small degree polynomial
  if minima:
    rough_min_idx = np.argmin(flattened_y)
  else:
    rough_max_idx = np.argmax(flattened_y)

  start = rough_max_idx - fit_half_range
  end = rough_max_idx + fit_half_range
  # model it as a parabola
  notch_shape = Poly.fit(data_x[start:end+1], data_y[start:end+1], 2)
  fitted_x = notch_shape.deriv().roots()[0]
  fitted_y = notch_shape.__call__(fitted_x)
  return ((fitted_x, fitted_y), notch_shape, smoothed_y, flattened_y)

def plot_notches(runs, rundata, notches, per_run_plots=False, use_figure=None):
  """Plot the energy scan, optionally one plot per spectrum for troubleshooting misses when automatically identifying notch positions, and always as an overlay of spectra in the scan with notch positions marked."""
  if per_run_plots:
    for run, data_y, notch in zip(runs, rundata, notches):
      data_x = range(len(data_y))
      (notch_x, notch_y), notch_shape, smoothed_y, flattened_y = notch
      plt.title("FEE spectrum for run %d"%run)
      plt.xlabel("FEE spectrometer pixels")
      plt.ylabel("Mean counts")
      plt.plot(data_x, data_y, 'g-', label="raw energy scan")
      plt.plot(data_x, smoothed_y, 'y-', label="smoothed scan")
      plt.plot(data_x, flattened_y*max(smoothed_y), 'b-', label="scaled flattened scan")
      plt.plot([notch_x], [notch_y], 'k+', label=f"notch found at {int(notch_x)} pixels".format())
      plt.legend()
      plt.figure()

  fig = use_figure or plt.figure()
  ax = fig.subplots()
  for run, data, notch in zip(runs, rundata, notches):
    (notch_x, notch_y), notch_shape, smoothed_y, flattened_y = notch
    ax.plot(range(len(data)), data, '-', label=f"run {run}: notch at {int(notch_x)} pixels".format())
    ax.plot([notch_x], [notch_y], 'k+', label="_nolegend_")
  # repeat last one to add legend
  ax.plot([notch_x], [notch_y], 'k+', label="identified notches")

  ax.legend()
  ax.set_title("Energy scan")
  ax.set_xlabel("FEE spectrometer pixels")
  ax.set_ylabel("Mean counts")

def calibrate_energy(notches, energies, return_trendline=False, use_figure=None):
  """Having identified the pixel positions on the FEE spectrometer corresponding to known energy values, get a linear fit of these ordered pairs and report the eV offset and eV per pixel matching the fit."""
  pixels = [n[0][0] for n in notches]
  linear_fit = Poly.fit(pixels, energies, 1).convert()
  eV_offset, eV_per_pixel = linear_fit.coef
  print(f"Calibrated eV offset of {eV_offset} and eV per pixel of {eV_per_pixel}".format())
  fig = use_figure or plt.figure()
  ax = fig.subplots()
  ax.scatter(pixels, energies, color='k', label="known energy positions")
  px_min = int(min(pixels))
  px_max = int(max(pixels))
  px_range = px_max - px_min
  trendline_x = np.arange(px_min-0.1*px_range, px_max+0.1*px_range, int(px_range/10))
  trendline_y = linear_fit.__call__(trendline_x)
  ax.plot(trendline_x, trendline_y, 'b-', label=f"linear fit: y = {eV_per_pixel:.4f}*x + {eV_offset:.4f}".format())
  ax.set_xlabel("FEE spectrometer pixels")
  ax.set_ylabel("Energy (eV)")
  ax.set_title("Energy calibration")
  ax.legend()
  if use_figure is None:
    plt.show()
  if return_trendline:
    return ((eV_offset, eV_per_pixel), (linear_fit, trendline_x, trendline_y))
  else:
    return (eV_offset, eV_per_pixel)



 *******************************************************************************


 *******************************************************************************
serialtbx/util/time.py
from __future__ import division

import math, time

def now_s_ms():
  """The now_s_ms() function returns the time since
  midnight, 1 January 1970 UTC (Unix time) to millisecond precision.

  @return    Unix time as a tuple of seconds and milliseconds
  """

  t = time.time()
  s = int(math.floor(t))
  return (s, int(round((t - s) * 1000)))

def timestamp(t=None):
  """The timestamp() function returns a string representation of
  an extended human-readable ISO 8601 timestamp.  If @p t is @c None
  the current time is used.

  @param t Tuple of the time in seconds and milliseconds
  @return  Human-readable ISO 8601 timestamp in string representation
  """

  if t is None:
    t = now_s_ms()
  return time.strftime("%Y-%m-%dT%H:%MZ%S", time.gmtime(t[0])) + \
      (".%03d" % t[1])


 *******************************************************************************
